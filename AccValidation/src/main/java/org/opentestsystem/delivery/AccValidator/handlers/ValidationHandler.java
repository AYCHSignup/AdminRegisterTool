package org.opentestsystem.delivery.AccValidator.handlers;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.UnknownHostException;
import java.text.DateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;

import javax.xml.XMLConstants;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.transform.stream.StreamSource;
import javax.xml.validation.Schema;
import javax.xml.validation.SchemaFactory;
import javax.xml.validation.Validator;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.delivery.AccValidator.Data.AccFamilySubject;
import org.opentestsystem.delivery.AccValidator.Data.AccommodationOption;
import org.opentestsystem.delivery.AccValidator.Data.AccommodationText;
import org.opentestsystem.delivery.AccValidator.Data.MasterResourceAccommodation;
import org.opentestsystem.delivery.AccValidator.Data.ResourceFamily;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;

/**
 * Handles requests for the application home page.
 */

public class ValidationHandler
{

  String                      nodeName = null;
  static ApplicationContext   _context = new ClassPathXmlApplicationContext (new String[] { "root-context.xml" });
  private static final Logger logger   = LoggerFactory.getLogger (ValidationHandler.class);
  // Todo Shajib: input filepath from user
  @Value ("${XmlValidation.configFilePath:}")
  String                      filePath;                                                                           // =
                                                                                                                   // "C:/Users/mskhan/Desktop/2015.07.08.TaskOrder10DesignOutputs/AccessibilityConfig.v3.xml";
  @Value ("${XmlValidation.xsdFilePath:}")
  String                      xsdPath;                                                                            // =
                                                                                                                   // "C:/Users/mskhan/Desktop/2015.07.08.TaskOrder10DesignOutputs/AccessibilityConfig.v2.xsd";

  public static void main (String[] args) {
    ValidationHandler validator = (ValidationHandler) _context.getBean ("validationHandler");
    String xml = validator.filePath;
    String xsd = validator.xsdPath;
    if (xml == null && args.length >= 2)
    {
      xml = args[0];
      xsd = args[1];
    }
    System.out.println ("Accommodations' config file is valid:" + validator.validateXmlAccs (xml, xsd));
  }

  public boolean validateXmlAccs (String filePath, String xsdPath)
  {
    try {
      InputStream xmlInput = new FileInputStream (new File (filePath));
      InputStream xsdInput = new FileInputStream (new File (xsdPath));

      StringBuffer textSB = new StringBuffer ();
      String text = null;
      XMLInputFactory factory = XMLInputFactory.newInstance ();
      XMLStreamReader reader = factory.createXMLStreamReader (xmlInput);

      MasterResourceAccommodation masterResource = null;
      List<MasterResourceAccommodation> masterResourceAccommodations = null;
      List<MasterResourceAccommodation> resourceFamiltyMasterResourceAccommodations = null;
      AccommodationText accommodationText = null;
      AccommodationOption accommodationOption = null;
      List<AccommodationOption> accommodationOptions = null;
      AccFamilySubject familySubject = null;
      List<AccFamilySubject> familySubjects = null;
      ResourceFamily resourceFamily = null;
      List<ResourceFamily> resourceFamilies = new ArrayList<ResourceFamily> ();
      List<String> grades = null;

      while (reader.hasNext ()) {
        int event = reader.next ();

        switch (event) {
        case XMLStreamConstants.START_ELEMENT: {
          System.out.println ("Start Element ->" + reader.getLocalName ());
          if ("MasterResourceFamily".equals (reader.getLocalName ())) {
            masterResourceAccommodations = new ArrayList<MasterResourceAccommodation> ();
          }
          if ("SingleSelectResource".equals (reader.getLocalName ())) {
            // if (resourceFamily == null) {
            masterResource = new MasterResourceAccommodation ();
            accommodationOptions = new ArrayList<AccommodationOption> ();
          }
          if ("MultiSelectResource".equals (reader.getLocalName ())) {
            masterResource = new MasterResourceAccommodation ();
            accommodationOptions = new ArrayList<AccommodationOption> ();
          }
          if ("EditResource".equals (reader.getLocalName ())) {
            masterResource = new MasterResourceAccommodation ();
            accommodationOptions = new ArrayList<AccommodationOption> ();
          }
          if ("Text".equals (reader.getLocalName ())) {
            accommodationText = new AccommodationText ();
          }
          if ("Selection".equals (reader.getLocalName ())) {
            accommodationOption = new AccommodationOption ();
          }
          if ("ResourceFamily".equals (reader.getLocalName ())) {
            familySubjects = new ArrayList<AccFamilySubject> ();
            resourceFamily = new ResourceFamily ();
            resourceFamiltyMasterResourceAccommodations = new ArrayList<MasterResourceAccommodation> ();
            grades = new ArrayList<String> ();
          }
          if ("Subject".equals (reader.getLocalName ())) {
            familySubject = new AccFamilySubject ();
          }
          break;
        }
        case XMLStreamConstants.CHARACTERS: {

          textSB.append (getContents (reader.getText ().trim ()));
          if (textSB.length () > 0) {
            text = textSB.toString ();
            System.out.println ("Text ->" + text);
          }

          break;
        }
        case XMLStreamConstants.END_ELEMENT: {
          textSB.setLength (0);
          System.out.println ("End Element ->" + reader.getLocalName ());
          switch (reader.getLocalName ()) {
          case "MultiSelectResource":
            masterResource.setResourceType ("MultiSelectResource");
            masterResource.setOptions (accommodationOptions);
            if (resourceFamily == null) {
              masterResourceAccommodations.add (masterResource);
            } else {
              resourceFamiltyMasterResourceAccommodations.add (masterResource);
            }
            accommodationOptions = null;
            masterResource = null;
            break;
          case "SingleSelectResource":
            masterResource.setResourceType ("SingleSelectResource");
            masterResource.setOptions (accommodationOptions);
            if (resourceFamily == null) {
              masterResourceAccommodations.add (masterResource);
            } else {
              resourceFamiltyMasterResourceAccommodations.add (masterResource);
            }
            accommodationOptions = null;
            masterResource = null;
            break;

          case "EditResource":
            masterResource.setResourceType ("EditResource");
            masterResource.setOptions (accommodationOptions);
            masterResourceAccommodations.add (masterResource);
            accommodationOptions = null;
            masterResource = null;
            break;
          case "Code":
            if (accommodationOption == null) {
              if (familySubject == null) {
                masterResource.setCode (text);
              } else {
                familySubject.setCode (text);
              }
            } else {
              accommodationOption.setCode (text);
            }
            break;
          case "Order":
            if (accommodationOption == null) {
              masterResource.setOrder (Integer.parseInt (text));
            } else {
              accommodationOption.setOrder (Integer.parseInt (text));
            }
            break;
          case "DefaultSelection":
            masterResource.setDefaultSelection (text);
            break;
          case "Language":
            accommodationText.setLanguage (text);
            break;
          case "Label":
            accommodationText.setLabel (text);
            break;
          case "Text":
            if (accommodationOption == null) {
              masterResource.setHeader (accommodationText);
              accommodationText = null;
            } else {
              accommodationOption.setText (accommodationText);
            }
            break;
          case "Selection":
            accommodationOptions.add (accommodationOption);
            accommodationOption = null;
            break;
          case "ResourceFamily":
            resourceFamily.setSubject (familySubjects);
            resourceFamily.setGrade (grades);
            resourceFamily.setMasterResourceAccommodation (resourceFamiltyMasterResourceAccommodations);
            resourceFamilies.add (resourceFamily);
            familySubjects = null;
            grades = null;
            resourceFamily = null;
            resourceFamiltyMasterResourceAccommodations = null;
            break;
          case "Name":
            familySubject.setName (text);
            break;
          case "Subject":
            familySubjects.add (familySubject);
            familySubject = null;
            break;
          case "Grade":
            grades.add (text);
            break;

          case "Message":
            accommodationText.setMessage (text);
            break;

          case "Description":
            accommodationText.setDescription (text);
            break;
          }
          break;
        }
        }
      }
      System.out.println ("masterResourceAccommodations size :: " + masterResourceAccommodations.size ());
      for (MasterResourceAccommodation accommodation : masterResourceAccommodations) {
        System.out.println (accommodation);
      }
      System.out.println ("resourceFamilies size :: " + resourceFamilies.size ());
      for (ResourceFamily family : resourceFamilies) {
        System.out.println (family);
      }

      boolean valid = validateRules (masterResourceAccommodations, resourceFamilies);
      // validation against xsd
      xmlInput = new FileInputStream (new File (filePath));
      xsdInput = new FileInputStream (new File (xsdPath));
      boolean validXsd = validateAgainstXSD (xmlInput, xsdInput);
      return validXsd && valid;

    } catch (IOException e) {
      e.printStackTrace ();
    } catch (XMLStreamException e) {
      e.printStackTrace ();
    }
    return false;
  }

  /**
   * @param masterResourceAccommodations
   * @param resourceFamilies
   */
  private boolean validateRules (List<MasterResourceAccommodation> masterResourceAccommodations, List<ResourceFamily> resourceFamilies) {
    HashMap<String, MasterResourceAccommodation> masterResourcesMap = new HashMap<String, MasterResourceAccommodation> ();
    for (MasterResourceAccommodation resource : masterResourceAccommodations)
    {
      if (masterResourcesMap.containsKey (resource.getCode ()))
      {
        logger.error ("Multiple resource with code:" + resource.getCode () + " within MasterResourceFamily.");
        return false;
      }
      // Order must be positive integer
      boolean invalidOrder = false;
      if (resource.getOrder () <= 0)
        invalidOrder = true;
      else
      {
        for (AccommodationOption selection : resource.getOptions ())
        {
          if (selection.getOrder () <= 0)
          {
            invalidOrder = true;
            break;
          }
        }
      }
      if (invalidOrder)
      {
        logger.error ("Order must be positive integer.");
        return false;
      }
      masterResourcesMap.put (resource.getCode (), resource);
    }

    HashMap<String, List<String>> resourceFamilyMap = new HashMap<String, List<String>> ();

    for (ResourceFamily resourceFamily : resourceFamilies)
    {
      /*
       * 2. The subject and grade(s) for a Resource Family must be defined in
       * the Resource Family.
       */
      if (resourceFamily.getSubject ().size () <= 0)
      {
        logger.error ("ResourceFamily has no subject defined");
        return false;
      }
      /*
       * 4. If a Resource Family is defined for a subject-grade combination that
       * is already defined by a previous Resource Family, The second Resource
       * Family will be ignored in favor of the settings of the first Resource
       * Family that covers the particular subject-grade combination.
       */
      String subjectCode = resourceFamily.getSubject ().get (0).getCode ();
      if (!StringUtils.isEmpty (subjectCode) && resourceFamilyMap.containsKey (subjectCode))
      {
        List<String> grades = resourceFamilyMap.get (subjectCode);
        List<String> newGrades = resourceFamily.getGrade ();
        boolean same = true;
        if (grades.size () == newGrades.size ())
        {
          for (int i = 0; i < newGrades.size (); i++)
            if (!grades.contains (newGrades.get (i)))
            {
              same = false;
              break;
            }
          if (same)
          {
            logger.error ("Subject:" + subjectCode + " and grades:" + grades + " already exists.");
            return false;
          }
        }
      }
      else
      {
        resourceFamilyMap.put (subjectCode, resourceFamily.getGrade ());
      }
      /*
       * 1. Resource codes and selection codes in Resource Families must be
       * present in the Master Resource Family. No new resources or selections
       * can be defined in subesquent Resource Familes.
       */
      for (MasterResourceAccommodation resource : resourceFamily.getMasterResourceAccommodation ())
      {

        MasterResourceAccommodation masterResource = masterResourcesMap.get (resource.getCode ());

        if (masterResource == null)
        {
          logger.error ("ResourceFamily code:" + resource.getCode () + " does not exist in master.");
          return false;
        }
        /*
         * 6. The following things for a resource defined in the Master Resource
         * Family cannot be overriden: Code, Order Type, Text/Label,
         * Text/Description. This restriction ensures consistency of the
         * resource for tabular user interface and file upload formats. Only the
         * resource default selection can be overridden.
         */

        // header can't be overridden in resource
        if (resource.getHeader () != null)
        {
          logger.error ("Header for resource:" + resource.getCode () + " can't be overridden.");
          return false;
        }

        // order can't be overridden in resource
        if (resource.getOrder () > 0 && masterResource.getOrder () != resource.getOrder ())
        {
          logger.error ("For resource:" + resource.getCode () + " there is mismatch in order.");
          return false;
        }
        HashMap<String, AccommodationOption> selectionsMap = new HashMap<String, AccommodationOption> ();
        for (AccommodationOption selection : masterResource.getOptions ())
        {
          selectionsMap.put (selection.getCode (), selection);
        }

        boolean defaultFound = false;
        for (AccommodationOption selection : resource.getOptions ())
        {
          if (selection.getCode ().equals (resource.getDefaultSelection ()) || (resource.getDefaultSelection () == null && selection.getCode ().equals (masterResource.getDefaultSelection ())))
            defaultFound = true;
          String code = selection.getCode ();
          // Order must be positive integer
          if (selection.getOrder () != null && selection.getOrder () <= 0)
          {
            logger.error ("Order must be positive integer");
            return false;
          }
          // order can't be overridden in selection
          if (selection.getOrder () != null && selection.getOrder () != selectionsMap.get (code).getOrder ())
          {
            logger.error ("Selection:" + selection.getCode () + " Resource:" + resource.getCode () + " has mismatch in order.");
            return false;
          }
          if (!selectionsMap.containsKey (code))
          {
            logger.error ("Selection code:" + selection.getCode () + " does not exist in master resource.");
            return false;
          }
        }
        // Rami-4. The default selection must appear as one of the resource
        // selections
        if (masterResource.getDefaultSelection () != null && (!defaultFound || !selectionsMap.containsKey (masterResource.getDefaultSelection ())))
        {
          logger.error ("Default selection not found in selections for resource:" + resource.getCode ());
          return false;
        }
        /*
         * Nothing to validate. 2. If a resource defined in the Master Resource
         * Family is completely omitted from a Resource Family, then the ART UI
         * will inherit all text and selection information about the resource
         * from the Master Resource Family. position defined by the Order
         * attribute
         */
        /*
         * Already handled. 3(a). If a resource defined in the Master Resource
         * Family is also present in a Resource Family, then: a. The code and
         * English and translated text of the resource cannot be overridden
         */
        /*
         * Nothing to validate in xml 3(b). The default code and translations
         * for the resource may be overridden.
         */
        /*
         * Nothing to validate in xml 3(c). The UI will only display resource
         * selections that are repeated in the Resource Family for the resource
         * and will not display any selections that are omitted for the resource
         * in the Resource Family. This permits configuration of display of only
         * certain selections and suppression of other selections for the
         * subject/grade combination of a Resource Family.
         */
        /*
         * Already handled 3(d). No new codes can be created for a selection in
         * a Resource Family that are not already provided in the Master
         * Resource Family.
         */
        /*
         * No validation required in xml 3(e). All text fields for resource
         * selections defined in the Master Resource Family can be overridden in
         * a Resource Family.
         */

        /*
         * Resource Families modify the behavior of the Master Resource Family
         * for specific subjects and for specific student grades. The following
         * rules apply to resource families:
         */

        /*
         * Nothing to validate in xml 1. Resource families are not strictly
         * required. If the intent is that all subjects and grades get exactly
         * the same resources and selections, then the configuration from the
         * Master REsource Family will be used for all grades and subjects.
         */

        /*
         * Nothing to validate in xml 3. Resource Families can be defined for
         * some subjects and grades, but do not have to be provided for every
         * possible subject and grade. The Master Resource Family will be used
         * for any subject/grade combination for which there is no Resource
         * Family defined. nothing to check
         */

        /*
         * Already checked 5. No new codes can be defined in Resource Families
         * that are not already defined in the Master Resource Family. Another
         * way of looking at this is that new resources cannot be defined in
         * Resource Families, only in the Master Resource Family.
         */

        /*
         * Already handled 7. The following things for a resource selection
         * cannot be overridden: Code, Order. Text/Label, Text/Description and
         * Text/Message can all be overridden for resource selections.
         */

      }
    }

    return true;
  }

  static boolean validateAgainstXSD (InputStream xml, InputStream xsd)
  {
    try
    {
      SchemaFactory factory =
          SchemaFactory.newInstance (XMLConstants.W3C_XML_SCHEMA_NS_URI);
      Schema schema = factory.newSchema (new StreamSource (xsd));
      Validator validator = schema.newValidator ();
      validator.validate (new StreamSource (xml));
      return true;
    } catch (Exception ex)
    {
      return false;
    }
  }

  private String getContents (String nodeValue) {
    StringBuffer sb = new StringBuffer ();
    if (nodeValue != null) {
      char[] ch = nodeValue.toCharArray ();
      for (char c : ch) {

        if (c == '\t' || c == '\n') {

        } else {
          sb.append (c);
        }
      }
    }
    return sb.toString ();

  }

}
