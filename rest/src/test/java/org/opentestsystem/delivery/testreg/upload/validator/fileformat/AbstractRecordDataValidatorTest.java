/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/

package org.opentestsystem.delivery.testreg.upload.validator.fileformat;

import static org.apache.commons.lang.ArrayUtils.isEmpty;
import static org.apache.commons.lang.ArrayUtils.isEquals;
import static org.hamcrest.core.Is.is;
import static org.junit.Assert.assertThat;
import static org.springframework.validation.ValidationUtils.invokeValidator;

import java.util.ArrayList;
import java.util.List;

import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.delivery.testreg.upload.DataRecord;
import org.opentestsystem.delivery.testreg.upload.FileDataRecord;
import org.opentestsystem.delivery.testreg.upload.FileHeaderRecord;
import org.springframework.test.util.ReflectionTestUtils;
import org.springframework.validation.BeanPropertyBindingResult;
import org.springframework.validation.Errors;
import org.springframework.validation.ObjectError;
import org.springframework.validation.Validator;

public class AbstractRecordDataValidatorTest {

    private final String[] configuredColumns = { "SSID", "GRADE", "GENDER", "IEP", "LEP" };
    private static final String[] testRecord1 = new String[] { "122332", "A", "M", "122", "AW3342L" };
    private static final String[] testRecord2 = new String[] { "909990", "D", "F", "2092", "999NM" };
    private List<DataRecord> recordsList;
    private boolean formatValidatorCalled = false;
    private boolean businessValidatorCalled = false;
    private boolean headerValidatorCalled = false;

    private Validator validator;
    private Errors result;

    private int numberOfTimesFormatValidatorCalled = 0;
    private int numberOfTimesHeaderValidatorCalled = 0;
    private int numberOfTimesBusinessValidatorCalled = 0;

    @Before
    public void setup() {
        recordsList = new ArrayList<DataRecord>();
        result = new BeanPropertyBindingResult("", "");
        validator = new AbstractRecordDataValidator("CLIENT") {

            @Override
            protected boolean isValidFormat(final FileDataRecord record, final Errors error) {
                formatValidatorCalled=true;
                numberOfTimesFormatValidatorCalled++;
                return isEmpty(record.getColumns()) ? false:true;
            }

            public Validator setHeadersAndReturnValidator() {
                setHeaders(configuredColumns);
                return this;
            }

            @Override
            protected boolean isValidData(final FileDataRecord record, final Errors errors) {
                businessValidatorCalled=true;
                numberOfTimesBusinessValidatorCalled++;
                return (isEquals(record.getColumns(), testRecord1) || isEquals(record.getColumns(), testRecord2)) ? true:false;
            }

            @Override
            protected boolean isValidHeader(final FileHeaderRecord record, final Errors errors) {
                headerValidatorCalled=true;
                numberOfTimesHeaderValidatorCalled++;
                return isEquals(record.getColumns(), headers) ? true:false;
            }
        }.setHeadersAndReturnValidator();
        ReflectionTestUtils.setField(validator, "duplicateRecordProcessor", new DuplicateRecordProcessor());
        recordsList.add(new FileHeaderRecord(configuredColumns));
    }



    @Test
    public void testConcreteValidatorCalled() {
        recordsList.add(new FileDataRecord(2, testRecord1));
        invokeValidator(validator, recordsList, result);
        assertThat(result.hasErrors(), is(false));
        assertThat(headerValidatorCalled, is(true));
        assertThat(formatValidatorCalled, is(true));
        assertThat(businessValidatorCalled, is(true));

        assertThat(numberOfTimesHeaderValidatorCalled, is(1));
        assertThat(numberOfTimesFormatValidatorCalled, is(1));
        assertThat(numberOfTimesBusinessValidatorCalled, is(1));
    }
   

    @Test
    public void testDuplicateRecords() {
        recordsList.add(new FileDataRecord(2, testRecord1));
        recordsList.add(new FileDataRecord(4, new String[] { "5442", "AF", "MB", "455", "0909K" }));
        recordsList.add(new FileDataRecord(5, testRecord1));
        recordsList.add(new FileDataRecord(6, testRecord2));
        recordsList.add(new FileDataRecord(7, new String[] { "9091", "GH", "JK", "WER", "098H9R"}));
        recordsList.add(new FileDataRecord(8, testRecord2));
        recordsList.add(new FileDataRecord(9, testRecord1));

        invokeValidator(validator, recordsList, result);
        assertThat(result.hasErrors(), is(true));

        assertThat(headerValidatorCalled, is(false));
        assertThat(formatValidatorCalled, is(false)); 
        assertThat(businessValidatorCalled, is(false)); 

        assertThat(numberOfTimesHeaderValidatorCalled, is(0));
        assertThat(numberOfTimesFormatValidatorCalled, is(0));
        assertThat(numberOfTimesBusinessValidatorCalled, is(0));
        String[] messages = {"Duplicates records found matching in rows {2,5,9}", "Duplicates records found matching in rows {6,8}"};
        List<String> errorMessages = new ArrayList<String>();
        for(ObjectError error: result.getAllErrors()) {
            errorMessages.add(error.getDefaultMessage());
        }
        assertThat(isEquals(errorMessages.toArray(new String[2]), messages), is(true));
    }
}
