/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.delivery.testreg.integration;

import static org.junit.Assert.assertTrue;
import static org.springframework.test.util.AssertionErrors.assertEquals;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.fileUpload;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.put;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.patch;

import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import org.junit.After;
import org.junit.Before;
import org.junit.runner.RunWith;
import org.opentestsystem.shared.exception.RestException;
import org.opentestsystem.shared.mna.client.listener.ClientSpringConfigurator;
import org.opentestsystem.shared.progman.init.InitSpringPropertyConfigLoad;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.mock.web.MockHttpServletResponse;
import org.springframework.mock.web.MockMultipartFile;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.web.WebAppConfiguration;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;
import org.springframework.test.web.servlet.ResultMatcher;
import org.springframework.test.web.servlet.request.MockHttpServletRequestBuilder;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.context.WebApplicationContext;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.collect.Maps;

import de.flapdoodle.embed.mongo.MongodStarter;
import de.flapdoodle.embed.mongo.config.MongodConfigBuilder;
import de.flapdoodle.embed.mongo.config.Net;
import de.flapdoodle.embed.mongo.distribution.Version;

@WebAppConfiguration
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = { "classpath:test-root-context.xml", "classpath:spring/servlet-context.xml",
        "classpath:unsecured-entity-context.xml", "classpath:test-context.xml" }, initializers = { InitSpringPropertyConfigLoad.class,
        ClientSpringConfigurator.class })
@ActiveProfiles({ "progman.client.impl.null", "progman.proploc.classpath", "mna.client.null" })
public abstract class AbstractRestEmbeddedMongoTest {

    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractRestEmbeddedMongoTest.class);

    private static final int MONGO_TEST_PORT = 55555;

    // setup our embedded mongo once for this jvm
    static {
        try {
            MongodStarter
                    .getDefaultInstance()
                    .prepare(
                            new MongodConfigBuilder().version(Version.Main.PRODUCTION)
                                    .net(new Net("localhost", MONGO_TEST_PORT, false)).build()).start();
        } catch (Exception e) {
            new RuntimeException("something went wrong", e);
        }
    }

    @Autowired
    protected ObjectMapper objectMapper;

    @Autowired
    protected WebApplicationContext webApplicationContext;

    @Autowired
    protected MongoTemplate mongoTemplate;

    protected MockMvc mockMvc;

    @Before
    public void setUp() {

        mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build();
    }

    protected byte[] getJsonContent(final Map<String, Object> params) {
        byte[] bytes = null;
        try {
            bytes = objectMapper.writeValueAsBytes(params);
        } catch (Exception e) {
            LOGGER.error(e.getMessage());
            throw new RestException("unit.test.error", e);
        }
        return bytes;
    }

    @After
    public void dropCollections() {
        Query all = new Query();
        for (String collectionName : mongoTemplate.getCollectionNames()) {
            if (!"system.indexes".equals(collectionName)) { // NOPMD
                mongoTemplate.remove(all, collectionName);
            }
        }
    }

    protected MockHttpServletResponse callGETRestService1(final String uri, final HttpStatus expectedStatus) {
        MockHttpServletResponse response = null;
        try {
            MockHttpServletRequestBuilder get = get(uri);
            MvcResult result = mockMvc.perform(get.accept(MediaType.APPLICATION_JSON))
                    .andExpect(matcher(expectedStatus)).andReturn();
            response = result.getResponse();

        } catch (Exception e) {
            throw new RestException("error int callGETRestService " + uri, e);
        }
        return response;
    }

    protected MockHttpServletResponse callGETRestService1(final String uri) {
        return callGETRestService1(uri, HttpStatus.OK);
    }

    protected <T> T callUploadFileRestService(final String uri, final MockMultipartFile mockMultipartFile,
            final Class<T> responseObjectType) throws Exception {
        return callUploadFileRestService(uri, mockMultipartFile, responseObjectType, HttpStatus.CREATED);
    }

    protected <T> T callUploadFileRestService(final String uri, final MockMultipartFile mockMultipartFile, final Class<T> responseObjectType, final HttpStatus expectedStatus) throws Exception {
        MvcResult result = mockMvc.perform(fileUpload(uri).file(mockMultipartFile)).andExpect(matcher(expectedStatus)).andReturn();
        return objectMapper.readValue(result.getResponse().getContentAsString(), responseObjectType);
    }

    protected <T> T callGETRestService(final String uri, final Class<T> responseObjectType,
            final HttpStatus expectedStatus) {
        T object = null;
        try {
            MockHttpServletRequestBuilder get = get(uri);
            MvcResult result = mockMvc.perform(get.accept(MediaType.APPLICATION_JSON)).andExpect(matcher(expectedStatus)).andReturn();
            String responseGet = result.getResponse().getContentAsString();
            if (responseGet != null && responseGet.length() >= 1 && !expectedStatus.equals(HttpStatus.UNAUTHORIZED)) {
                object = objectMapper.readValue(responseGet, responseObjectType);
            }
        } catch (Exception e) {
            throw new RestException("error int callGETRestService " + uri, e);
        }
        return object;
    }
    
    protected <T> T callPATCHRestService(final String uri, final Map<String, Object> jsonParams,
            final Class<T> responseObjectType, final HttpStatus expectedStatus) {
        T object = null;
        try {
            MvcResult result = mockMvc
                    .perform(
                            patch(uri).accept(MediaType.ALL).contentType(MediaType.APPLICATION_JSON)
                                    .content(getJsonContent(jsonParams))).andExpect(matcher(expectedStatus))
                    .andReturn();
            String responseGet = result.getResponse().getContentAsString();
            if (!expectedStatus.equals(HttpStatus.UNAUTHORIZED)) {
                object = objectMapper.readValue(responseGet, responseObjectType);
            }
        } catch (Exception e) {
            e.printStackTrace();
            throw new RestException("error int callPUTRestService " + uri, e);
        }
        return object;
    }


    protected String callGETRestServicePlainText(final String uri) {
        String ret = null;
        try {
            MockHttpServletRequestBuilder get = get(uri);
            MvcResult result = mockMvc.perform(get.accept(MediaType.TEXT_PLAIN)).andExpect(matcher(HttpStatus.OK))
                    .andReturn();
            String responseGet = result.getResponse().getContentAsString();
            ret = responseGet;
        } catch (Exception e) {
            throw new RestException("error int callGETRestServicePlainText " + uri, e);
        }
        return ret;
    }

    protected <T> T callGETRestService(final String uri, final Class<T> responseObjectType) {
        return callGETRestService(uri, responseObjectType, HttpStatus.OK);
    }
    
    protected <T> T callPATCHRestService(final String uri, final Map<String, Object> jsonParams,
            final Class<T> responseObjectType) {
        return callPATCHRestService(uri, jsonParams, responseObjectType, HttpStatus.OK);
    }

    protected <T> T callGETRestServiceWithParams(final String uri, final Class<T> responseObjectType,
            final Map<String, String> params, final HttpStatus expectedStatus) {
        T object = null;
        try {
            MockHttpServletRequestBuilder get = get(uri);
            if (params != null) {
                for (Entry<String, String> entry : params.entrySet()) {
                    get = get.param(entry.getKey(), entry.getValue());
                }
            }

            MvcResult result = mockMvc.perform(get.accept(MediaType.APPLICATION_JSON))
                    .andExpect(matcher(expectedStatus)).andReturn();
            String responseGet = result.getResponse().getContentAsString();
            if (responseGet != null && responseGet.length() > 1 && !expectedStatus.equals(HttpStatus.UNAUTHORIZED)) {
                object = objectMapper.readValue(responseGet, responseObjectType);
            }
        } catch (Exception e) {
            throw new RestException("error int callGETRestServiceWithParams " + uri, e);
        }
        return object;
    }

    protected <T> T callGETRestServiceWithParams(final String uri, final Class<T> responseObjectType,
            final Map<String, String> params) {
        return callGETRestServiceWithParams(uri, responseObjectType, params, HttpStatus.OK);
    }

    protected <T> T callPOSTRestService(final String uri, final Map<String, Object> jsonParams,
            final Class<T> responseObjectType, final HttpStatus expectedStatus) {
        T object = null;
        try {
            MvcResult result = mockMvc
                    .perform(
                            post(uri).accept(MediaType.ALL).contentType(MediaType.APPLICATION_JSON)
                                    .content(getJsonContent(jsonParams))).andExpect(matcher(expectedStatus))
                    .andReturn();
            String responseGet = result.getResponse().getContentAsString();
            if (responseGet != null && responseGet.length() > 1 && !expectedStatus.equals(HttpStatus.UNAUTHORIZED)) {
                object = objectMapper.readValue(responseGet, responseObjectType);
            }
        } catch (Exception e) {
            e.printStackTrace();
            throw new RestException("error int callPOSTRestService " + uri, e);
        }
        return object;
    }

    protected <T> T callPOSTRestService(final String uri, final Map<String, Object> jsonParams,
            final Class<T> responseObjectType) {
        return callPOSTRestService(uri, jsonParams, responseObjectType, HttpStatus.CREATED);
    }

    @SuppressWarnings("unchecked")
    protected Map<String, List<String>> callPOSTWithBadData(final String uri, final Map<String, Object> jsonParams,
            final HttpStatus expectedStatus) {
        Map<String, Object> propertyMap = Maps.newHashMap(); // NOPMD
        Map<String, List<String>> messages = null;
        try {
            MvcResult result = mockMvc
                    .perform(
                            post(uri).accept(MediaType.ALL).contentType(MediaType.APPLICATION_JSON)
                                    .content(getJsonContent(jsonParams))).andExpect(matcher(expectedStatus))
                    .andReturn();
            String response = result.getResponse().getContentAsString();
            if (!expectedStatus.equals(HttpStatus.UNAUTHORIZED)) {
                propertyMap = objectMapper.readValue(response, Map.class);
                messages = (Map<String, List<String>>) propertyMap.get("messages");
            }
        } catch (Exception e) {
            e.printStackTrace();
            throw new RestException("error int callPOSTRestService " + uri, e);
        }
        return messages;
    }

    protected Map<String, List<String>> callPOSTWithBadData(final String uri, final Map<String, Object> jsonParams) {
        return callPOSTWithBadData(uri, jsonParams, HttpStatus.BAD_REQUEST);
    }

    protected void callDeleteRestService(final String uri, HttpStatus expectedStatus) {
        try {
            mockMvc.perform(delete(uri).accept(MediaType.ALL)).andExpect(matcher(expectedStatus)).andReturn();
        } catch (Exception e) {
            e.printStackTrace();
            throw new RestException("error int callDeleteRestService " + uri, e);
        }
    }

    protected void callDeleteRestService(final String uri) {
        callDeleteRestService(uri, HttpStatus.NO_CONTENT);
    }

    protected void callDeleteRestServiceForBadRequest(final String uri, final HttpStatus expectedStatus) {
        try {
            mockMvc.perform(delete(uri).accept(MediaType.ALL)).andExpect(matcher(expectedStatus)).andReturn();
        } catch (Exception e) {
            e.printStackTrace();
            throw new RestException("error int callDeleteRestService " + uri, e);
        }
    }

    protected void callDeleteRestServiceForBadRequest(final String uri) {
        callDeleteRestServiceForBadRequest(uri, HttpStatus.BAD_REQUEST);
    }

    protected <T> T callPUTRestService(final String uri, final byte[] content, final Class<T> responseObjectType, final HttpStatus expectedStatus) {
        T object = null;
        try {
            MvcResult result = mockMvc
                    .perform(
                            put(uri).accept(MediaType.ALL).contentType(MediaType.APPLICATION_JSON)
                                    .content(content)).andExpect(matcher(expectedStatus))
                    .andReturn();
            String responseGet = result.getResponse().getContentAsString();
            if (!expectedStatus.equals(HttpStatus.UNAUTHORIZED)) {
                object = objectMapper.readValue(responseGet, responseObjectType);
            }
        } catch (Exception e) {
            e.printStackTrace();
            throw new RestException("error int callPUTRestService " + uri, e);
        }
        return object;
    }

    protected <T> T callPUTRestService(final String uri, final Map<String, Object> jsonParams, final Class<T> responseObjectType, final HttpStatus expectedStatus) {
        return callPUTRestService(uri, getJsonContent(jsonParams), responseObjectType, expectedStatus);
    }

    protected <T> T callPUTRestService(final String uri, final Map<String, Object> jsonParams,
            final Class<T> responseObjectType) {
        return callPUTRestService(uri, jsonParams, responseObjectType, HttpStatus.OK);
    }

    protected String buildQueryString(final Map<String, String> params) {
        StringBuffer sBuf = new StringBuffer();
        sBuf.append('?');
        boolean first = true;
        for (Entry<String, String> arg : params.entrySet()) {
            if (!first) {
                sBuf.append('&');
            }
            sBuf.append(arg.getKey()).append('=').append(arg.getValue());
            first = false;
        }
        return sBuf.toString();
    }

    @SafeVarargs
    protected final List<Map<String, Object>> buildParamList(final Map<String, Object>... params) {
        return Arrays.asList(params);
    }

    protected void assertFieldLevelErrorMessageReturned(final Map<String, List<String>> errorMessages,
            final String fieldName, final String compareMessage) {
        boolean found = false;
        List<String> fieldMessages = errorMessages.get(fieldName);
        if (fieldMessages != null) {
            for (String message : fieldMessages) {
                if (compareMessage.equalsIgnoreCase(message)) {
                    found = true;
                }
            }
        }
        assertTrue("unable to find error message in response:" + compareMessage + " for field:" + fieldName, found);
    }

    private ResultMatcher matcher(final HttpStatus status) {
        return new ResultMatcher() {
            public void match(MvcResult result) {
                assertEquals("Status", status.value(), result.getResponse().getStatus());
            }
        };
    }
}
