/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.delivery.testreg.integration;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.junit.runner.RunWith;
import org.opentestsystem.delivery.testreg.domain.TestRegPermission;
import org.opentestsystem.shared.exception.RestException;
import org.opentestsystem.shared.security.domain.SbacPermission;
import org.opentestsystem.shared.security.domain.SbacRole;
import org.opentestsystem.shared.security.domain.SbacUser;
import org.springframework.http.HttpStatus;
import org.springframework.mock.web.MockHttpServletResponse;
import org.springframework.mock.web.MockMultipartFile;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.authentication.TestingAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.web.WebAppConfiguration;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.Multimap;

@WebAppConfiguration
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = { "classpath:security/testSecurityContext.xml", "classpath:unsecured-entity-context.xml" })
public abstract class AbstractSecuredRestEmbeddedMongoTest extends AbstractRestEmbeddedMongoTest {

    private static final String COMPONENT_NAME = "TestReg";

    static {
        System.setProperty("component.name", COMPONENT_NAME);
    }

    protected MockHttpServletResponse callGETRestService1(String uri, TestRegPermission... requiredPermissions) {
        try {
            setUserWithRoles(getAllUnauthorizedPermissions(requiredPermissions));
            callGETRestService1(uri, HttpStatus.UNAUTHORIZED);
        } catch (RestException re) {
            // since callGETRestService1 isn't properly matching UNAUTHORIZED for some reason?
            if (!(re.getCause().getCause() instanceof AccessDeniedException)) {
                throw re;
            }
        }
        setUserWithRoles(requiredPermissions);
        return callGETRestService1(uri);
    }

    protected <T> T callGETRestService(String uri, Class<T> responseObjectType,
            TestRegPermission... requiredPermissions) {
        setUserWithRoles(getAllUnauthorizedPermissions(requiredPermissions));
        callGETRestService(uri, responseObjectType, HttpStatus.UNAUTHORIZED);
        setUserWithRoles(requiredPermissions);
        return callGETRestService(uri, responseObjectType);
    }

    protected <T> T callGETRestService(String uri, Class<T> responseObjectType, HttpStatus requiredStatus,
            TestRegPermission... requiredPermissions) {
        setUserWithRoles(getAllUnauthorizedPermissions(requiredPermissions));
        callGETRestService(uri, responseObjectType, HttpStatus.UNAUTHORIZED);
        setUserWithRoles(requiredPermissions);
        return callGETRestService(uri, responseObjectType, requiredStatus);
    }

    protected <T> T callGETRestServiceWithParams(String uri, Class<T> responseObjectType, Map<String, String> params,
            TestRegPermission... requiredPermissions) {
        setUserWithRoles(getAllUnauthorizedPermissions(requiredPermissions));
        callGETRestServiceWithParams(uri, responseObjectType, params, HttpStatus.UNAUTHORIZED);
        setUserWithRoles(requiredPermissions);
        return callGETRestServiceWithParams(uri, responseObjectType, params);
    }

    // this will inherently test access to the URI is only allowed for the requiredPermissions and no others
    protected <T> T callPOSTRestService(final String uri, final Map<String, Object> jsonParams,
            final Class<T> responseObjectType, TestRegPermission... requiredPermissions) {
        setUserWithRoles(getAllUnauthorizedPermissions(requiredPermissions));
        callPOSTRestService(uri, jsonParams, responseObjectType, HttpStatus.UNAUTHORIZED);
        setUserWithRoles(requiredPermissions);
        return callPOSTRestService(uri, jsonParams, responseObjectType);
    }

    protected Map<String, List<String>> callPOSTWithBadData(String uri, Map<String, Object> jsonParams,
            TestRegPermission... requiredPermissions) {
        setUserWithRoles(getAllUnauthorizedPermissions(requiredPermissions));
        callPOSTWithBadData(uri, jsonParams, HttpStatus.UNAUTHORIZED);
        setUserWithRoles(requiredPermissions);
        return callPOSTWithBadData(uri, jsonParams);
    }

    protected void callDeleteRestService(String uri, TestRegPermission... requiredPermissions) {
        setUserWithRoles(getAllUnauthorizedPermissions(requiredPermissions));
        callDeleteRestService(uri, HttpStatus.UNAUTHORIZED);
        setUserWithRoles(requiredPermissions);
        callDeleteRestService(uri);
    }

    protected void callDeleteRestServiceForBadRequest(String uri, TestRegPermission... requiredPermissions) {
        // a bad request trumps the unauthorized so no need to check for that here...
        setUserWithRoles(requiredPermissions);
        callDeleteRestServiceForBadRequest(uri);
    }

    protected <T> T callPUTRestService(String uri, Map<String, Object> jsonParams, Class<T> responseObjectType,
            TestRegPermission... requiredPermissions) {
        setUserWithRoles(getAllUnauthorizedPermissions(requiredPermissions));
        callPUTRestService(uri, jsonParams, responseObjectType, HttpStatus.UNAUTHORIZED);
        setUserWithRoles(requiredPermissions);
        return callPUTRestService(uri, jsonParams, responseObjectType);
    }

    protected <T> T callUploadFileRestService(final String uri, final MockMultipartFile mockMultipartFile,
            final Class<T> responseObjectType, TestRegPermission... requiredPermissions) throws Exception {
        setUserWithRoles(getAllUnauthorizedPermissions(requiredPermissions));
        callUploadFileRestService(uri, mockMultipartFile, responseObjectType, HttpStatus.UNAUTHORIZED);
        setUserWithRoles(requiredPermissions);
        return callUploadFileRestService(uri, mockMultipartFile, responseObjectType);

    }

    // -------------------------------------------------------

    protected void wipeOutUserRoles() {
        setUserWithRoles();
    }

    protected void setUserWithRoles(final TestRegPermission... inPermissions) {
        final Map<String, Collection<SbacPermission>> permissionsMap = new HashMap<>();
        final Collection<SbacPermission> permissionCollection = new ArrayList<>();
        final Multimap<String, SbacPermission> permissions = ArrayListMultimap.create();
        final Multimap<String, SbacRole> roles = ArrayListMultimap.create();

        for (TestRegPermission inPermission : inPermissions) {
            final SbacPermission permission = new SbacPermission();
            permission.setComponentName(COMPONENT_NAME);
            permission.setName(inPermission.getTitle());
            permissions.put(inPermission.name(), permission);

            permissionCollection.add(permission);
            permissionsMap.put(inPermission.getTitle(), permissionCollection);
            permissions.put(inPermission.getTitle(), permission);

            final SbacRole role = new SbacRole();
            role.setRoleName(inPermission.getTitle());
            role.setPermissions(permissionCollection);
            roles.put(role.getRoleName(), role);
        }

        final SbacUser user = new SbacUser(roles, null);
        SecurityContextHolder.getContext().setAuthentication(
                new TestingAuthenticationToken(user, null, new ArrayList<>(user.getAuthorities())));
    }

    // get the list of all permissions that would be unauthorized to access some end-point
    private TestRegPermission[] getAllUnauthorizedPermissions(TestRegPermission[] requiredPermissions) {
        List<TestRegPermission> unauthorizedPermissions = new ArrayList<>(Arrays.asList(TestRegPermission.values()));
        unauthorizedPermissions.removeAll(new ArrayList<>(Arrays.asList(requiredPermissions)));
        return unauthorizedPermissions.toArray(new TestRegPermission[unauthorizedPermissions.size()]);
    }
}
