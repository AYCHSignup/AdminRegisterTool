/*************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2015 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at 
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 *************************************************************************/

package org.opentestsystem.delivery.testreg.rest.view;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.delivery.testreg.domain.ARTHelpers;
import org.opentestsystem.delivery.testreg.domain.AccommodationResourceType;
import org.opentestsystem.delivery.testreg.domain.DomainIndexConstants;
import org.opentestsystem.delivery.testreg.domain.ExplicitEligibility;
import org.opentestsystem.delivery.testreg.domain.Student;

import com.google.common.collect.ObjectArrays;

public class StudentEntityExportHelper
{
  /**
   * transform student record to multirow String array which contains only student information
   * 
   * @param student
   *        
   * @return array 
   */
  public static String[][] transformStudentsOnly(Student student) {
    String[][] rows;
    rows = new String[1][student.toStringArray ().length];
    rows[0] = student.toStringArray ();
    return rows;
  }
  
  /**
   * transform student record to multirow String array which contains only accommodation data
   * 
   * @param student
   * @param resourceTypesMap  masterResourceAccommodation map with key: resourceCode and value : resourceTypes
   *        
   * @return multi-row array 
   */
  @SuppressWarnings ("unchecked")
  public static String[][] transformStudenttoAccommodationsOnly(Student student, HashMap<String, String> resourceTypesMap, List<String> accommodationNames) {
    String[][] rows = new String[0][];
    Object[] accommodations = student.getAccommodations ();
    if (accommodations != null && accommodations.length > 0) {
      rows = new String[accommodations.length][student.getAccommodations ().length];
      int rowCount = 0;
      int accSize = 0;
      accSize = accommodations.length;
      for (int i=0; i<accSize; i++) {
        Object obj = accommodations[i];
        Map<String, Object>   acc = (Map<String, Object>)obj;
        List<String> accommo = new ArrayList<String>();
        for (String str : accommodationNames) {
          if (!str.equalsIgnoreCase("_id") && !str.equalsIgnoreCase ("atleastOneAccommodationField") && acc.containsKey (str)) {
            String tempKey = ARTHelpers.convertCodeToUpperCase (str);
            if (resourceTypesMap.containsKey (tempKey) && resourceTypesMap.get (tempKey).equalsIgnoreCase (AccommodationResourceType.EditResource.name ())) {
              if (!StringUtils.isBlank(acc.get (str).toString ())) {
                StringBuffer editResourceSB = new StringBuffer ();
                editResourceSB.append (tempKey).append ("(").append (acc.get (str)).append (")");
                accommo.add (editResourceSB.toString ());
              }
            } else if (resourceTypesMap.containsKey (tempKey) && resourceTypesMap.get (tempKey).equalsIgnoreCase (AccommodationResourceType.MultiSelectResource.name ())){
              List<String> multi = (List<String>)acc.get (str);
              StringBuffer namesSB = new StringBuffer ();
              if (multi != null) {
                for (String multiAccomo : multi) {
                  namesSB.append (multiAccomo).append (";");
                }
              }
              if (namesSB.toString ().contains (";")) {
                namesSB.replace (namesSB.length ()-1, namesSB.length (), "");
              }
              accommo.add (namesSB.toString ());
            } else if (resourceTypesMap.containsKey (tempKey) && resourceTypesMap.get (tempKey).equalsIgnoreCase (AccommodationResourceType.SingleSelectResource.name ())){
              accommo.add (acc.get (str).toString ());
            } else if (str.equalsIgnoreCase ("subject") || str.equalsIgnoreCase ("studentId") || str.equalsIgnoreCase ("stateAbbreviation")){
              accommo.add (acc.get (str).toString ());
            }
          }
        }
        String[] tempAccommodations = new String[accommo.size ()];
        tempAccommodations = accommo.toArray (tempAccommodations);
        StringBuffer accommodationFull = new StringBuffer();
        String accommodationFullStr = "";
        // Based on TO-15( SB-1426 ) requirement 3.9.5
        // Consolidating all accessibility codes into one field ( AccommodationCodes header column) for both import and export formats.
        // Accommodation export format will have 4 fields ( StudentIdentifier, StateAbbreviation, Subject, AccommodationCodes)
        // Index 3 represents start of accessibility codes in tempAccommodations array
        for (int x = DomainIndexConstants.FIRST_ACCESSIBILITY_CODE_INDEX; x < tempAccommodations.length; x++) {
          if(tempAccommodations[x] != null && tempAccommodations[x] !="")
            accommodationFull.append (tempAccommodations[x]).append ("|");
        }
        accommodationFullStr = accommodationFull.toString ();
        accommodationFullStr = accommodationFullStr.substring (0, accommodationFullStr.length ()-1);
        List<String> accommodationList = new ArrayList<String>();
        accommodationList.add (tempAccommodations[DomainIndexConstants.ACCOMMODATION_STUDENTID_INDEX]);
        accommodationList.add (tempAccommodations[DomainIndexConstants.ACCOMMODATION_STATE_ABBREVIATION_INDEX]);
        accommodationList.add (tempAccommodations[DomainIndexConstants.ACCOMMODATION_SUBJECT_INDEX]);
        accommodationList.add (accommodationFullStr);
        String[] accommodationsArray = new String[accommodationList.size ()];
        rows[rowCount++] = accommodationList.toArray (accommodationsArray);
      }
    }
    return rows;
  }
  
  /**
   * transform student record to multirow String array which contains only explicitEligibilities data
   * 
   * @param explicitEligibilities
   *        
   * @return explicitEligibilities array data
   */
  public static String[][] transformStudenttoExplicitEligibility(List<ExplicitEligibility> explicitEligibilities) {
    String[][] rows;
    int rowCount = 0;
    rows = new String[explicitEligibilities.size ()][];
    for (ExplicitEligibility explicitEligibility: explicitEligibilities) {
      rows[rowCount++] = explicitEligibility.toStringArray ();
    }
    return rows;
  }

  /**
   * transform student record to multirow String array which contains student plus accommodation information
   * 
   * @param student
   *        
   * @return student plus accommodation data array
   */
  @SuppressWarnings ("unchecked")
  public static String[][] toMultiRowStringArray (Student student, HashMap<String, String> resourceTypesMap, List<String> accommodationNames) {
    String[][] rows;
    Object[] accommodations = student.getAccommodations ();
    if (accommodations != null && accommodations.length > 0) {
      rows = new String[student.getAccommodations ().length][student.toStringArray ().length + student.getAccommodations ().length];
      int rowCount = 0;
      int accSize = 0;
      accSize = accommodations.length;
      for (int i=0; i<accSize; i++) {
        Object obj = accommodations[i];
        Map<String, Object>   acc = (Map<String, Object>)obj;
        List<String> accommo = new ArrayList<String>();
        for (String str : accommodationNames) {
          if (!str.equalsIgnoreCase ("studentId") && !str.equalsIgnoreCase ("stateAbbreviation") && !str.equalsIgnoreCase("_id") && !str.equalsIgnoreCase ("atleastOneAccommodationField") && acc.containsKey (str)) {
            String tempKey = ARTHelpers.convertCodeToUpperCase (str);
            if (resourceTypesMap.containsKey (tempKey) && resourceTypesMap.get (tempKey).equalsIgnoreCase (AccommodationResourceType.EditResource.name ())) {
              if (!StringUtils.isBlank(acc.get (str).toString ())) {
                StringBuffer editResourceSB = new StringBuffer ();
                editResourceSB.append (tempKey).append ("(").append (acc.get (str)).append (")");
                accommo.add (editResourceSB.toString ());
              }
            } else if (resourceTypesMap.containsKey (tempKey) && resourceTypesMap.get (tempKey).equalsIgnoreCase (AccommodationResourceType.MultiSelectResource.name ())) {
              List<String> multi = (List<String>)acc.get (str);
              StringBuffer namesSB = new StringBuffer ();
              if (multi != null) {
                for (String multiAccomo : multi) {
                  namesSB.append (multiAccomo).append (";");
                }
              }
              if (namesSB.toString ().contains (";")) {
                namesSB.replace (namesSB.length ()-1, namesSB.length (), "");
              }
              accommo.add (namesSB.toString ());
            } else if (resourceTypesMap.containsKey (tempKey) && resourceTypesMap.get (tempKey).equalsIgnoreCase (AccommodationResourceType.SingleSelectResource.name ())) {
              accommo.add (acc.get (str).toString ());
            } else if (str.equalsIgnoreCase ("subject")) {
              accommo.add (acc.get (str).toString ());
            }
          }
        }
        String[] tempAccommodations = new String[accommo.size ()];
        tempAccommodations = accommo.toArray (tempAccommodations);
        StringBuffer accommodationFull = new StringBuffer();
        String accommodationFullStr = "";
        for (int x=1; x<tempAccommodations.length; x++) {
          if (tempAccommodations[x] != null && tempAccommodations[x] !="")
            accommodationFull.append (tempAccommodations[x]).append ("|");
        }
        accommodationFullStr = accommodationFull.toString ();
        accommodationFullStr = accommodationFullStr.substring (0, accommodationFullStr.length ()-1);
        rows[rowCount++] = ObjectArrays.concat (student.toStringArray (), new String[]{tempAccommodations[0], accommodationFullStr}, String.class);
      }
    } else {
      rows = new String[1][student.toStringArray ().length];
      rows[0] = student.toStringArray ();
    }
    return rows;
  }

}

