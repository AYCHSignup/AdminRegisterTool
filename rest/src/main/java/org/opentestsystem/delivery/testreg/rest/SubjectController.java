/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.delivery.testreg.rest;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.validation.Valid;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.delivery.testadmin.rest.TestAdminBaseController;
import org.opentestsystem.delivery.testreg.domain.ARTHelpers;
import org.opentestsystem.delivery.testreg.domain.AccFamilySubject;
import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.MasterResourceAccommodation;
import org.opentestsystem.delivery.testreg.domain.ResourceFamily;
import org.opentestsystem.delivery.testreg.domain.Student;
import org.opentestsystem.delivery.testreg.domain.Subject;
import org.opentestsystem.delivery.testreg.domain.TestRegistrationBase;
import org.opentestsystem.delivery.testreg.domain.search.StudentSearchRequest;
import org.opentestsystem.delivery.testreg.domain.search.SubjectSearchRequest;
import org.opentestsystem.delivery.testreg.service.ResourceFamilyService;
import org.opentestsystem.delivery.testreg.service.SubjectService;
import org.opentestsystem.delivery.testreg.service.TestRegPersister;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.exception.RestException;
import org.opentestsystem.shared.search.domain.AbstractSearchRequest;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.Cache;
import org.springframework.cache.Cache.ValueWrapper;
import org.springframework.cache.CacheManager;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.ResponseStatus;

@Controller
public class SubjectController extends TestAdminBaseController {

    private static final Logger LOGGER = LoggerFactory.getLogger(SubjectController.class);

    @Autowired
    private SubjectService subjectService;

    @Autowired
    private TestRegPersister studentService;
    
    @Autowired
    private ResourceFamilyService resourceFamilyService;
    
    @Resource
    private CacheManager cacheManager;
    
    @Resource(name = "gradeLevel")
    private Map<String, String> gradeLevel;
    
  
    
    /**
     * Find all subjects.
     * @return Subjects.
     */
    @RequestMapping(value = "/subjects", method = RequestMethod.GET, produces = {MediaType.APPLICATION_JSON_VALUE })
    @ResponseBody
    public List<String> findAllSubjects() {
        return subjectService.getAllSubjectCodes();
    }
    
    /**
     * Gets subject by subjectId.
     * @param subject id.
     * @return Subject object.
     */
    @RequestMapping(value = "/subject/{subjectId}", method = RequestMethod.GET, produces = {MediaType.APPLICATION_JSON_VALUE })
    @ResponseBody
    public Subject findSubjectById(@PathVariable final String subjectId) {
        LOGGER.debug("Finding subject for Id: " + subjectId);
        return subjectService.getSubject(subjectId);
    }


    /**
     * Creates Subject.
     * @param subject to be saved.
     * @param response HttpServletResponse.
     * @return Subject newly created subject object.
     */
    @ResponseStatus(HttpStatus.CREATED)
    @RequestMapping(value = "/subject", method = RequestMethod.POST, consumes = MediaType.APPLICATION_JSON_VALUE, produces = {MediaType.APPLICATION_JSON_VALUE })
    @ResponseBody
    public Subject saveSubject(@RequestBody @Valid final Subject subject, final HttpServletResponse response) {
        LOGGER.debug("Saving Subject");
        Subject savedSubject = subjectService.saveSubject(subject);
        response.setHeader("Location", savedSubject.getUrl());
        return savedSubject;
    }

    /**
     * Updates Subject.
     * @param subject to be saved.
     * @param response HttpServletResponse.
     * @return Subject updated subject object.
     */
    @ResponseStatus(HttpStatus.OK)
    @RequestMapping(value = "/subject/{subjectId}", method = RequestMethod.PUT, consumes = MediaType.APPLICATION_JSON_VALUE, produces = {MediaType.APPLICATION_JSON_VALUE })
    @ResponseBody
    public Subject updateSubject(@PathVariable final String subjectId, @RequestBody @Valid final Subject subject, final HttpServletResponse response) {
        Subject subjectDb = subjectService.getSubject(subjectId);
        if (subject == null || subjectDb == null || StringUtils.isEmpty(subject.getId()) || !subjectId.equals(subject.getId())) {
            throw new LocalizedException("subject.invalid.id");
        } else {
            Map<String, String[]> params = new HashMap<String, String[]>();
            params.put(StudentSearchRequest.SEARCH_KEY_ACCOM_SUBJECT, new String[]{subjectDb.getCode()});
            AbstractSearchRequest searchRequest = new StudentSearchRequest(params);
            SearchResponse<TestRegistrationBase> searchResponse = studentService.searchDomainObjects(searchRequest, FormatType.STUDENT);
            for (TestRegistrationBase base : searchResponse.getSearchResults()) {
                Student student = (Student) base;
                Object[] accommodations = student.getAccommodations();
                
                int accSize = 0;
                if(accommodations != null){
                  accSize = accommodations.length;
                  for(int i=0;i<accSize; i++){
                    
                      Object obj = accommodations[i];
                      Map<String, Object> acc = (Map<String, Object>)obj;
                      if (acc.get("subject") != null &&  acc.get("subject").toString().equalsIgnoreCase(subjectDb.getCode())) {
                        acc.put("subject", subject.getCode());
                        accommodations[i] = acc;
                    }
                  }
                }
                //update student now
                studentService.saveDomainObject(student); 
            }
            //update resource family
            List<ResourceFamily> resourceFamily = resourceFamilyService.findBySubject (subjectDb.getCode());
            for(ResourceFamily rf : resourceFamily){
             List<AccFamilySubject> subjects = rf.getSubject ();
             for(int i=0; i< subjects.size ();i++){
               AccFamilySubject sub = subjects.get(i);
               if(sub.getCode ().equalsIgnoreCase (subjectDb.getCode())){
                 sub.setCode (subject.getCode ());
               }  
             }
             rf.setSubject (subjects);
             resourceFamilyService.saveResourceFamily (rf);
            }
            //update cache
            final Cache accommodationToCache = cacheManager.getCache("accommodationCache");
            List<MasterResourceAccommodation> masterAccommodations = null; 
            if(accommodationToCache != null && subjectDb.getCode() != null){
              for(String grade : gradeLevel.values ()){
                masterAccommodations = new ArrayList<MasterResourceAccommodation>();
                ValueWrapper cacheGet = accommodationToCache.get(ARTHelpers.generateKey (grade,subjectDb.getCode()));
                if (cacheGet != null) {
                  masterAccommodations = (List<MasterResourceAccommodation>) cacheGet.get();
                  accommodationToCache.evict (ARTHelpers.generateKey (grade,subjectDb.getCode()));
                  accommodationToCache.put (ARTHelpers.generateKey(grade,subject.getCode()), masterAccommodations);
                }
              }
            }
            Subject savedSubject = subjectService.saveSubject(subject);
            response.setHeader("Location", savedSubject.getUrl());
            return savedSubject;
        }
    }

    
    /**
     * Merge Subject.
     * @param subject to be merged.
     * @param response HttpServletResponse.
     * @return Subject updated subject object.
     */
    @ResponseStatus(HttpStatus.OK)
    @ResponseBody
    @RequestMapping(value = "/subject/{subjectId}/merge", method = RequestMethod.PUT, consumes = MediaType.APPLICATION_JSON_VALUE, produces = {MediaType.APPLICATION_JSON_VALUE })
    public Subject mergeSubject(@PathVariable final String subjectId, @RequestBody @Valid final Subject subject) {
            Subject subjectDb = subjectService.getSubject(subjectId);
            if (subject == null || subjectDb == null || StringUtils.isEmpty(subject.getId()) || !subjectId.equals(subject.getId())) {
                throw new LocalizedException("Invalid subject id for merge");
            } else {
                Map<String, String[]> params = new HashMap<String, String[]>();
                params.put(StudentSearchRequest.SEARCH_KEY_ACCOM_SUBJECT, new String[]{subjectDb.getCode()});
                AbstractSearchRequest searchRequest = new StudentSearchRequest(params);
                SearchResponse<TestRegistrationBase> searchResponse = studentService.searchDomainObjects(searchRequest, FormatType.STUDENT);
                for (TestRegistrationBase base : searchResponse.getSearchResults()) {
                    Student student = (Student) base;
                    Object[] accommodations = student.getAccommodations();
                    
                    int accSize = 0;
                    if(accommodations != null){
                      accSize = accommodations.length;
                      for(int i=0;i<accSize; i++){
                        
                          Object obj = accommodations[i];
                          Map<String, Object> acc = (Map<String, Object>)obj;
                          if (acc.get("subject") != null &&  acc.get("subject").toString().equalsIgnoreCase(subjectDb.getCode())) {
                            acc.put("subject", subject.getCode());
                            accommodations[i] = acc;
                        }
                      }
                    }
                    //update student now
                    studentService.saveDomainObject(student);
                }
                subjectService.removeSubject(subjectId);
            }
            return subject;
    }
    
    /**
     * Removes Subject.
     * @param subjectId subject Id.
     */
    @ResponseStatus(HttpStatus.NO_CONTENT)
    @RequestMapping(value = "/subject/{subjectId}", method = RequestMethod.DELETE)
    public void removeSubjectById(@PathVariable final String subjectId) {
        if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("Removing subject with Id:" + subjectId);
        }
        subjectService.removeSubject(subjectId);
    }
    
    

    /**
     * Can query the /subject endpoint with query parameters in a querystring.
     * @param request HttpServletRequest
     * @param response HttpServletResponse
     * @return SearchResponse<Subject>
     */
    @RequestMapping(value = "/subject", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)
    @ResponseBody
    public SearchResponse<Subject> searchSubject(final HttpServletRequest request, final HttpServletResponse response) {

        SubjectSearchRequest searchRequest = new SubjectSearchRequest(request.getParameterMap());
        SearchResponse<Subject> searchResponse;
        if (searchRequest.isValid()) {
            searchResponse = subjectService.searchSubjects(searchRequest);
        } else {
            throw new RestException("subject.search.invalidSearchCriteria");
        }
        return searchResponse;
    }
}
