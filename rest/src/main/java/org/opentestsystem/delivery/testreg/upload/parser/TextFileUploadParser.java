/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.delivery.testreg.upload.parser;

import static org.opentestsystem.delivery.testreg.upload.parser.ParserTextUtils.areAllElementsNull;
import static org.opentestsystem.delivery.testreg.upload.parser.ParserTextUtils.padEmptyTextIfNoColumnAtEnd;
import static org.opentestsystem.delivery.testreg.upload.parser.ParserTextUtils.trimRecords;

import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.opentestsystem.delivery.testreg.rest.FilePreviewHelper;
import org.opentestsystem.delivery.testreg.upload.DataRecord;
import org.opentestsystem.delivery.testreg.upload.FileDataRecord;
import org.opentestsystem.delivery.testreg.upload.FileHeaderRecord;
import org.opentestsystem.delivery.testreg.upload.TextFileUtils;
import org.opentestsystem.delivery.testreg.upload.TextFileUtils.LineMapper;
import org.opentestsystem.shared.exception.LocalizedException;

public class TextFileUploadParser implements UploadFileParser<Map<String, List<DataRecord>>> {

    private final String delimiter;

    private final String disallowedHeaderValue;

    private boolean trim = true;


    public TextFileUploadParser(final String inDelimiter, final String inDisallowedStringDelimiter) {
        delimiter = inDelimiter;
        disallowedHeaderValue = inDisallowedStringDelimiter;
    }

    @Override
    public ParserResult<Map<String, List<DataRecord>>> parse(final InputStream uploadFile, final String formatType) throws Exception {

        final TextFileUtils textFileUtils = new TextFileUtils();
        final Map<String, List<DataRecord>> recordMap = new HashMap<String, List<DataRecord>>();
        final List<Integer> ignoredRowNums = new ArrayList<>();

        textFileUtils.processTextFile(uploadFile, formatType, new LineMapper() {

            List<DataRecord> recordsList = new ArrayList<DataRecord>();
            int numberOfHeaders;

            @Override
            public boolean mapLine(final String line, final int lineNumber, final String formatType) {
                if (lineNumber == HEADER_ROW) {// Header
                    final String[] headers = getColumnValues(line);
                    if (headers.length > 0 && headers[0].contains(getDisallowedHeaderDelimiter())) {
                        String delim = delimiter.equals("\\t") ? "tab" : delimiter;
                        String dis = disallowedHeaderValue.equals("\\t") ? "tab" : disallowedHeaderValue;
                        throw new LocalizedException("Header columns for files delimted by: '" + delim + "' cannot contain: '" + dis +"'");
                    }
                    this.numberOfHeaders = headers.length;
                    this.recordsList.add(new FileHeaderRecord(headers));
                    recordMap.put(formatType, this.recordsList);

                } else {

                    final String[] rowvals = getColumnValues(line);
                    if (!areAllElementsNull(rowvals)) { // ignore blank rows
                        final String[] rowValsForMap = TextFileUploadParser.this.trim ? trimRecords(rowvals) : rowvals;
                        recordMap.get(formatType).add(new FileDataRecord(lineNumber, padEmptyTextIfNoColumnAtEnd(this.numberOfHeaders, rowValsForMap)));
                    } else {
                        ignoredRowNums.add(lineNumber);
                    }

                }
                recordMap.put(formatType, this.recordsList);
                return true; // Keep mapping
            }


        });
        return new ParserResultImpl<Map<String, List<DataRecord>>>(ignoredRowNums, recordMap);
    }

    private CharSequence getDisallowedHeaderDelimiter() {
        return disallowedHeaderValue;
    }
    private String[] getColumnValues(final String columnString) {
        return getValues(columnString.split(this.delimiter));
    }
    
    private String[] getValues(String[] rowvals) {
      for (int i = 0; i < rowvals.length; i++) {
        rowvals[i] = FilePreviewHelper.removeExtraneousQuotes (rowvals[i]);
      }
      return rowvals;
    }

    public void setTrimRecords(final boolean trimValue) {
        this.trim = trimValue;
    }
}
