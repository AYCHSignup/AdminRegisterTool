/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/

package org.opentestsystem.delivery.testreg.upload.validator.fileformat;

import static org.opentestsystem.delivery.testreg.upload.validator.FileValidationUtils.rejectValue;

import java.util.Arrays;
import java.util.List;

import org.opentestsystem.delivery.testreg.upload.FileHeaderRecord;
import org.opentestsystem.delivery.testreg.upload.RowMetadata;
import org.opentestsystem.delivery.testreg.upload.RowMetadataImpl.RowErrorType;
import org.springframework.util.Assert;
import org.springframework.validation.Errors;

public abstract class AbstractFileHeaderValidator extends AbstractRecordDataValidator {

    protected AbstractFileHeaderValidator(String recordDataName) {
        super(recordDataName);
    }

    protected boolean isValidHeader(FileHeaderRecord record, Errors errors) {
        Assert.isTrue(record.getRowMetadata().getRowNum() == 1);

        RowMetadata metadata = record.getRowMetadata();
        metadata.setErrorType(RowErrorType.FATAL_ERROR);
        return compareHeaders(errors, metadata, Arrays.asList(record.getColumns()));
    }

    private boolean compareHeaders(Errors errors, RowMetadata metadata, List<String> headersFound) {
        
        if (headersFound.size() > headers.length) { //Extra Headers than expected
            matchConfiguredHeaders(errors, metadata, headersFound); //Check if configured headers are there
            addExtraHeadersError(errors, metadata, headersFound);   
            return false;
            
        } else if (headers.length > headersFound.size()) {//Missing Headers
             matchConfiguredHeaders(errors, metadata, headersFound); //Check if configured headers are there
             addMissingHeadersError(errors, metadata, headersFound); 
             return false;
             
        } else { //Header count matches
            return matchConfiguredHeaders(errors, metadata, headersFound);
        }
    }
    
    private boolean matchConfiguredHeaders(Errors errors, RowMetadata metadata, List<String> headersFound) {
        boolean isValidHeader = true;
        int upperBound = (headersFound.size()<headers.length) ? headersFound.size():headers.length; //End of Match
        
        for (int i = 0; i < upperBound; i++) {
            String headerFound = headersFound.get(i);
            if (!headers[i].equalsIgnoreCase(headerFound)) {
                rejectValue(errors, getDatasetName(), metadata, "Header [" + (i + 1) + "]", headerFound, "header.invalid",
                        "This is an invalid header for this format. Valid value is "
                                + headers[i]);
                isValidHeader = false;
            }
        }
        return isValidHeader;
    }
    
    private void addExtraHeadersError(Errors errors, RowMetadata metadata, List<String> headersFound) {
        for (int i = headers.length; i < headersFound.size(); i++) {
            String headerFound = headersFound.get(i);
            rejectValue(errors, getDatasetName(), metadata, "Header ["+ (i + 1)+ "]", headerFound, "header.notapplicable",
                    "This header is not applicable for this format");
        }
    }
    
    private void addMissingHeadersError(Errors errors, RowMetadata metadata, List<String> headersFound) {
        for (int i = headersFound.size(); i < headers.length; i++) {
            rejectValue(errors, getDatasetName(), metadata, "Header [" + (i + 1)+ "]", "", "header.missing", "Header '" + headers[i]
                    + "' is missing for this format");
        }
    }

}
