/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/

package org.opentestsystem.delivery.testreg.upload;

import static org.apache.commons.beanutils.ConstructorUtils.invokeConstructor;
import static org.apache.commons.lang.ClassUtils.isAssignable;
import static org.apache.commons.lang.ClassUtils.isInnerClass;
import static org.opentestsystem.delivery.testreg.rest.FileType.TXT;
import static org.opentestsystem.delivery.testreg.rest.FileType.XLSX;
import static org.opentestsystem.delivery.testreg.upload.parser.ParserTextUtils.trimTextValues;

import java.io.InputStream;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import javax.annotation.Resource;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.io.FilenameUtils;
import org.opentestsystem.delivery.testreg.domain.Action;
import org.opentestsystem.delivery.testreg.domain.FileUploadSummary;
import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.TestRegistrationBase;
import org.opentestsystem.delivery.testreg.domain.TestRegistrationBuilder;
import org.opentestsystem.delivery.testreg.persistence.ParentEntityClassFinder;
import org.opentestsystem.delivery.testreg.rest.FileType;
import org.opentestsystem.delivery.testreg.service.TestRegPersister;
import org.opentestsystem.delivery.testreg.upload.parser.ParserResult;
import org.opentestsystem.delivery.testreg.upload.parser.UploadFileParser;
import org.opentestsystem.shared.exception.LocalizedException;
import org.springframework.beans.factory.annotation.Autowired;

// TODO Many of these methods are marked to throw Exception. Can we come up with a better Exception to throw?
public class FileUploadUtils {

    @Autowired
    ParentEntityClassFinder parentEntityClassFinder;
    
    @Resource(name = "entityBasedParserMap")
    Map<FileType, UploadFileParser<Map<FormatType, List<TestRegistrationBase>>>> entityBasedParserMap;

    public ParserResult<Map<FormatType, List<TestRegistrationBase>>> extractFile(final String fileName, final InputStream uploadFile)
            throws Exception {
        String extension = FilenameUtils.getExtension(fileName);

        if (extension == null) {
            throw createNullExtensionException(extension);
        }

        switch (FileType.findByFilename(fileName)) {

        case XLS:
        case XLSX:
            return parseExcelFile(XLSX, uploadFile);
        case CSV:
        case TXT:
            return parseCSVFiles(TXT, uploadFile);
        default:
            throw createFileExtensionException("File extension must be either XLS or XLSX or CSV or TXT");
        }
    }

    public ParserResult<Map<FormatType, List<TestRegistrationBase>>> parseExcelFile(FileType type, final InputStream uploadFile) throws Exception {
        return entityBasedParserMap.get(type).parse(uploadFile);
    }

    public List<TestRegistrationBase> entityType(final FormatType formatType,
            final List<TestRegistrationBase> excelRows, final Object[] cellData) throws Exception {
        excelRows.add(getDomainObject(formatType, trimTextValues(cellData)));
        return excelRows;
    }

    public TestRegistrationBase getDomainObject(final FormatType formatType, final Object[] cellData) {
        Class<? extends TestRegistrationBase> sb11EntityClass = parentEntityClassFinder.getParentClass(formatType
                .name());

        Class<?>[] cArray = sb11EntityClass.getDeclaredClasses();
        for (Class<?> clazz : cArray) {
            if (isInnerClass(clazz) && isAssignable(clazz, TestRegistrationBuilder.class)) {// Builders as Static Inner
                // class
                try {
                    return (TestRegistrationBase) TestRegistrationBuilder.class.cast(
                            invokeConstructor(clazz, new Object[] { cellData })).build();
                } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException
                        | InstantiationException e) {
                    throw createInvalidTypeException(formatType.toString());
                }
            }
        }
        throw createInvalidTypeException(formatType.toString());
    }

    public TestRegistrationBase getDomainObject(final FormatType formatType, final FileDataRecord dataRecord) {
        return getDomainObject(formatType, dataRecord.getColumns());
    }

    private ParserResult<Map<FormatType, List<TestRegistrationBase>>> parseCSVFiles(FileType fileType, final InputStream uploadFile) throws Exception {
        return entityBasedParserMap.get(fileType).parse(uploadFile);
    }

    public FileUploadSummary processGroupEntities(final List<TestRegistrationBase> testRegEntities,
            final TestRegPersister entityService) {

        FileUploadSummary summaryResponse = new FileUploadSummary();
        List<TestRegistrationBase> addEntityList = new ArrayList<TestRegistrationBase>();
        List<TestRegistrationBase> updateEntityList = new ArrayList<TestRegistrationBase>();
        List<TestRegistrationBase> deleteEntityList = new ArrayList<TestRegistrationBase>();

        for (TestRegistrationBase entityObj : testRegEntities) {
            Action action = entityObj.getAction();
            switch (action) {
            case ADD:
                addEntityList.add(entityObj);
                break;
            case UPD:
                updateEntityList.add(entityObj);
                break;
            case DEL:
                deleteEntityList.add(entityObj);
                break;
            default:
                updateEntityList.add(entityObj);
                break;
                // add and upd will no longer be valid. we will always do an upsert
                // for now, this will look like an update
            }
        }
        if (CollectionUtils.isNotEmpty(addEntityList)) {
            entityService.saveDomainObjects(addEntityList);
            summaryResponse.setAddedRecords(addEntityList.size());
        }

        if (CollectionUtils.isNotEmpty(updateEntityList)) {
            entityService.updateDomainObjects(updateEntityList);
            summaryResponse.setUpdatedRecords(updateEntityList.size());
        }

        if (CollectionUtils.isNotEmpty(deleteEntityList)) {
            entityService.deleteDomainObjects(deleteEntityList);
            summaryResponse.setDeletedRecords(deleteEntityList.size());
        }

        return summaryResponse;
    }

    private LocalizedException createNullExtensionException(final String extension) {
        return new LocalizedException("file.extension.null", new String[] { extension });
    }

    private LocalizedException createFileExtensionException(final String extension) {
        return new LocalizedException("file.invlaid.fileformat", new String[] { extension });
    }

    private LocalizedException createInvalidTypeException(final String fileType) {
        return new LocalizedException("file.invalid.filetype", new String[] { fileType });
    }
}
