/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/

package org.opentestsystem.delivery.testreg.upload.validator.fileformat;

import static org.opentestsystem.delivery.testreg.persistence.criteria.verifiers.VerifierUtils.addFieldError;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.validation.ConstraintValidatorContext;

import org.opentestsystem.delivery.testreg.domain.Accommodation;
import org.opentestsystem.delivery.testreg.domain.AccommodationResourceType;
import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.Student;
import org.opentestsystem.delivery.testreg.domain.TestRegistrationBase;
import org.opentestsystem.delivery.testreg.domain.constraintvalidators.AlphanumericValidator;
import org.opentestsystem.delivery.testreg.persistence.criteria.BusinessValidator;
import org.opentestsystem.delivery.testreg.persistence.criteria.Sb11BusinessValidatorFactory;
import org.opentestsystem.delivery.testreg.service.AccommodationCacheService;
import org.opentestsystem.delivery.testreg.service.MasterResourceAccommodationService;
import org.opentestsystem.delivery.testreg.service.StudentService;
import org.opentestsystem.delivery.testreg.service.SubjectService;
import org.opentestsystem.delivery.testreg.upload.FileDataRecord;
import org.opentestsystem.delivery.testreg.upload.RowMetadata;
import org.opentestsystem.delivery.testreg.upload.RowMetadataImpl.RowErrorType;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.util.CollectionUtils;
import org.springframework.validation.BindingResult;
import org.springframework.validation.Errors;
import org.springframework.validation.FieldError;
import org.springframework.validation.ObjectError;

public class FileDataValidator extends FileFormatValidator {

    ConstraintValidatorContext                 context;
    @Autowired
    protected Sb11BusinessValidatorFactory businessValidatorFactory;

    @Autowired
    private MasterResourceAccommodationService masterResourceAccommodationService;
    
    @Autowired
    private StudentService                     studentService;
    
    @Autowired
    private SubjectService subjectService;
    
    @Autowired
    private AccommodationCacheService          accommodationCacheService;
    
    @Autowired
    protected BusinessValidator<TestRegistrationBase> fileUploadSecurityValidator;

    @Autowired
    private MasterResourceAccommodationService masterResourceService;
    
    // Capturing groups are a way to treat multiple characters as a single unit
    // placing the characters to be grouped inside a set of parentheses Ex: (value)
    // RegularExpression starts with open parentheses followed by startGroup"(" then any character other than ")" one or more times then stop matching group ")"
    // followed by close parentheses
    private static final String REGEX_DELIMITER = "\\(([^)]+)\\)";
    
    protected FileDataValidator(final String datasetName) {
        super(FormatType.valueOf(datasetName));
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    @Override
    protected boolean isValidData(final FileDataRecord record, final Errors errors) {
       
        List<FieldError> fieldErrors = new ArrayList<FieldError> ();
        Accommodation accommodation = new Accommodation();
        RowMetadata metadata = record.getRowMetadata();
        metadata.setErrorType(RowErrorType.FATAL_ERROR);
        
        if (getFormat ().equals (FormatType.DESIGNATEDSUPPORTSANDACCOMMODATIONS)) {
          
        HashMap<String, String> headerTypes = masterResourceAccommodationService.getAllResourceTypes();
        headerTypes.put ("StudentIdentifier","SingleSelectResource" );
        headerTypes.put ("StateAbbreviation","SingleSelectResource" );
        headerTypes.put ("Subject","SingleSelectResource" );
        
        List<String> headers = masterResourceAccommodationService.getAllOptionsCodes();
        Map<String, ArrayList<String>> formattedData;
        if (record.getColumns ().length > 4) {
          formattedData= convertData(record.getColumns(), headers, headerTypes);
        } else {
          formattedData = convertDataToMap(record.getColumns(), headers, headerTypes, fieldErrors, errors, metadata);
        }
        
        Student student = studentService.findByStudentIdAndStateAbbreviation (record.getColumnAt (0), record.getColumnAt (1).toUpperCase ());  
        //student validation whether student record is present in database or not 
        if (student != null) {
          //subject validation
          if (record.getColumnAt (2) != null && !subjectService.getAllSubjectCodes().contains(record.getColumnAt (2).toUpperCase())) {
            final String message = "  Subject not found in the database";
            addFieldError(fieldErrors, accommodation, "Subject", record.getColumnAt (2), message, new Object[] { metadata });
            processValidationErrors(errors,fieldErrors);
          } else {
            HashMap<String, List<String>> accOptions = accommodationCacheService.getResourceOptionCodes (record.getColumnAt (2).toUpperCase (), student.getGrade ());
            HashMap<String, List<String>> mutualOptions = accommodationCacheService.getAllMutallyExclusiveOptions (record.getColumnAt (2).toUpperCase (), student.getGrade ());
            HashMap<String, List<String>> masterResourceOptionsCode = masterResourceService.getMasterResourceOptions ();
            validateAccommodationData(formattedData, headerTypes, headers, errors, metadata, fieldErrors,accOptions, masterResourceOptionsCode,mutualOptions);
          }
        } else {
          final String message = " Student Identifier not found in the database";
          addFieldError (
              fieldErrors,
              accommodation,
              "StudentIdentifier",
              record.getColumnAt (0),
              message,
              new Object[] { metadata });
          processValidationErrors(errors,fieldErrors);
        }
        return errors == null ? true : false;
        }
        else {
        TestRegistrationBase sb11Entity = fileUploadUtils.getDomainObject(getFormat(), record);
        BusinessValidator<TestRegistrationBase> businessValidator = businessValidatorFactory
                .getBusinessValidator(sb11Entity);
        List<? extends ObjectError> objectErrors = businessValidator.validate(sb11Entity);
        objectErrors.addAll((List) fileUploadSecurityValidator.validate(sb11Entity));
        return (businessValidator == null) ? true : !processBusinessViolations(record, errors, objectErrors);
        }
    }

    /**
     * Converting accommodationData( accommodation upload data ) to accommodationMap
     * 
     * @param columns       accommodation data from upload file 
     * @param headers       list of all accommodation resource codes 
     * @param headerTypes   masterResourceAccommodation map with key : resourceCode and value : resourceType
     * @return map with data( values ) assigned to its corresponding resource codes(key)
     */
    private Map<String, ArrayList<String>> convertDataToMap (Object[] columns, List<String> headers, HashMap<String, String> headerTypes, List<FieldError> fieldErrors, final Errors errors, RowMetadata metadata) {
      List<String> headerCodes = convertToHeaders(headers);
      HashMap<String, ArrayList<String>> data = new HashMap<String, ArrayList<String>> ();
      HashMap<String, ArrayList<String>> accommodationMap = new HashMap<String, ArrayList<String>> ();
      
      Accommodation accommodation = new Accommodation();
      for (String columnHeader : headerCodes) {
        ArrayList<String> al = new ArrayList<String>();
        if (columnHeader.equalsIgnoreCase ("Subject") || columnHeader.equalsIgnoreCase ("StateAbbreviation")) {
          al.add (columns[headerCodes.indexOf (columnHeader)].toString ().toUpperCase ());
          data.put (columnHeader, al);
          accommodationMap.put (columnHeader, al);
        } else if (columnHeader.equalsIgnoreCase ("StudentIdentifier")) {
          al.add (columns[headerCodes.indexOf (columnHeader)].toString ());
          data.put (columnHeader, al);
          accommodationMap.put (columnHeader, al);
        }
      }
      String allAccommodationCodes = columns[3].toString ();
      List<String> editResourceValuesList = new ArrayList<String>();
      Matcher m = Pattern.compile(REGEX_DELIMITER).matcher(allAccommodationCodes);
      while(m.find()) {
        editResourceValuesList.add (m.group (1));
      }
      if (!editResourceValuesList.isEmpty ()) {
        for (String editResourceValue : editResourceValuesList) {
          if (editResourceValue!= null && editResourceValue.length () > 0 && editResourceValue.contains ("|")) {
            final String message = "Valid values for EditResource accommodation are alphanumeric characters, spaces, dashes, and periods";
            addFieldError (
                fieldErrors,
                accommodation,
                "AccommodationCodes",
                editResourceValue,
                message,
                new Object[] { metadata });

          }
        }
      }
      List<String> accommodationCode = new ArrayList<String> ();
      StringTokenizer tokenizer = new StringTokenizer (allAccommodationCodes, "|");
      while (tokenizer.hasMoreElements ()) {
        String token = (String) tokenizer.nextElement ();
        accommodationCode.add (token.trim ());
      }
      Set<String> tempCodesToValidate = new HashSet<String>();
      for (String tmpCode : accommodationCode) {
        if (!tmpCode.contains (";") && (!tmpCode.contains ("(") && !tmpCode.contains (")")) )
          tempCodesToValidate.add (tmpCode);
      }
      List<String> editResourceHeaders = getEditResourceHeaders(accommodationCode);
      ArrayList<String> tempValues = new ArrayList<String>();
      for (String valueCode : accommodationCode) {
        if (valueCode.contains (";") && !valueCode.contains ("(")) {
          StringTokenizer tokenizerMultiCodes = new StringTokenizer (valueCode, ";");
          while (tokenizerMultiCodes.hasMoreElements ()) {
            String token = (String) tokenizerMultiCodes.nextElement ();
            String tmpToken = token.trim ();
            tempValues.add (tmpToken);
            tempCodesToValidate.add (tmpToken);
          }
        } else if (!valueCode.contains ("(") && !valueCode.contains (")")) {
          tempValues.add (valueCode);
        }
      }
     
      HashMap<String,List<String>> masterAccommodationOptions = masterResourceAccommodationService.getMasterResourceOptions ();
      
      boolean flag = iSAllAccommodationCodesValid(masterAccommodationOptions, tempCodesToValidate);
      if (!flag) {
        List<String> allValidAccommodationCodes = getAllValidAccommodationCodes(masterAccommodationOptions);
        List<String> tempCodesToValidateList = new ArrayList<String>(tempCodesToValidate);
        tempCodesToValidateList.removeAll (allValidAccommodationCodes);
        final String message = "Invalid value for AccommodationCodes accommodation ";
        addFieldError (
            fieldErrors,
            accommodation,
            "AccommodationCodes",
            tempCodesToValidateList.toString (),
            message,
            new Object[] { metadata });
      }
        Set<String> masterCodes = masterAccommodationOptions.keySet ();
        for (String uploadCode : accommodationCode) {
          Set<String> tempCodes = new HashSet<String>(); 
          for (String resourceCode : masterCodes) {
            ArrayList<String> options = new ArrayList<String>();
            if (uploadCode.contains (";") && !uploadCode.contains ("(")) {
              StringTokenizer tokenizerMultiCodes = new StringTokenizer (uploadCode, ";");
              while (tokenizerMultiCodes.hasMoreElements ()) {
                String token = (String) tokenizerMultiCodes.nextElement ();
                options.add (token.trim ());
              }
              if(masterAccommodationOptions.get (resourceCode).containsAll (options)){
                data.put (resourceCode, options);
                tempCodes.add (resourceCode);
                break;
              }
            } else if (uploadCode.contains ("(") && uploadCode.contains (")")) {
              int startIndex = (uploadCode.indexOf ("("))+1;
              int endIndex = (uploadCode.indexOf (")"));
              String editResource = uploadCode.substring (startIndex, endIndex);
              String matchResource = uploadCode.substring (0, uploadCode.indexOf ("("));
              options.add (editResource);
              if (resourceCode.equalsIgnoreCase (matchResource)) {
                data.put (resourceCode, options);
                tempCodes.add (resourceCode);
                break;
              }
            } else {
              if (masterAccommodationOptions.get (resourceCode).contains (uploadCode)) {
                options.add (uploadCode);
                data.put (resourceCode, options);
                tempCodes.add (resourceCode);
                break;
              }
            }

          }
        }
       for (String resourceCode : masterAccommodationOptions.keySet ()) {
        Set<String> keys = data.keySet ();
        if (keys.contains (resourceCode)) {
          accommodationMap.put (resourceCode, data.get (resourceCode));
        } else {
          ArrayList<String> accommoList = new ArrayList<String> ();
          accommodationMap.put (resourceCode, accommoList);
        }
      }
       
      for (String headerNames : headerTypes.keySet ()) {
        if (accommodationMap.get (headerNames).size () >= 2 && headerTypes.get (headerNames).equalsIgnoreCase (AccommodationResourceType.SingleSelectResource.name ())) {
          final String message = " This accommodation ( " + headerNames + " ) does not support multiple values" ;
          addFieldError (
              fieldErrors,
              accommodation,
              "AccommodationCodes",
              headerNames,
              message,
              new Object[] { metadata });
        }
      }
      
      for (String editHeader : editResourceHeaders) {
        if (!accommodationMap.keySet ().contains (editHeader)) {
          final String message = " This is an invalid header for this format";
          addFieldError (
              fieldErrors,
              accommodation,
              "AccommodationCodes",
              editHeader,
              message,
              new Object[] { metadata });
        }
      }
          
      return accommodationMap;
     
    }

    /**
     * Determine whether all accommodation codes valid or not 
     * @param masterAccommodationOptions masterAccommodation map with key:resource code and value : corresponding options for that particular resource code
     * @param tempCodesToValidate        accommodation codes in upload file to validate
     * @return true/false 
     */
    private boolean iSAllAccommodationCodesValid (HashMap<String, List<String>> masterAccommodationOptions, Set<String> tempCodesToValidate) {
      List<String> allValidAccommodationCodes = getAllValidAccommodationCodes(masterAccommodationOptions);
      List<String> tempCodesToValidateList = new ArrayList<String>(tempCodesToValidate);
      tempCodesToValidateList.removeAll (allValidAccommodationCodes);
      
      if (tempCodesToValidateList.size () > 0) {
        return false;
      } else {
        return true;
      }
      
    }

    /**
     * Getting list of all accommodation option codes
     * @param masterAccommodationOptions  
     * @return list of options
     */
    private List<String> getAllValidAccommodationCodes (HashMap<String, List<String>> masterAccommodationOptions) {
      List<String> allValidAccommodationCodes = new ArrayList<String>();
      for (Map.Entry<String, List<String>> entry : masterAccommodationOptions.entrySet()) {
        for (String code : entry.getValue ()) {
          allValidAccommodationCodes.add(code);
        }
      }
      return allValidAccommodationCodes;
    }

    /**
     * getting list of Edit Resource Header codes
     * 
     * @param accommodationCode 
     * @return list of editResource HeaderNames
     */
    private List<String> getEditResourceHeaders (List<String> accommodationCode) {
      List<String> headers = new ArrayList<String>();
      for (String resource : accommodationCode) {
        if (resource.contains ("(") && resource.contains (")")) {
          String matchResource = resource.substring (0, resource.indexOf ("("));
          headers.add (matchResource);
        }
      }
      return headers;
    }

    /**
     * validateAccommodationData is used to validate all accommodation data validations
     * @param formattedData,headerTypes
     */
    private void validateAccommodationData (Map<String, ArrayList<String>> formattedData, HashMap<String, String> headerTypes, List<String> headers, final Errors errors, RowMetadata metadata, List<FieldError> fieldErrors, HashMap<String, List<String>> accOptionsMap, HashMap<String, List<String>> masterResourceOptionsCode,HashMap<String, List<String>> mutuallyExclusiveOptions) {
      AlphanumericValidator validator = new AlphanumericValidator ();
     
      Accommodation accommodation = new Accommodation();
      
      List<String> excludeHeaders = new ArrayList<String> ();
      excludeHeaders.add ("studentId");
      excludeHeaders.add ("stateAbbreviation");
      excludeHeaders.add ("subject");
      
      for (String header: headers) {
        
        if (!excludeHeaders.contains (header)) {
          header = header.substring (0,1).toUpperCase ().concat (header.substring (1));
        AccommodationResourceType resourceType = masterResourceService.getResourceType (header);
        HashMap<String, List<String>> accOptions = formatMap(accOptionsMap);
        List<String> options = accOptions.get (header);
        List<String> masterOptions = masterResourceOptionsCode.get (header);
      switch (resourceType) {
      case EditResource: {
        List<String> valueList = formattedData.get (header);
        String value = null;
        if (valueList!= null && !valueList.isEmpty ()) {
         value = valueList.get (0);
        }
        // Maximum length for EditResource accommodation is 90 characters
        if (value!= null && value.length () > 90) {
          final String message = "Maximum length for " + header + " accommodation is 90 characters";
          addFieldError (
              fieldErrors,
              accommodation,
              header,
              value,
              message,
              new Object[] { metadata });
        }
        
        if (value!= null && value.toString ().length () > 0 && validator.processValidateWithVetoing (value, context)) {
          final String message = "Valid values for Other accommodation are alphanumeric characters, spaces, dashes, and periods";
          addFieldError (
              fieldErrors,
              accommodation,
              header,
              value,
              message,
              new Object[] { metadata });

        }
      }

        break;
      case SingleSelectResource: {
        List<String> valueList = formattedData.get (header);
        String value = null;
        if (valueList != null && !valueList.isEmpty ()) {
         value = valueList.get (0);
        }
        
        if (value != null && value.toString ().length () > 0 && options!=null && !options.contains (value) && masterOptions.contains (value)) {
          addFieldError (fieldErrors, accommodation, header, value.toString (), "This "+ header + " option is not available for this combination of subject and grade", new Object[] { metadata });
        }

        if (value != null && value.toString ().length () > 0 && !masterOptions.contains (value)) {
          final String message = "Invalid value for " + header + " accommodation ";
          addFieldError (fieldErrors, accommodation, header, value.toString (), message, new Object[] { metadata });
        
      }}
        break;

      case MultiSelectResource: {
        List<String> valueList = formattedData.get (header);
        List<String> loadedOptions =  null;
       if (valueList != null) {
         loadedOptions = convertOptionsToList (valueList);
       }

        if (valueList != null && valueList.size() > 0 && options!=null && !options.containsAll (loadedOptions) && masterOptions.containsAll (loadedOptions)) {
          addFieldError (fieldErrors, accommodation, header, valueList.toString (), header + " some of these options are not available for this combination of subject and grade", new Object[] { metadata });
        }

        if (loadedOptions != null && !masterOptions.containsAll (loadedOptions)) {
          final String message = "Invalid value for " + header + " accommodation ";
          addFieldError (fieldErrors, accommodation, header, valueList.toString (), message, new Object[] { metadata });
        }

        final Set<String> duplicates = findDuplicateCodes (loadedOptions);
        if (!CollectionUtils.isEmpty (duplicates)) {
          for (final String dupCodes : duplicates) {
            final String message = "Duplicate code " + dupCodes + " in accommodation";
            addFieldError (
                fieldErrors,
                accommodation,
                header,
                dupCodes,
                message, new Object[] { metadata });
          }
        }
        
        List<String> mutExOptions = mutuallyExclusiveOptions.get (header);
        if (mutExOptions != null && !mutExOptions.isEmpty ()) {
          for (String defaultOptionValue : mutExOptions) {
            if (loadedOptions != null && loadedOptions.size () > 1 && loadedOptions.contains (defaultOptionValue)) {
              final String message = " : Incompatible option combination with " + defaultOptionValue;
              addFieldError (fieldErrors, accommodation, header, valueList.toString (), header + message, new Object[] { metadata });
            }
          }
        }
        
      }
        break;
      }

    }
      }
      processValidationErrors(errors,fieldErrors);
    }

    /**
     * @param accOptionsMap
     * @return
     */
    private HashMap<String, List<String>> formatMap (HashMap<String, List<String>> accOptionsMap) {
      HashMap<String, List<String>> accOptions = new HashMap<String, List<String>>();
      
      for (String key : accOptionsMap.keySet ()) {
        accOptions.put (key.substring (0, 1).toUpperCase ().concat (key.substring (1)), accOptionsMap.get (key));
      }
      
      return accOptions;
    }

    private List<String> convertOptionsToList (List<String> values) {
      List<String> loadedOptions = new ArrayList<String> ();
      for (int i = 0; i < values.size (); i++) {
        loadedOptions.add (values.get (i).toString ());
      }
      return loadedOptions;
    }
    
    private Set<String> findDuplicateCodes (List<String> codes) {
      final Set<String> code = new HashSet<String> ();
      final Set<String> duplicates = new HashSet<String> ();
      if (codes != null ) {
      for (String option : codes) {
        if (code.contains (option)) {
          duplicates.add (option);
        } else {
          code.add (option);
        }
      }
      }
      return duplicates;
    }
    
    private boolean processBusinessViolations(final FileDataRecord record, final Errors errors,
            final List<? extends ObjectError> objectErrors) {
        boolean hasErrors = false;
        for (ObjectError objectError : objectErrors) {
            if (objectError instanceof FieldError) {
                hasErrors = true;
                FieldError fieldError = (FieldError) objectError;
                ((BindingResult) errors).addError(new FieldError(getDatasetName(), fieldError.getField(), fieldError
                        .getRejectedValue(), fieldError.isBindingFailure(), fieldError.getCodes(),
                        new Object[] { record.getRowMetadata() }, fieldError.getDefaultMessage()));
            }
        }
        return hasErrors;
    }
    
    /**
     * @param cellData
     * @param headers
     * @param headerTypes
     * @return
     */
    private Map<String, ArrayList<String>> convertData (Object[] cellData, List<String> headerCodes, HashMap<String, String> headerTypes) {
      
      List<String> headers = convertToHeaders(headerCodes);
     
      HashMap<String, ArrayList<String>> data = new HashMap<String, ArrayList<String>> ();
      for (String columnHeader : headers) {
        String resourceType = headerTypes.get (columnHeader);
        ArrayList<String> al = null;
        switch (resourceType) {
        case "SingleSelectResource":
          al = new ArrayList<String> ();
          if (columnHeader.equalsIgnoreCase ("Subject") || columnHeader.equalsIgnoreCase ("StateAbbreviation")) {
            al.add (cellData[headers.indexOf (columnHeader)].toString ().toUpperCase ());
          }else{
            al.add (cellData[headers.indexOf (columnHeader)].toString ());
          }
          data.put (columnHeader, al);
          break;

        case "MultiSelectResource":
          String dt = cellData[headers.indexOf (columnHeader)].toString ();
          al = new ArrayList<String> ();
          StringTokenizer tokenizer = new StringTokenizer (dt, ";");
          while (tokenizer.hasMoreElements ()) {
            String token = (String) tokenizer.nextElement ();
            al.add (token.trim ());
          }
          data.put (columnHeader, al);
          break;
        case "EditResource":
          al = new ArrayList<String> ();
          al.add (cellData[headers.indexOf (columnHeader)].toString ());
          data.put (columnHeader, al);
          break;
        }
      }
      return data;
    }

    /**
     * @param headerCodes
     * @return
     */
    private List<String> convertToHeaders (List<String> headerCodes) {
      ArrayList<String> headers = new ArrayList<String> ();
      for (String col : headerCodes) {
        if (col.equals ("studentId")) {
          headers.add("StudentIdentifier");
        } else {
          headers.add (col.substring (0, 1).toUpperCase ().concat (col.substring (1)));
        }
      }
      return headers;
    }
    
    private void processValidationErrors(final Errors errors, List<FieldError> fieldErrors){
      
      for (FieldError e : fieldErrors) {
        ((BindingResult) errors).addError (e);
      }
    }
}
