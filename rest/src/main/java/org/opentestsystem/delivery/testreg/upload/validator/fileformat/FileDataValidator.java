/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/

package org.opentestsystem.delivery.testreg.upload.validator.fileformat;

import static org.opentestsystem.delivery.testreg.persistence.criteria.verifiers.VerifierUtils.addFieldError;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;

import javax.validation.ConstraintValidatorContext;


import org.opentestsystem.delivery.testreg.domain.Accommodation;
import org.opentestsystem.delivery.testreg.domain.AccommodationResourceType;
import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.Student;
import org.opentestsystem.delivery.testreg.domain.TestRegistrationBase;
import org.opentestsystem.delivery.testreg.domain.constraintvalidators.AlphanumericValidator;
import org.opentestsystem.delivery.testreg.persistence.criteria.BusinessValidator;
import org.opentestsystem.delivery.testreg.persistence.criteria.Sb11BusinessValidatorFactory;
import org.opentestsystem.delivery.testreg.service.AccommodationCacheService;
import org.opentestsystem.delivery.testreg.service.MasterResourceAccommodationService;
import org.opentestsystem.delivery.testreg.service.StudentService;
import org.opentestsystem.delivery.testreg.service.SubjectService;
import org.opentestsystem.delivery.testreg.upload.FileDataRecord;
import org.opentestsystem.delivery.testreg.upload.RowMetadata;
import org.opentestsystem.delivery.testreg.upload.RowMetadataImpl.RowErrorType;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.util.CollectionUtils;
import org.springframework.validation.BindingResult;
import org.springframework.validation.Errors;
import org.springframework.validation.FieldError;
import org.springframework.validation.ObjectError;

public class FileDataValidator extends FileFormatValidator {

    ConstraintValidatorContext                 context;
    @Autowired
    protected Sb11BusinessValidatorFactory businessValidatorFactory;

    @Autowired
    private MasterResourceAccommodationService masterResourceAccommodationService;
    
    @Autowired
    private StudentService                     studentService;
    
    @Autowired
    private SubjectService subjectService;
    
    @Autowired
    private AccommodationCacheService          accommodationCacheService;
    
    @Autowired
    protected BusinessValidator<TestRegistrationBase> fileUploadSecurityValidator;

    @Autowired
    private MasterResourceAccommodationService masterResourceService;
    
    protected FileDataValidator(final String datasetName) {
        super(FormatType.valueOf(datasetName));
    }

    @SuppressWarnings({ "unchecked", "rawtypes" })
    @Override
    protected boolean isValidData(final FileDataRecord record, final Errors errors) {
       
        List<FieldError> fieldErrors = new ArrayList<FieldError> ();
        Accommodation accommodation = new Accommodation();
        
        if(getFormat ().equals (FormatType.DESIGNATEDSUPPORTSANDACCOMMODATIONS)) {
          
        HashMap<String, String> headerTypes = masterResourceAccommodationService.getAllResourceTypes();
        headerTypes.put ("StudentIdentifier","SingleSelectResource" );
        headerTypes.put ("StateAbbreviation","SingleSelectResource" );
        headerTypes.put ("Subject","SingleSelectResource" );
        
        List<String> headers = masterResourceAccommodationService.getAllOptionsCodes();
        Map<String, ArrayList<String>> formattedData = convertData(record.getColumns(), headers, headerTypes);
        RowMetadata metadata = record.getRowMetadata();
        metadata.setErrorType(RowErrorType.FATAL_ERROR);
        
        Student student = studentService.findByStudentIdAndStateAbbreviation (record.getColumnAt (0), record.getColumnAt (1));
        //student validation whether student record is present in database or not 
        if(student != null){
          //subject validation
          if (record.getColumnAt (2) != null && !subjectService.getAllSubjectCodes().contains(record.getColumnAt (2).toUpperCase())) {
            final String message = "  Subject not found in the database";
            addFieldError(fieldErrors, accommodation, "Subject", record.getColumnAt (2), message, new Object[] { metadata });
            processValidationErrors(errors,fieldErrors);
          }else{
            HashMap<String, List<String>> accOptions = accommodationCacheService.getResourceOptionCodes (record.getColumnAt (2), student.getGrade ());
            HashMap<String, List<String>> mutualOptions = accommodationCacheService.getAllMutallyExclusiveOptions (record.getColumnAt (2), student.getGrade ());
            HashMap<String, List<String>> masterResourceOptionsCode = masterResourceService.getMasterResourceOptions ();
            validateAccommodationData(formattedData, headerTypes, headers, errors, metadata, fieldErrors,accOptions, masterResourceOptionsCode,mutualOptions);
          }
        }else{
          final String message = " Student Identifier not found in the database";
          addFieldError (
              fieldErrors,
              accommodation,
              "StudentIdentifier",
              record.getColumnAt (0),
              message,
              new Object[] { metadata });
          processValidationErrors(errors,fieldErrors);
        }
        return errors == null ? true : false;
        }
        else {
        TestRegistrationBase sb11Entity = fileUploadUtils.getDomainObject(getFormat(), record);
        BusinessValidator<TestRegistrationBase> businessValidator = businessValidatorFactory
                .getBusinessValidator(sb11Entity);
        List<? extends ObjectError> objectErrors = businessValidator.validate(sb11Entity);
        objectErrors.addAll((List) fileUploadSecurityValidator.validate(sb11Entity));
        return (businessValidator == null) ? true : !processBusinessViolations(record, errors, objectErrors);
        }
    }

    /**
     * validateAccommodationData is used to validate all accommodation data validations
     * @param formattedData,headerTypes
     */
    private void validateAccommodationData (Map<String, ArrayList<String>> formattedData, HashMap<String, String> headerTypes, List<String> headers, final Errors errors, RowMetadata metadata, List<FieldError> fieldErrors, HashMap<String, List<String>> accOptionsMap, HashMap<String, List<String>> masterResourceOptionsCode,HashMap<String, List<String>> mutallyExclusiveOptions) {
      AlphanumericValidator validator = new AlphanumericValidator ();
     
      Accommodation accommodation = new Accommodation();
      
      List<String> excludeHeaders = new ArrayList<String> ();
      excludeHeaders.add ("studentId");
      excludeHeaders.add ("stateAbbreviation");
      excludeHeaders.add ("subject");
      
      for(String header: headers){
        
        if (!excludeHeaders.contains (header)) {
          header = header.substring (0,1).toUpperCase ().concat (header.substring (1));
        AccommodationResourceType resourceType = masterResourceService.getResourceType (header);
        HashMap<String, List<String>> accOptions = formatMap(accOptionsMap);
        List<String> options = accOptions.get (header);
        List<String> masterOptions = masterResourceOptionsCode.get (header);
      switch (resourceType) {
      case EditResource: {
        List<String> valueList = formattedData.get (header);
        String value = null;
        if(valueList!= null) {
         value = valueList.get (0);
        }
        if (value!= null && value.length () > 90) {
          final String message = "Maximum length for " + header + " accommodation is 90 characters";
          addFieldError (
              fieldErrors,
              accommodation,
              header,
              value,
              message,
              new Object[] { metadata });
        }
        
        if (value!= null && value.toString ().length () > 0 && validator.processValidateWithVetoing (value, context)) {
          final String message = "Valid values for Other accommodation are alphanumeric characters, spaces, dashes, and periods";
          addFieldError (
              fieldErrors,
              accommodation,
              header,
              value,
              message,
              new Object[] { metadata });

        }
      }

        break;
      case SingleSelectResource: {
        List<String> valueList = formattedData.get (header);
        String value = null;
        if(valueList != null ){
         value = valueList.get (0);
        }
        
        if (value != null && value.toString ().length () > 0 && !options.contains (value) && masterOptions.contains (value)) {
          addFieldError (fieldErrors, accommodation, header, value.toString (), header + " option is not available for this combination of subject and grade", new Object[] { metadata });
        }

        if (value != null && value.toString ().length () > 0 && !masterOptions.contains (value)) {
          final String message = "Invalid value for " + header + " accommodation ";
          addFieldError (fieldErrors, accommodation, header, value.toString (), message, new Object[] { metadata });
        
      }}
        break;

      case MultiSelectResource: {
        List<String> valueList = formattedData.get (header);
        List<String> loadedOptions =  null;
       if(valueList != null){
         loadedOptions = convertOptionsToList (valueList);
       }

        if (valueList != null & valueList.size() > 0 && !options.containsAll (loadedOptions) && masterOptions.containsAll (loadedOptions)) {
          addFieldError (fieldErrors, accommodation, header, valueList.toString (), header + " some of these options are not available for this combination of subject and grade", new Object[] { metadata });
        }

        if (loadedOptions != null && !masterOptions.containsAll (loadedOptions)) {
          final String message = "Invalid value for " + header + " accommodation ";
          addFieldError (fieldErrors, accommodation, header, valueList.toString (), message, new Object[] { metadata });
        }

        final Set<String> duplicates = findDuplicateCodes (loadedOptions);
        if (!CollectionUtils.isEmpty (duplicates)) {
          for (final String dupCodes : duplicates) {
            final String message = "Duplicate code " + dupCodes + " in accommodation";
            addFieldError (
                fieldErrors,
                accommodation,
                header,
                dupCodes,
                message, new Object[] { metadata });
          }
        }

        for(String defaultOptionValue : mutallyExclusiveOptions.get (header)){
          if (loadedOptions != null && loadedOptions.size () > 1 && loadedOptions.contains (defaultOptionValue)) {
            final String message = " : Incompatible option combination with " + defaultOptionValue;
            addFieldError (fieldErrors, accommodation, header, valueList.toString (), header + message, new Object[] { metadata });
          }
        }
        
      }
        break;
      }

    }
      }
      processValidationErrors(errors,fieldErrors);
    }

    /**
     * @param accOptionsMap
     * @return
     */
    private HashMap<String, List<String>> formatMap (HashMap<String, List<String>> accOptionsMap) {
      HashMap<String, List<String>> accOptions = new HashMap<String, List<String>>();
      
      for(String key : accOptionsMap.keySet ()){
        accOptions.put (key.substring (0, 1).toUpperCase ().concat (key.substring (1)), accOptionsMap.get (key));
      }
      
      return accOptions;
    }

    private List<String> convertOptionsToList (List<String> values) {
      List<String> loadedOptions = new ArrayList<String> ();
      for (int i = 0; i < values.size (); i++) {
        loadedOptions.add (values.get (i).toString ());
      }
      return loadedOptions;
    }
    
    private Set<String> findDuplicateCodes (List<String> codes) {
      final Set<String> code = new HashSet<String> ();
      final Set<String> duplicates = new HashSet<String> ();
      for (String option : codes) {
        if (code.contains (option)) {
          duplicates.add (option);
        } else {
          code.add (option);
        }
      }
      return duplicates;
    }
    
    private boolean processBusinessViolations(final FileDataRecord record, final Errors errors,
            final List<? extends ObjectError> objectErrors) {
        boolean hasErrors = false;
        for (ObjectError objectError : objectErrors) {
            if (objectError instanceof FieldError) {
                hasErrors = true;
                FieldError fieldError = (FieldError) objectError;
                ((BindingResult) errors).addError(new FieldError(getDatasetName(), fieldError.getField(), fieldError
                        .getRejectedValue(), fieldError.isBindingFailure(), fieldError.getCodes(),
                        new Object[] { record.getRowMetadata() }, fieldError.getDefaultMessage()));
            }
        }
        return hasErrors;
    }
    
    /**
     * @param cellData
     * @param headers
     * @param headerTypes
     * @return
     */
    private Map<String, ArrayList<String>> convertData (Object[] cellData, List<String> headerCodes, HashMap<String, String> headerTypes) {
      
      List<String> headers = convertToHeaders(headerCodes);
     
      HashMap<String, ArrayList<String>> data = new HashMap<String, ArrayList<String>> ();
      for (String columnHeader : headers) {
        String resourceType = headerTypes.get (columnHeader);
        ArrayList<String> al = null;
        switch (resourceType) {
        case "SingleSelectResource":
          al = new ArrayList<String> ();
          al.add (cellData[headers.indexOf (columnHeader)].toString ());
          data.put (columnHeader, al);
          break;

        case "MultiSelectResource":
          String dt = cellData[headers.indexOf (columnHeader)].toString ();
          al = new ArrayList<String> ();
          StringTokenizer tokenizer = new StringTokenizer (dt, ";");
          while (tokenizer.hasMoreElements ()) {
            String token = (String) tokenizer.nextElement ();
            al.add (token.trim ());
          }
          data.put (columnHeader, al);
          break;
        case "EditResource":
          al = new ArrayList<String> ();
          al.add (cellData[headers.indexOf (columnHeader)].toString ());
          data.put (columnHeader, al);
          break;
        }
      }
      return data;
    }

    /**
     * @param headerCodes
     * @return
     */
    private List<String> convertToHeaders (List<String> headerCodes) {
      ArrayList<String> headers = new ArrayList<String> ();
      for(String col : headerCodes){
        if(col.equals ("studentId")){
          headers.add("StudentIdentifier");
        } else {
          headers.add (col.substring (0, 1).toUpperCase ().concat (col.substring (1)));
        }
      }
      return headers;
    }
    
    private void processValidationErrors(final Errors errors, List<FieldError> fieldErrors){
      
      for (FieldError e : fieldErrors) {
        ((BindingResult) errors).addError (e);
      }
    }
}
