/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/

package org.opentestsystem.delivery.testreg.rest;

import java.util.ArrayList;
import java.util.List;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.delivery.CachedClientEntity;
import org.opentestsystem.delivery.testadmin.persistence.validator.DuplicateUserValidator;
import org.opentestsystem.delivery.testreg.domain.AddOperation;
import org.opentestsystem.delivery.testreg.domain.ClientEntity;
import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.HierarchyLevel;
import org.opentestsystem.delivery.testreg.domain.SSOAction;
import org.opentestsystem.delivery.testreg.domain.TestRegistrationBase;
import org.opentestsystem.delivery.testreg.domain.UIValidationGroup;
import org.opentestsystem.delivery.testreg.domain.UpdateOperation;
import org.opentestsystem.delivery.testreg.domain.User;
import org.opentestsystem.delivery.testreg.domain.UserChangeEvent;
import org.opentestsystem.delivery.testreg.domain.search.UserSearchRequest;
import org.opentestsystem.delivery.testreg.service.TestRegPersister;
import org.opentestsystem.delivery.testreg.service.TestRegUserDetailsService;
import org.opentestsystem.delivery.testreg.service.UserChangeEventCallbackService;
import org.opentestsystem.delivery.testreg.service.UserChangeEventService;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.exception.RestException;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.opentestsystem.shared.security.domain.permission.SbacPermissionEntity;
import org.opentestsystem.shared.security.domain.permission.UserRole;
import org.opentestsystem.shared.web.AbstractRestController;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.access.annotation.Secured;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.Validator;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.WebDataBinder;
import org.springframework.web.bind.annotation.InitBinder;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.ResponseStatus;

@Controller
public class UserController extends AbstractRestController {

    @SuppressWarnings("unused")
    private static final Logger LOGGER = LoggerFactory.getLogger(UserController.class);

    private static final String DATA_LIST = "DATA_LIST";
    private static final String FORMAT_TYPE = "FORMAT_TYPE";

    @Autowired
    private Validator duplicateUserValidator;

    @InitBinder
    protected void initBinder(final WebDataBinder binder) {
        if(binder.getTarget() != null && duplicateUserValidator.supports(binder.getTarget().getClass())) {
            binder.setValidator(this.duplicateUserValidator);
        }
    }

    @Autowired
    private TestRegPersister userService;

    @Autowired
    private CachedClientEntity cachedClientEntity;

    @Autowired
    private UserChangeEventCallbackService userChangeEventCallbackService;

    @Autowired
    private UserChangeEventService userChangeEventService;

    @Qualifier("userDetailService")
    @Autowired
    private TestRegUserDetailsService testRegUserDetailsService;

    /**
     * Find user by id.
     *
     * @param id user mongo id
     * @return User user
     */
    @RequestMapping(value = "/user/{id}", method = RequestMethod.GET, produces = { MediaType.APPLICATION_JSON_VALUE })
    @Secured({ "ROLE_User Read" })
    @ResponseBody
    public User findUserById(@PathVariable final String id) {
        return userService.findById(id, User.FORMAT_TYPE);
    }

    /**
     * Save user.
     *
     * @param user unsaved user
     * @param response HttpServlet response
     * @return User saved user
     */
    @ResponseStatus(HttpStatus.CREATED)
    @RequestMapping(value = "/user", method = RequestMethod.POST, consumes = MediaType.APPLICATION_JSON_VALUE, produces = { MediaType.APPLICATION_JSON_VALUE })
    @Secured({ "ROLE_User Modify" })
    @ResponseBody
    public User saveUser(@RequestBody @Validated({ UIValidationGroup.class, AddOperation.class, DuplicateUserValidator.class }) final User user, final HttpServletResponse response) {

        User savedUser = userService.saveDomainObject(user);
        response.setHeader("Location", savedUser.getUrl());
        return savedUser;
    }

    /**
     * Update User.
     *
     * @param id user mongo id
     * @param user to be updated
     * @param response HttpServlet response
     * @return User updated user
     */
    @ResponseStatus(HttpStatus.OK)
    @RequestMapping(value = "/user/{id}", method = RequestMethod.PUT, consumes = MediaType.APPLICATION_JSON_VALUE, produces = { MediaType.APPLICATION_JSON_VALUE })
    @Secured({ "ROLE_User Modify" })
    @ResponseBody
    public User editUser(@PathVariable final String id, @RequestBody @Validated({ UIValidationGroup.class,
        UpdateOperation.class }) final User user, final HttpServletResponse response) {
        if (user == null || StringUtils.isEmpty(user.getId()) || !id.equals(user.getId())) {
            throw new LocalizedException("nonentity.invalid.id", new String[] { "User" });
        } else {
            user.setChangeEventExportError(null);
            User savedEntity = userService.saveDomainObject(user);
            response.setHeader("Location", savedEntity.getUrl());
            return savedEntity;
        }
    }

    /**
     * Delete user.
     *
     * @param id user mongo id
     */
    @ResponseStatus(HttpStatus.NO_CONTENT)
    @RequestMapping(value = "/user/{id}", method = RequestMethod.DELETE)
    @Secured({ "ROLE_User Modify" })
    public void deleteUser(@PathVariable final String id) {
        userService.deleteDomainObject(id, User.FORMAT_TYPE);
    }

    /**
     * RESET user - kick off a reset user password flow SYNC user - send all user info to remote data management system
     * (OpenDJ/OpenAM) LOCK user - send lock request to OpenDJ/OpenAM (Note: we don't hold this state) UNLOCK user -
     * send unlock request to OpenDJ/OpenAM (Note: we don't hold this state)
     *
     * @param id user mongo id
     * @param action action to take
     */
    @ResponseStatus(HttpStatus.OK)
    @RequestMapping(value = "/user/{id}/{action}", method = RequestMethod.POST)
    @Secured({ "ROLE_User Modify" })
    public void requestUserActionBePerformed(@PathVariable final String id, @PathVariable final String action) {
        if (action.toLowerCase().equals(SSOAction.RESET.name().toLowerCase())) {
            userChangeEventService.saveUserChangeEvent(new UserChangeEvent(id, SSOAction.RESET));
        } else if (action.toLowerCase().equals(SSOAction.SYNC.name().toLowerCase())) {
            userChangeEventService.saveUserChangeEvent(new UserChangeEvent(id, SSOAction.SYNC));
        } else if (action.toLowerCase().equals(SSOAction.LOCK.name().toLowerCase())) {
            userChangeEventService.saveUserChangeEvent(new UserChangeEvent(id, SSOAction.LOCK));
        } else if (action.toLowerCase().equals(SSOAction.UNLOCK.name().toLowerCase())) {
            userChangeEventService.saveUserChangeEvent(new UserChangeEvent(id, SSOAction.UNLOCK));
        } else {
            throw new RestException("invalid.action", new String[] { action });
        }
    }

    /**
     * Search users by search criteria.
     *
     * @param request HttpServlet request
     * @return SearchResponse containing users
     */
    @RequestMapping(value = "/user", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_VALUE)
    @Secured({ "ROLE_User Read" })
    @ResponseBody
    public SearchResponse<User> searchUser(final HttpServletRequest request) {
        UserSearchRequest searchRequest = new UserSearchRequest(request.getParameterMap());
        SearchResponse<User> searchResponse;
        if (searchRequest.isValid()) {
            searchResponse = userService.searchDomainObjects(searchRequest, User.FORMAT_TYPE);
        } else {
            throw new RestException("nonentity.search.invalidSearchCriteria");
        }
        return searchResponse;
    }

    /**
     * Export User Data into Excel or CSV based on path extensions
     *
     * @param model ModelMap.
     */
    @RequestMapping(value = "/users", method = RequestMethod.GET)
    @Secured({ "ROLE_User Read" })
    public void exportToFiles(final HttpServletRequest request, final Model model) throws Exception {
        List<User> userList = null;
        if (request.getParameterMap() != null) {
            UserSearchRequest searchRequest = new UserSearchRequest(request.getParameterMap());
            SearchResponse<User> searchResponse = userService.searchDomainObjects(searchRequest, User.FORMAT_TYPE);
            userList = searchResponse.getSearchResults();
        }
        if (model != null) {
            model.addAttribute(FORMAT_TYPE, User.FORMAT_TYPE.toString());
            model.addAttribute(DATA_LIST, userList);
        }
    }

    /**
     * SSO Callback
     */
    @ResponseStatus(HttpStatus.CREATED)
    @RequestMapping(value = "/users/extract", method = RequestMethod.POST, consumes = MediaType.APPLICATION_XML_VALUE)
    public void ssoUsersExtractCallback(@RequestBody final String xml) throws Exception {
        userChangeEventCallbackService.processCallback(xml);
    }

    /**
     * Get all Roles.
     *
     * @return user
     */
    @RequestMapping(value = "/user/role", method = RequestMethod.GET, produces = { MediaType.APPLICATION_JSON_VALUE })
    @Secured({ "ROLE_User Read" })
    @ResponseBody
    public List<UserRole> findAllUserRoles() {

        ClientEntity client = cachedClientEntity.getClient();
        List<UserRole> userRoles = testRegUserDetailsService.getAllUserRolesForCurrentUser();

        // filter allowable entities for each role based on group of hiding in client configuration Ref: JIRA-884
        for (UserRole role : userRoles) {
            List<SbacPermissionEntity> allowableEntities = new ArrayList<>();
            for (SbacPermissionEntity entity : role.getAllowableEntities()) {
                if ((client.isGroupOfStates() && entity.getEntity().equalsIgnoreCase(HierarchyLevel.GROUPOFSTATES.toString()))
                        || (client.isGroupOfDistricts() && entity.getEntity().equalsIgnoreCase(HierarchyLevel.GROUPOFDISTRICTS.toString()))
                        || (client.isGroupOfInstitutions() && entity.getEntity().equalsIgnoreCase(HierarchyLevel.GROUPOFINSTITUTIONS.toString()))) {
                    continue;
                } else {
                    allowableEntities.add(entity);
                }
            }
            role.setAllowableEntities(allowableEntities);
        }

        return userRoles;
    }

    /**
     * A hook to SYNC all users to SSO component.
     * Just a simple GET request to a URI with no arguments expected.
     */
    @ResponseStatus(HttpStatus.NO_CONTENT)
    @RequestMapping(value = "/users/sync", method = RequestMethod.GET)
    @Secured({ "ROLE_User Modify" })
    public void syncAllUsers() {
        List<UserChangeEvent> userChangeEvents = new ArrayList<>();
        for (TestRegistrationBase user : userService.findAll(FormatType.USER)) {
            userChangeEvents.add(new UserChangeEvent(user.getId(), SSOAction.SYNC));
        }
        userChangeEventService.saveUserChangeEvents(userChangeEvents);
    }
}
