/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/

package org.opentestsystem.delivery.testreg.rest.view;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.collections.ListUtils;
import org.opentestsystem.delivery.testreg.domain.ExplicitEligibility;
import org.opentestsystem.delivery.testreg.domain.ExportStudentFormatEnums;
import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.Student;
import org.opentestsystem.delivery.testreg.domain.StudentGroup;
import org.opentestsystem.delivery.testreg.domain.TestRegistrationBase;
import org.opentestsystem.delivery.testreg.domain.User;
import org.opentestsystem.delivery.testreg.domain.User.RoleAssociation;
import org.opentestsystem.delivery.testreg.persistence.ExplicitEligibilityRepository;
import org.opentestsystem.delivery.testreg.service.MasterResourceAccommodationService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.util.CollectionUtils;
import org.springframework.web.servlet.view.AbstractView;

import au.com.bytecode.opencsv.CSVWriter;

import com.google.common.collect.ObjectArrays;

/**
 * This class builds a CSV document using CSVWriter.
 */

public class CSVView extends AbstractView {

    private final String CONTENT_TYPE = com.google.common.net.MediaType.CSV_UTF_8.toString();

    private static final String DATA_LIST = "DATA_LIST";
    private static final String FORMAT_TYPE = "FORMAT_TYPE";
    private static final String EXPORT_TYPE = "EXPORT_TYPE";

    @Resource(name = "headersMap")
    private Map<String, String[]> headersMap;
    
    @Resource (name = "templateDownloadMap")
    private Map<FormatType, List<String>>          templateDownloadMap;
    
    @Autowired
    private MasterResourceAccommodationService                      masterResourceService;

    @Autowired
    private Transformer<TestRegistrationBase, String[]> testRegistrationViewTransformer;

    @Autowired
    private Transformer<User.RoleAssociation, String[]> userRoleAssociationEntityExportTransformer;

    @Autowired
    private Transformer<StudentGroup, String[]> studentGroupEntityExportTransformer;

    @Autowired
    private Transformer<Student, String[][]> studentEntityExportTransformer;
    
    @Autowired
    private ExplicitEligibilityRepository explicitEligRepository;

    /**
     * Writes the CSV data to the response stream
     * 
     * @param model
     *        the model
     * @param out
     *        the response stream writer
     */
    @SuppressWarnings("unchecked")
    protected void writeValues(final Map<String, Object> model, final PrintWriter writer) throws IOException {

        final List<TestRegistrationBase> entityList = (List<TestRegistrationBase>) model.get(DATA_LIST);
        final String formatType = ((String) model.get(FORMAT_TYPE)).toUpperCase();
        String exportType = null;
        if (formatType.equalsIgnoreCase (FormatType.STUDENT.name ())) {
          exportType = ((String) model.get(EXPORT_TYPE)).toUpperCase();
        }
        
        final CSVWriter csvWriter = new CSVWriter(writer, ',');
        // Adding Title to the CSV row
         String headerColumns[] =  new String[100];
         if (formatType.equalsIgnoreCase (FormatType.STUDENT.name ())) {
           // Based on export type for FormatType( STUDENT ) assigning headers for export file
           if (exportType.equalsIgnoreCase (ExportStudentFormatEnums.studentsPlusAccommodations.name ())) {
             List<String> headerStudentList = templateDownloadMap.get (FormatType.STUDENT);
             String[] headerCodesTemp = headersMap.get (FormatType.DESIGNATEDSUPPORTSANDACCOMMODATIONS.name ());
             List<String> headerCodes = Arrays.asList (headerCodesTemp);
             List<String> headerAccommodationList = headerCodes.subList (2, headerCodes.size ());
             String lastElement = headerStudentList.get (headerStudentList.size ()-1);
             List<String> combinedHeaders = ListUtils.union (headerStudentList.subList (0, headerStudentList.size ()-1), headerAccommodationList);
             combinedHeaders.add(lastElement);
             headerColumns = combinedHeaders.toArray(new String[combinedHeaders.size()]); 
           } else if (exportType.equalsIgnoreCase (ExportStudentFormatEnums.studentsOnly.name ())) {
             List<String> headerStudentList = templateDownloadMap.get (FormatType.STUDENT);
             headerColumns = headerStudentList.toArray (new String[headerStudentList.size()]);
           } else if (exportType.equalsIgnoreCase (ExportStudentFormatEnums.accommodationsOnly.name ())) {
             headerColumns = headersMap.get (FormatType.DESIGNATEDSUPPORTSANDACCOMMODATIONS.name ());
           } else if(exportType.equalsIgnoreCase (ExportStudentFormatEnums.explicitEligibility.name ())) {
             List<String> headerExplicitEligibilityList = templateDownloadMap.get (FormatType.EXPLICITELIGIBILITY);
             headerColumns = headerExplicitEligibilityList.toArray (new String[headerExplicitEligibilityList.size()]);
           }  
        }else {
          headerColumns = this.headersMap.get(formatType);
        }
        // Add the Header
        csvWriter.writeNext(headerColumns);
        if (!CollectionUtils.isEmpty(entityList)) {
            for (final TestRegistrationBase entity : entityList) {
                switch (FormatType.valueOf(formatType)) {
                case STUDENT:
                    exportStudent(csvWriter, (Student) entity, exportType);
                    break;
                case STUDENTGROUP:
                    exportStudentGroup(csvWriter, (StudentGroup) entity);
                    break;
                case USER: // if format is user then we need to customize export to include role associations as separate rows
                    exportUser(csvWriter, (User) entity);
                    break;
                default:
                    csvWriter.writeNext(this.testRegistrationViewTransformer.transform(entity));
                    break;
                }
            }
        }
        csvWriter.flush();
        csvWriter.close();
    }

    private void exportStudent(final CSVWriter csvWriter, final Student student, final String exportType) {
      String[][] columnDataArray = new String[100][100];
      HashMap<String, String> resourceTypesMap = masterResourceService.getAllResourceTypes();
      List<String> accommodationNames = masterResourceService.getAllOptionsCodes ();
      // Based on ExportType transforming student data to export
      if (exportType.equalsIgnoreCase (ExportStudentFormatEnums.studentsPlusAccommodations.name ())) {
        columnDataArray = StudentEntityExportHelper.toMultiRowStringArray (student, resourceTypesMap, accommodationNames);
      } else if (exportType.equalsIgnoreCase (ExportStudentFormatEnums.studentsOnly.name ())) {
        columnDataArray = StudentEntityExportHelper.transformStudentsOnly (student);
      } else if (exportType.equalsIgnoreCase (ExportStudentFormatEnums.accommodationsOnly.name ())) {
        columnDataArray = StudentEntityExportHelper.transformStudenttoAccommodationsOnly (student, resourceTypesMap,accommodationNames);
      } else if (exportType.equalsIgnoreCase (ExportStudentFormatEnums.explicitEligibility.name ())) {
        List<ExplicitEligibility> explicitEligibilities =  explicitEligRepository.findByStudentIdAndStateAbbreviation (student.getEntityId (), student.getStateAbbreviation ());
        columnDataArray = StudentEntityExportHelper.transformStudenttoExplicitEligibility (explicitEligibilities);
      }

      if (columnDataArray != null) {
        for (final String[] columnData : columnDataArray) {
          csvWriter.writeNext(columnData);
        }
      }
    }

    private void exportStudentGroup(final CSVWriter csvWriter, final StudentGroup studentGroup) {
        final String[] columnData = this.studentGroupEntityExportTransformer.transform(studentGroup);
        // add role association
        if (!CollectionUtils.isEmpty(studentGroup.getStudentIds())) {
            for (final String studentId : studentGroup.getStudentIds()) {
                columnData[3] = studentId;
                csvWriter.writeNext(columnData);
            }
        } else {
            csvWriter.writeNext(columnData);
        }
    }

    private void exportUser(final CSVWriter csvWriter, final User user) {
        final String[] columnData = user.toStringArray();
        // add role association
        if (!CollectionUtils.isEmpty(user.getRoleAssociations())) {
            for (final RoleAssociation role : user.getRoleAssociations()) {
                final String[] roleData = this.userRoleAssociationEntityExportTransformer.transform(role);
                final String[] allData = ObjectArrays.concat(columnData, roleData, String.class);
                csvWriter.writeNext(allData);
            }
        } else {
            csvWriter.writeNext(columnData);
        }
    }

    @Override
    public void renderMergedOutputModel(final Map<String, Object> model, final HttpServletRequest request,
            final HttpServletResponse response) throws IOException {
        // get data model which is passed by the Spring container

        response.setContentType(com.google.common.net.MediaType.CSV_UTF_8.toString());
        response.setHeader(com.google.common.net.HttpHeaders.CONTENT_DISPOSITION, "attachment; filename="
                + getFilename(model));
        writeValues(model, response.getWriter());

    }

    /**
     * Gets the display filename to return to the client
     * 
     * @param model
     *        the model
     * @return the filename
     */
    private String getFilename(final Map<String, Object> model) {
        final String formatType = ((String) model.get(FORMAT_TYPE)).toLowerCase();
        if (formatType.equalsIgnoreCase (FormatType.STUDENT.name ())) {
          final String exportType = ((String) model.get(EXPORT_TYPE));
          return exportType.concat(".csv");
        } else if (formatType.equalsIgnoreCase (FormatType.GROUPOFSTATES.name ()) || formatType.equalsIgnoreCase (FormatType.GROUPOFDISTRICTS.name ()) || formatType.equalsIgnoreCase (FormatType.GROUPOFINSTITUTIONS.name ())) { 
          return formatType.concat(".csv");
        }else
        return formatType.concat("s.csv");
    }

    @Override
    public String getContentType() {
        return this.CONTENT_TYPE;
    }
}
