/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/

package org.opentestsystem.delivery.testreg.rest.view;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;
import java.util.Map;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.Student;
import org.opentestsystem.delivery.testreg.domain.StudentGroup;
import org.opentestsystem.delivery.testreg.domain.TestRegistrationBase;
import org.opentestsystem.delivery.testreg.domain.User;
import org.opentestsystem.delivery.testreg.domain.User.RoleAssociation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.util.CollectionUtils;
import org.springframework.web.servlet.view.AbstractView;

import au.com.bytecode.opencsv.CSVWriter;

import com.google.common.collect.ObjectArrays;

/**
 * This class builds a CSV document using CSVWriter.
 */

public class CSVView extends AbstractView {

    private final String CONTENT_TYPE = com.google.common.net.MediaType.CSV_UTF_8.toString();

    private static final String DATA_LIST = "DATA_LIST";
    private static final String FORMAT_TYPE = "FORMAT_TYPE";

    @Resource(name = "headersMap")
    private Map<String, String[]> headersMap;

    @Autowired
    private Transformer<TestRegistrationBase, String[]> testRegistrationViewTransformer;

    @Autowired
    private Transformer<User.RoleAssociation, String[]> userRoleAssociationEntityExportTransformer;

    @Autowired
    private Transformer<StudentGroup, String[]> studentGroupEntityExportTransformer;

    @Autowired
    private Transformer<Student, String[][]> studentEntityExportTransformer;

    /**
     * Writes the CSV data to the response stream
     * 
     * @param model
     *        the model
     * @param out
     *        the response stream writer
     */
    @SuppressWarnings("unchecked")
    protected void writeValues(final Map<String, Object> model, final PrintWriter writer) throws IOException {

        final List<TestRegistrationBase> entityList = (List<TestRegistrationBase>) model.get(DATA_LIST);
        final String formatType = ((String) model.get(FORMAT_TYPE)).toUpperCase();

        final CSVWriter csvWriter = new CSVWriter(writer, ',');
        // Adding Title to the CSV row
        final String headerColumns[] = this.headersMap.get(formatType);
        // Add the Header
        csvWriter.writeNext(headerColumns);
        if (!CollectionUtils.isEmpty(entityList)) {
            for (final TestRegistrationBase entity : entityList) {
                switch (FormatType.valueOf(formatType)) {
                case STUDENT:
                    exportStudent(csvWriter, (Student) entity);
                    break;
                case STUDENTGROUP:
                    exportStudentGroup(csvWriter, (StudentGroup) entity);
                    break;
                case USER: // if format is user then we need to customize export to include role associations as separate rows
                    exportUser(csvWriter, (User) entity);
                    break;
                default:
                    csvWriter.writeNext(this.testRegistrationViewTransformer.transform(entity));
                    break;
                }
            }
        }
        csvWriter.flush();
        csvWriter.close();
    }

    private void exportStudent(final CSVWriter csvWriter, final Student student) {
        final String[][] columnDataArray = this.studentEntityExportTransformer.transform(student);

        if (columnDataArray != null) {
            for (final String[] columnData : columnDataArray) {
                csvWriter.writeNext(columnData);
            }
        }
    }

    private void exportStudentGroup(final CSVWriter csvWriter, final StudentGroup studentGroup) {
        final String[] columnData = this.studentGroupEntityExportTransformer.transform(studentGroup);
        // add role association
        if (!CollectionUtils.isEmpty(studentGroup.getStudentIds())) {
            for (final String studentId : studentGroup.getStudentIds()) {
                columnData[3] = studentId;
                csvWriter.writeNext(columnData);
            }
        } else {
            csvWriter.writeNext(columnData);
        }
    }

    private void exportUser(final CSVWriter csvWriter, final User user) {
        final String[] columnData = user.toStringArray();
        // add role association
        if (!CollectionUtils.isEmpty(user.getRoleAssociations())) {
            for (final RoleAssociation role : user.getRoleAssociations()) {
                final String[] roleData = this.userRoleAssociationEntityExportTransformer.transform(role);
                final String[] allData = ObjectArrays.concat(columnData, roleData, String.class);
                csvWriter.writeNext(allData);
            }
        } else {
            csvWriter.writeNext(columnData);
        }
    }

    @Override
    public void renderMergedOutputModel(final Map<String, Object> model, final HttpServletRequest request,
            final HttpServletResponse response) throws IOException {
        // get data model which is passed by the Spring container

        response.setContentType(com.google.common.net.MediaType.CSV_UTF_8.toString());
        response.setHeader(com.google.common.net.HttpHeaders.CONTENT_DISPOSITION, "attachment; filename="
                + getFilename(model));
        writeValues(model, response.getWriter());

    }

    /**
     * Gets the display filename to return to the client
     * 
     * @param model
     *        the model
     * @return the filename
     */
    private String getFilename(final Map<String, Object> model) {
        final String formatType = ((String) model.get(FORMAT_TYPE)).toLowerCase();
        return formatType.concat(".csv");
    }

    @Override
    public String getContentType() {
        return this.CONTENT_TYPE;
    }
}
