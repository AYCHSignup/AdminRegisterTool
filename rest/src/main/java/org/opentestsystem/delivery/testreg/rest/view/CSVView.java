/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/

package org.opentestsystem.delivery.testreg.rest.view;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;
import java.util.Map;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.collections.CollectionUtils;
import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.Student;
import org.opentestsystem.delivery.testreg.domain.StudentGroup;
import org.opentestsystem.delivery.testreg.domain.TestRegistrationBase;
import org.opentestsystem.delivery.testreg.domain.User;
import org.opentestsystem.delivery.testreg.domain.User.RoleAssociation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.servlet.view.AbstractView;

import au.com.bytecode.opencsv.CSVWriter;

import com.google.common.collect.ObjectArrays;

/**
 * This class builds a CSV document using CSVWriter.
 */

public class CSVView extends AbstractView {

    private final String CONTENT_TYPE = com.google.common.net.MediaType.CSV_UTF_8.toString();

    private static final String DATA_LIST = "DATA_LIST";
    private static final String FORMAT_TYPE = "FORMAT_TYPE";

    @Resource(name = "headersMap")
    private Map<String, String[]> headersMap;
    
    @Autowired
    private Transformer<TestRegistrationBase, String[]> testRegistrationViewTransformer;
    
    @Autowired
    private Transformer<User.RoleAssociation, String[]> userRoleAssociationEntityExportTransformer;
    
    @Autowired
    private Transformer<StudentGroup, String[]> studentGroupEntityExportTransformer;
    
    @Autowired
    private Transformer<Student, String[][]> studentEntityExportTransformer;



    /**
     * Writes the CSV data to the response stream
     * 
     * @param model
     *            the model
     * @param out
     *            the response stream writer
     */
    @SuppressWarnings("unchecked")
    protected void writeValues(final Map<String, Object> model, final PrintWriter writer) throws IOException {

        List<TestRegistrationBase> entityList = (List<TestRegistrationBase>) model.get(DATA_LIST);
        String formatType = ((String) model.get(FORMAT_TYPE)).toUpperCase();

        CSVWriter csvWriter = new CSVWriter(writer, ',');
        // Adding Title to the CSV row
        String headerColumns[] = headersMap.get(formatType);
        // Add the Header
        csvWriter.writeNext(headerColumns);
        if (CollectionUtils.isNotEmpty(entityList)) {
            for (TestRegistrationBase entity : entityList) {
                switch(FormatType.valueOf(formatType)) {                    
                    case STUDENT:
                        exportStudent(csvWriter, (Student)entity);
                        break;
                    case STUDENTGROUP:
                        exportStudentGroup(csvWriter, (StudentGroup)entity);  
                        break;
                    case USER:                //if format is user then we need to customize export to include role associations as separate rows                
                        exportUser(csvWriter, (User)entity);  
                        break;
                    default:
                        csvWriter.writeNext(testRegistrationViewTransformer.transform(entity));
                        break;                   
                }
            }
        }
        csvWriter.flush();
        csvWriter.close();
    }
    
    private void exportStudent(CSVWriter csvWriter, Student student) {
        String[][] columnDataArray = studentEntityExportTransformer.transform(student);
        
        if(columnDataArray !=null) {
            for(String[] columnData: columnDataArray) {
                csvWriter.writeNext(columnData);
            }
        }
    }

    private void exportStudentGroup(CSVWriter csvWriter, StudentGroup studentGroup) {       
        String[] columnData = studentGroupEntityExportTransformer.transform(studentGroup);
        //add role association
        if(CollectionUtils.isNotEmpty(studentGroup.getStudentIds())) {
           for (String studentId : studentGroup.getStudentIds()) {
               columnData[3] = studentId;
               csvWriter.writeNext(columnData);
           }
        } else {
            csvWriter.writeNext(columnData);
        }  
    }

    private void exportUser(CSVWriter csvWriter, User user) {
        String[] columnData = user.toStringArray();
        //add role association
        if(CollectionUtils.isNotEmpty(user.getRoleAssociations())) {
           for (RoleAssociation role : user.getRoleAssociations()) {
               String[] roleData = userRoleAssociationEntityExportTransformer.transform(role);
               String[] allData = ObjectArrays.concat(columnData, roleData, String.class);
               csvWriter.writeNext(allData);
           }
        } else {
            csvWriter.writeNext(columnData);
        }       
    }
    
    @Override
    public void renderMergedOutputModel(final Map<String, Object> model, final HttpServletRequest request,
            final HttpServletResponse response) throws IOException {
        // get data model which is passed by the Spring container

        response.setContentType(com.google.common.net.MediaType.CSV_UTF_8.toString());
        response.setHeader(com.google.common.net.HttpHeaders.CONTENT_DISPOSITION, "attachment; filename="
                + getFilename(model));
        writeValues(model, response.getWriter());

    }

    /**
     * Gets the display filename to return to the client
     * 
     * @param model
     *            the model
     * @return the filename
     */
    private String getFilename(final Map<String, Object> model) {
        String formatType = ((String) model.get(FORMAT_TYPE)).toLowerCase();
        return formatType.concat(".csv");
    }

    public String getContentType() {
        return CONTENT_TYPE;
    }
}
