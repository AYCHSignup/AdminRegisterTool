/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/

package org.opentestsystem.delivery.testreg.rest;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.io.FilenameUtils;
import org.opentestsystem.delivery.testreg.domain.FileUploadResponse;
import org.opentestsystem.delivery.testreg.domain.FileUploadSummary;
import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.TestRegistrationBase;
import org.opentestsystem.delivery.testreg.persistence.criteria.dependencyresolvers.Sb11DependencyResolverInvoker;
import org.opentestsystem.delivery.testreg.rest.ValidationMessage.ValidationMessageType;
import org.opentestsystem.delivery.testreg.service.FileUploadService;
import org.opentestsystem.delivery.testreg.service.TestRegPersister;
import org.opentestsystem.delivery.testreg.upload.DataRecord;
import org.opentestsystem.delivery.testreg.upload.FileFormatTypeAppender;
import org.opentestsystem.delivery.testreg.upload.FileUploadUtils;
import org.opentestsystem.delivery.testreg.upload.RowMetadata;
import org.opentestsystem.delivery.testreg.upload.parser.ParserResult;
import org.opentestsystem.delivery.testreg.upload.parser.UploadFileParser;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.exception.RestException;
import org.opentestsystem.shared.mna.client.domain.MnaSeverity;
import org.opentestsystem.shared.mna.client.service.AlertBeacon;
import org.opentestsystem.shared.mna.client.service.MetricClient;
import org.opentestsystem.shared.web.AbstractRestController;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.access.annotation.Secured;
import org.springframework.stereotype.Controller;
import org.springframework.util.CollectionUtils;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.validation.ValidationUtils;
import org.springframework.validation.Validator;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.multipart.MultipartFile;

import com.google.common.collect.Lists;
import com.mongodb.gridfs.GridFSDBFile;

@Controller
public class FileUploadDataController extends AbstractRestController {

    private static final Logger LOGGER = LoggerFactory.getLogger(FileUploadDataController.class);

    @Resource(name = "fileParserMap")
    private Map<FileType, UploadFileParser<Map<String, List<DataRecord>>>> fileParserMap;

    @Autowired
    @Qualifier("fileUploadValidator")
    private Validator fileUploadValidator;

    @Autowired
    private FileUploadService fileUploadService;

    @Autowired
    private TestRegPersister entityService;

    @Autowired
    private FileUploadUtils fileUploadUtils;

    @Autowired
    private Sb11DependencyResolverInvoker sb11DependencyResolverInvoker;

    @Autowired
    private FileFormatTypeAppender fileFormatTypeAppender;

    @Autowired
    private MetricClient metricClient;
    @Autowired
    private AlertBeacon alertBeacon;

    /**
     * Upload File.
     * 
     * @param testRegFile
     *        to be saved.
     * @returns response FileUploadResponse.
     */
    @ResponseStatus(HttpStatus.CREATED)
    @RequestMapping(value = "/uploadFile", method = RequestMethod.POST, produces = { MediaType.APPLICATION_JSON_VALUE })
    @Secured({ "ROLE_Accommodations Upload", "ROLE_Student Upload", "ROLE_Entity Upload", "ROLE_StudentGroup Upload", "ROLE_User Upload" })
    @ResponseBody
    public FileUploadResponse uploadFile(@RequestParam("uploadFile") final MultipartFile testRegFile, @RequestParam final String formatType) throws Exception {
        FileUploadResponse response;
        final long start = System.currentTimeMillis();
        if (!FileType.isValidType(testRegFile.getOriginalFilename())) {
            throw new LocalizedException("file.invalid.fileextension", new String[] {
                    FilenameUtils.getExtension(testRegFile.getOriginalFilename()), Arrays.toString(FileType.values()) });
        } else {
            /*
             * Following line inserts FormatType of the file as first row in the file.
             */
            // InputStream inputStream = fileFormatTypeAppender.forFile(testRegFile).insert(formatType);
            final long middle = System.currentTimeMillis();
            this.metricClient.sendPerformanceMetricToMna("upload begin", middle - start);
            response = this.fileUploadService.saveFile(testRegFile.getOriginalFilename(), testRegFile.getInputStream(), formatType);
            this.metricClient.sendPerformanceMetricToMna("upload end", System.currentTimeMillis() - middle);
            this.alertBeacon.sendAlert(MnaSeverity.INFO, "ART_" + FormatType.valueOf(formatType).getFormatName() + "_UPLOAD", response.getMessage());
        }
        return response;
    }

    /**
     * Validates a file given its format and gridFsId.
     * 
     * @param gridFsId
     *        A {@link ModelAttribute} whose value is bound from the request mapping variables.
     * @param result
     *        An interface for binding results of all forms of validation
     * @param response
     *        HttpServletResponse for sending HTTP-specific responses
     * @return Returns {@link FileValidationResult}
     * @throws Exception
     */
    @RequestMapping(value = "/validateFile/{gridFsId}", method = RequestMethod.GET, produces = { MediaType.APPLICATION_JSON_VALUE })
    @Secured({ "ROLE_Accommodations Upload", "ROLE_Student Upload", "ROLE_Entity Upload", "ROLE_StudentGroup Upload", "ROLE_User Upload" })
    @ResponseBody
    public List<FileValidationResult> validate(@ModelAttribute("gridFsId") final String gridFsId, final BindingResult result, final HttpServletResponse response) throws Exception {

        final long start = System.currentTimeMillis();
        final GridFSDBFile file = getGridFSDBFile(gridFsId);
        LOGGER.debug("validateFile->getGridFSDBFile took: " + (System.currentTimeMillis() - start));

        long startMarker = System.currentTimeMillis();

        // fileType cannot be null
        final FileType fileType = FileType.findByFilename(file.getFilename());
        // throws IllegalArgumentException when no enum is found from file-extension
        final UploadFileParser<Map<String, List<DataRecord>>> fileParser = this.fileParserMap.get(fileType);
        ParserResult<Map<String, List<DataRecord>>> parsedResult = null;
        try {
            parsedResult = fileParser.parse(file.getInputStream(), retrieveFormatTypeFromFileMetadata(file));
        } catch (final LocalizedException loc) {
            final List<FileValidationResult> results = new ArrayList<>();
            final FileValidationResult validationResult = new FileValidationResult();
            validationResult.addError(new ValidationMessage("Invalid File type: " + loc.getLocalizedMessage(), ValidationMessageType.FATAL_ERROR));
            results.add(validationResult);
            return results;
        }

        this.metricClient.sendPerformanceMetricToMna("validateFile->file parse", System.currentTimeMillis() - startMarker);

        if (parsedResult.isEmpty()) {
            final List<FileValidationResult> results = new ArrayList<>();
            final FileValidationResult validationResult = new FileValidationResult();
            validationResult.addError(new ValidationMessage("Invalid File type", ValidationMessageType.FATAL_ERROR));
            results.add(validationResult);
            return results;
        }

        startMarker = System.currentTimeMillis();
        ValidationUtils.invokeValidator(this.fileUploadValidator, parsedResult.getParsedObject(), result);
        this.metricClient.sendPerformanceMetricToMna("validateFile->validation", System.currentTimeMillis() - startMarker);

        final List<FileValidationResult> returnList = Lists.newArrayList();
        if (result.hasErrors()) {
            returnList.addAll(ValidationHelper.transform(result));
            this.metricClient.sendPerformanceMetricToMna("validateFile->total time", System.currentTimeMillis() - start);
        }
        return returnList;
    }

    /**
     * Preview File.
     * 
     * @param gridFsId
     *        file to be retrieved for preview.
     * @return List<FilePreview> file preview.
     */
    @ResponseStatus(HttpStatus.OK)
    @RequestMapping(value = "/previewFile/{gridFsId}", method = RequestMethod.GET, produces = { MediaType.APPLICATION_JSON_VALUE })
    @Secured({ "ROLE_Accommodations Upload", "ROLE_Student Upload", "ROLE_Entity Upload", "ROLE_StudentGroup Upload", "ROLE_User Upload" })
    @ResponseBody
    public List<FilePreview> previewFile(@PathVariable final String gridFsId) throws Exception {
        final long start = System.currentTimeMillis();
        final GridFSDBFile file = getGridFSDBFile(gridFsId);
        this.metricClient.sendPerformanceMetricToMna("previewFile->getGridFSDBFile", System.currentTimeMillis() - start);
        return FilePreviewHelper.extractDataForPreview(file.getInputStream(), retrieveFormatTypeFromFileMetadata(file), file.getFilename(), 7);
    }

    @ResponseStatus(HttpStatus.OK)
    @RequestMapping(value = "/saveEntity/{fileId}", method = RequestMethod.GET, produces = { MediaType.APPLICATION_JSON_VALUE })
    @Secured({ "ROLE_Accommodations Upload", "ROLE_Student Upload", "ROLE_Entity Upload", "ROLE_StudentGroup Upload", "ROLE_User Upload" })
    @ResponseBody
    public List<FileUploadSummary> saveEntity(@ModelAttribute("fileId") final String fileId, final BindingResult result, final HttpServletResponse response) throws Exception {

        final long start = System.currentTimeMillis();
        final GridFSDBFile file = getGridFSDBFile(fileId);
        this.metricClient.sendPerformanceMetricToMna("saveEntity->getGridFSDBFile", System.currentTimeMillis() - start);

        // reset our start marker...
        long startMarker = System.currentTimeMillis();
        final List<FileUploadSummary> summaryResponse = new ArrayList<>();
        final ParserResult<Map<FormatType, List<TestRegistrationBase>>> parsedEntities = extractFile(file);
        validate(fileId, result, response); // validate the file
        this.metricClient.sendPerformanceMetricToMna("saveEntity->validate", System.currentTimeMillis() - startMarker);

        for (final Map.Entry<FormatType, List<TestRegistrationBase>> mapEntry : parsedEntities.getParsedObject().entrySet()) {

            final FormatType type = mapEntry.getKey();
            final List<TestRegistrationBase> testRegistrationBaseList = mapEntry.getValue();
            this.metricClient.sendPerformanceMetricToMna("saveEntity->processing sb11Entity: type=" + type, testRegistrationBaseList.size());

            // Filter entities that needed to be saved.
            startMarker = System.currentTimeMillis();
            filterErrorRecords(type, parsedEntities.getIgnoredRowNumbers(), testRegistrationBaseList, result.getFieldErrors());
            this.metricClient.sendPerformanceMetricToMna("saveEntity->filterErrorRecords", System.currentTimeMillis() - startMarker);

            // reset our start marker...
            startMarker = System.currentTimeMillis();
            this.sb11DependencyResolverInvoker.resolveDependency(testRegistrationBaseList); // Resolve dependencies if any
            this.metricClient.sendPerformanceMetricToMna("saveEntity->resolveDependency", System.currentTimeMillis() - startMarker);

            // reset our start marker...
            startMarker = System.currentTimeMillis();
            final FileUploadSummary summaryCount = this.fileUploadUtils.processGroupEntities(testRegistrationBaseList, this.entityService);
            this.metricClient.sendPerformanceMetricToMna("saveEntity->processGroupEntities", System.currentTimeMillis() - startMarker);

            summaryCount.setFormatType(type);
            summaryResponse.add(summaryCount);
        }

        this.metricClient.sendPerformanceMetricToMna("saveEntity->total time", System.currentTimeMillis() - start);

        return summaryResponse;
    }

    // =====================================================================================================================

    private GridFSDBFile getGridFSDBFile(final String gridFsId) throws Exception {
        final GridFSDBFile file = this.fileUploadService.getFileById(gridFsId);
        if (null == file) {
            throw new RestException("file.invalid.fileId");
        }
        return file;
    }

    private ParserResult<Map<FormatType, List<TestRegistrationBase>>> extractFile(final GridFSDBFile file) throws Exception {
        return this.fileUploadUtils.extractFile(file.getFilename(), file.getInputStream(), retrieveFormatTypeFromFileMetadata(file));
    }

    private void filterErrorRecords(final FormatType formatType, final List<Integer> ignoredRows, final List<TestRegistrationBase> recordList, final List<FieldError> fieldErrors) {
        final List<TestRegistrationBase> errorRecords = new ArrayList<>();
        for (final FieldError fieldError : fieldErrors) {
            if (FormatType.valueOf(fieldError.getObjectName()).equals(formatType)) {
                /*
                 * Each field error has a metadata about where the error occurred in the upload file. Get the row number
                 * and adjust that with the row offset value. Find all error records in the original collection this
                 * way.
                 */
                // HEADER ROW + ARRAYLIST ROW INDEX OFFSET + TOTAL IGNORED ROWS
                final int ROW_OFFSET = 2;
                final int ignoredRowsSize = ignoredRows.isEmpty() ? 0 : ignoredRows.size();
                final int recordRowNumber = ((RowMetadata) fieldError.getArguments()[0]).getRowNum();

                if (!CollectionUtils.isEmpty(ignoredRows) && recordRowNumber < ignoredRows.get(0)) {
                    errorRecords.add(recordList.get(recordRowNumber - ROW_OFFSET));
                } else {
                    errorRecords.add(recordList.get(recordRowNumber - (ROW_OFFSET + ignoredRowsSize)));
                }
            }
        }
        recordList.removeAll(errorRecords);
    }

    private String retrieveFormatTypeFromFileMetadata(final GridFSDBFile file) {
        return (String) file.getMetaData().get("formatType");
    }
}
