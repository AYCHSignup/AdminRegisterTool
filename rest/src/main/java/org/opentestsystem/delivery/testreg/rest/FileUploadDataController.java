/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/

package org.opentestsystem.delivery.testreg.rest;

import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.io.FilenameUtils;
import org.opentestsystem.delivery.testreg.domain.FileUploadResponse;
import org.opentestsystem.delivery.testreg.domain.FileUploadSummary;
import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.TestRegistrationBase;
import org.opentestsystem.delivery.testreg.persistence.criteria.dependencyresolvers.Sb11DependencyResolverInvoker;
import org.opentestsystem.delivery.testreg.rest.ValidationMessage.ValidationMessageType;
import org.opentestsystem.delivery.testreg.service.FileUploadService;
import org.opentestsystem.delivery.testreg.service.TestRegPersister;
import org.opentestsystem.delivery.testreg.upload.DataRecord;
import org.opentestsystem.delivery.testreg.upload.FileFormatTypeAppender;
import org.opentestsystem.delivery.testreg.upload.FileUploadUtils;
import org.opentestsystem.delivery.testreg.upload.RowMetadata;
import org.opentestsystem.delivery.testreg.upload.parser.ParserResult;
import org.opentestsystem.delivery.testreg.upload.parser.UploadFileParser;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.exception.RestException;
import org.opentestsystem.shared.web.AbstractRestController;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.access.annotation.Secured;
import org.springframework.stereotype.Controller;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.validation.ValidationUtils;
import org.springframework.validation.Validator;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.multipart.MultipartFile;

import com.mongodb.gridfs.GridFSDBFile;

@Controller
public class FileUploadDataController extends AbstractRestController {

    private static final Logger LOGGER = LoggerFactory.getLogger(FileUploadDataController.class);

    @Resource(name = "fileParserMap")
    private Map<FileType, UploadFileParser<Map<String, List<DataRecord>>>> fileParserMap;

    @Autowired
    @Qualifier("fileUploadValidator")
    private Validator fileUploadValidator;

    @Autowired
    private FileUploadService fileUploadService;

    @Autowired
    private TestRegPersister entityService;

    @Autowired
    private FileUploadUtils fileUploadUtils;

    @Autowired
    private Sb11DependencyResolverInvoker sb11DependencyResolverInvoker;
    
    @Autowired
    private FileFormatTypeAppender fileFormatTypeAppender;

    /**
     * Upload File.
     *
     * @param testRegFile to be saved.
     * @returns response FileUploadResponse.
     */
    @ResponseStatus(HttpStatus.CREATED)
    @RequestMapping(value = "/uploadFile", method = RequestMethod.POST, produces = { MediaType.APPLICATION_JSON_VALUE })
    @Secured({ "ROLE_Accommodations Upload", "ROLE_Student Upload", "ROLE_Entity Upload", "ROLE_StudentGroup Upload", "ROLE_User Upload" })
    @ResponseBody
    public FileUploadResponse uploadFile(@RequestParam("uploadFile") final MultipartFile testRegFile, @RequestParam final String formatType) throws Exception {
        FileUploadResponse response;
        if (!FileType.isValidType(testRegFile.getOriginalFilename())) {
            throw new LocalizedException("file.invalid.fileextension", new String[] {
                    FilenameUtils.getExtension(testRegFile.getOriginalFilename()), Arrays.toString(FileType.values()) });
        } else {
            /*
             * Following line inserts FormatType of the file as first row in the file. 
             */
           InputStream inputStream = fileFormatTypeAppender
                                        .forFile(testRegFile)
                                        .insert(formatType);
            response = fileUploadService.saveFile(testRegFile.getOriginalFilename(), inputStream);
        }
        return response;
    }

    /**
     * Validates a file given its format and gridFsId.
     *
     * @param gridFsId A {@link ModelAttribute} whose value is bound from the request mapping variables.
     * @param result   An interface for binding results of all forms of validation
     * @param response HttpServletResponse for sending HTTP-specific responses
     * @return Returns {@link FileValidationResult}
     * @throws Exception
     */
    @RequestMapping(value = "/validateFile/{gridFsId}", method = RequestMethod.GET, produces = { MediaType.APPLICATION_JSON_VALUE })
    @Secured({ "ROLE_Accommodations Upload", "ROLE_Student Upload", "ROLE_Entity Upload", "ROLE_StudentGroup Upload", "ROLE_User Upload" })
    @ResponseBody
    public List<FileValidationResult> validate(@ModelAttribute("gridFsId") final String gridFsId,
            final BindingResult result, final HttpServletResponse response) throws Exception {

        long start = System.currentTimeMillis();
        GridFSDBFile file = getGridFSDBFile(gridFsId);
        LOGGER.debug("validateFile->getGridFSDBFile took: " + (System.currentTimeMillis() - start));

        long startMarker = System.currentTimeMillis();

        // fileType cannot be null
        FileType fileType = FileType.findByFilename(file.getFilename());
        // throws IllegalArgumentException when no enum is found from file-extension
        UploadFileParser<Map<String, List<DataRecord>>> fileParser = fileParserMap.get(fileType);
        ParserResult<Map<String, List<DataRecord>>> parsedResult = fileParser.parse(file.getInputStream());

        LOGGER.debug("validateFile->file parse took: " + (System.currentTimeMillis() - startMarker));

        if (parsedResult.isEmpty()) {
            List<FileValidationResult> results = new ArrayList<>();
            FileValidationResult validationResult = new FileValidationResult();
            validationResult.addError(new ValidationMessage("Invalid File type", ValidationMessageType.FATAL_ERROR));
            results.add(validationResult);
            return results;
        }

        startMarker = System.currentTimeMillis();
        ValidationUtils.invokeValidator(fileUploadValidator, parsedResult.getParsedObject(), result);
        LOGGER.debug("validateFile->validation took: " + (System.currentTimeMillis() - startMarker));

        List returnList = result.hasErrors() ? ValidationHelper.transform(result) : Collections.emptyList();
        LOGGER.debug("validateFile->total time took: " + (System.currentTimeMillis() - start));
        return returnList;
    }

    /**
     * Preview File.
     *
     * @param gridFsId file to be retrieved for preview.
     * @return List<FilePreview> file preview.
     */
    @ResponseStatus(HttpStatus.OK)
    @RequestMapping(value = "/previewFile/{gridFsId}", method = RequestMethod.GET, produces = { MediaType.APPLICATION_JSON_VALUE })
    @Secured({ "ROLE_Accommodations Upload", "ROLE_Student Upload", "ROLE_Entity Upload", "ROLE_StudentGroup Upload",
            "ROLE_User Upload" })
    @ResponseBody
    public List<FilePreview> previewFile(@PathVariable final String gridFsId) throws Exception {
        long start = System.currentTimeMillis();
        GridFSDBFile file = getGridFSDBFile(gridFsId);
        LOGGER.debug("previewFile->getGridFSDBFile took: " + (System.currentTimeMillis() - start));
        return FilePreviewHelper.extractDataForPreview(file.getInputStream(), file.getFilename(), 7);
    }

    @ResponseStatus(HttpStatus.OK)
    @RequestMapping(value = "/saveEntity/{fileId}", method = RequestMethod.GET, produces = { MediaType.APPLICATION_JSON_VALUE })
    @Secured({ "ROLE_Accommodations Upload", "ROLE_Student Upload", "ROLE_Entity Upload", "ROLE_StudentGroup Upload", "ROLE_User Upload" })
    @ResponseBody
    public List<FileUploadSummary> saveEntity(@ModelAttribute("fileId") final String fileId,
            final BindingResult result, final HttpServletResponse response) throws Exception {

        long start = System.currentTimeMillis();
        GridFSDBFile file = getGridFSDBFile(fileId);
        LOGGER.debug("saveEntity->getGridFSDBFile took: " + (System.currentTimeMillis() - start));

        // reset our start marker...
        long startMarker = System.currentTimeMillis();
        List<FileUploadSummary> summaryResponse = new ArrayList<>();
        ParserResult<Map<FormatType, List<TestRegistrationBase>>> parsedEntities = extractFile(file);
        validate(fileId, result, response); // validate the file
        LOGGER.debug("saveEntity->validate took: " + (System.currentTimeMillis() - startMarker));

        for (Map.Entry<FormatType, List<TestRegistrationBase>> mapEntry : parsedEntities.getParsedObject().entrySet()) {
            FormatType type = mapEntry.getKey();
            List<TestRegistrationBase> sb11Entity = mapEntry.getValue();

            // Filter entities that needed to be saved.
            filterErrorRecords(type, parsedEntities.getIgnoredRowNumbers(), sb11Entity, result.getFieldErrors());

            // reset our start marker...
            startMarker = System.currentTimeMillis();
            sb11DependencyResolverInvoker.resolveDependency(sb11Entity); // Resolve dependencies if any
            LOGGER.debug("saveEntity->resolveDependency took: " + (System.currentTimeMillis() - startMarker));

            // reset our start marker...
            startMarker = System.currentTimeMillis();
            FileUploadSummary summaryCount = fileUploadUtils.processGroupEntities(sb11Entity, entityService);
            LOGGER.debug("saveEntity->processGroupEntities took: " + (System.currentTimeMillis() - startMarker));

            summaryCount.setFormatType(type);
            summaryResponse.add(summaryCount);
        }

        LOGGER.debug("saveEntity->total took: " + (System.currentTimeMillis() - start));

        return summaryResponse;
    }

    // =====================================================================================================================

    private GridFSDBFile getGridFSDBFile(final String gridFsId) throws Exception {
        GridFSDBFile file = fileUploadService.getFileById(gridFsId);
        if (null == file) {
            throw new RestException("file.invalid.fileId");
        }
        return file;
    }

    private ParserResult<Map<FormatType, List<TestRegistrationBase>>> extractFile(final GridFSDBFile file) throws Exception {
        return fileUploadUtils.extractFile(file.getFilename(), file.getInputStream());
    }

    private void filterErrorRecords(final FormatType formatType, final List<Integer> ignoredRows,
            final List<TestRegistrationBase> recordList, final List<FieldError> fieldErrors) {

        List<TestRegistrationBase> errorRecords = new ArrayList<>();
        for (FieldError fieldError : fieldErrors) {
            if (FormatType.valueOf(fieldError.getObjectName()).equals(formatType)) {
                /*
                 * Each field error has a metadata about where the error occurred in the upload file. Get the row number
                 * and adjust that with the row offset value. Find all error records in the original collection this
                 * way.
                 */
                // FORMAT ROW + HEADER ROW + ARRAYLIST ROW INDEX OFFSET + TOTAL IGNORED ROWS
                final int ROW_OFFSET = 3;
                final int ignoredRowsSize = ignoredRows.isEmpty() ? 0 : ignoredRows.size();
                int recordRowNumber = ((RowMetadata) fieldError.getArguments()[0]).getRowNum();

                if (CollectionUtils.isNotEmpty(ignoredRows) && recordRowNumber < ignoredRows.get(0)) {
                    errorRecords
                            .add(recordList.get(recordRowNumber - ROW_OFFSET));
                } else {
                    errorRecords
                            .add(recordList.get(recordRowNumber - (ROW_OFFSET + ignoredRowsSize)));
                }
            }
        }
        recordList.removeAll(errorRecords);
    }
}
