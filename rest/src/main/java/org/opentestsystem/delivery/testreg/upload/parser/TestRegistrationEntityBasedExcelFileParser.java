/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/

package org.opentestsystem.delivery.testreg.upload.parser;

import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.TestRegistrationBase;
import org.opentestsystem.delivery.testreg.upload.ExcelUtils;
import org.opentestsystem.delivery.testreg.upload.ExcelUtils.*;
import org.opentestsystem.delivery.testreg.upload.FileUploadUtils;
import org.springframework.beans.factory.annotation.Autowired;

import java.io.InputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.opentestsystem.delivery.testreg.upload.ExcelUtils.*;
import static org.opentestsystem.delivery.testreg.upload.parser.ParserTextUtils.*;

public class TestRegistrationEntityBasedExcelFileParser implements UploadFileParser<Map<FormatType, List<TestRegistrationBase>>> {

    @Autowired
    ExcelUtils excelUtils;

    @Autowired
    private FileUploadUtils fileUploadUtils;

    @Override
    public ParserResult<Map<FormatType, List<TestRegistrationBase>>> parse(InputStream uploadFile) throws Exception {

        final Map<FormatType, List<TestRegistrationBase>> convertedMap = new HashMap<FormatType, List<TestRegistrationBase>>();
        final List<Integer> ignoredRowNums = new ArrayList<>();

        excelUtils.processExcelFile(uploadFile, new ExcelWorksheetProcessor() {
            @Override
            public void process(final Sheet sheet) {
                final List<TestRegistrationBase> excelRows = new ArrayList<TestRegistrationBase>();
                // make formattype an array of size 1 to get around "final" access from the inner class
                final FormatType[] formatType = new FormatType[1];

                boolean skipHeader = false;
                excelUtils.iterateRows(sheet, new ExcelRowMapper() {
                    int totalHeaders;

                    @Override
                    public boolean mapRow(final Row row) {
                        try {
                            String[] records = excelUtils.getRecordsWithNullRowsAsBlank(row);
                            if (getRowNum(row) == FORMAT_TYPE_ROW) {
                                formatType[0] = FormatType.valueOf(records[0]);
                                return true;
                            } else if (getRowNum(row) == HEADER_ROW) {
                                totalHeaders = records.length;
                                return true;
                            }
                            if (!isEmptyRecord(records)) {
                                fileUploadUtils.entityType(formatType[0], excelRows, padEmptyIfNoColumnAtEnd(totalHeaders, trimRecords(records)));
                            } else {
                                ignoredRowNums.add(getRowNum(row));
                            }
                        } catch (Exception e) {
                            throw new RuntimeException(e);
                        }
                        return true; // Continue mapping the row
                    }
                }, skipHeader, false);

                convertedMap.put(formatType[0], excelRows);
            }
        });

        return new ParserResultImpl<Map<FormatType, List<TestRegistrationBase>>>(ignoredRowNums, convertedMap);
    }
}
