/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.delivery.testreg.rest;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import org.opentestsystem.delivery.testreg.rest.ValidationMessage.ValidationMessageType;
import org.opentestsystem.delivery.testreg.upload.RowMetadata;
import org.opentestsystem.delivery.testreg.upload.RowMetadataImpl.RowErrorType;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.validation.ObjectError;

/**
 * Helper class for transforming spring binding errors into list of validation result objects.
 *
 */
public class ValidationHelper {

    private static final String GLOBAL_ERROR = "GLOBAL";
    
    /**
     * Transforms binding result errors into validation messages.
     * @param result contains global and field errors
     * @return List of FileValidationResult
     */
    public static List<FileValidationResult> transform(BindingResult result) {
       
        Map<String, List<ValidationMessage>> errorMap = new TreeMap<String, List<ValidationMessage>>();
        if (result.hasGlobalErrors()) {
            errorMap.putAll(transformGlobalErrors(result.getGlobalErrors()));
        } 
        if (result.hasFieldErrors()) {
            Map<String, List<ValidationMessage>> fieldErrors = transformFieldErrors(result.getFieldErrors());
            for(String key : fieldErrors.keySet()) {
                if(errorMap.containsKey(key)) {
                    errorMap.get(key).addAll(fieldErrors.get(key));
                } else {
                    errorMap.put(key,fieldErrors.get(key));
                }
            }
        }
        return buildValidationResult(errorMap);
    }
    
 
    /**
     * Transform global errors.
     * @param errors global errors
     * @return Map of validation messages for each worksheet
     */
    private static Map<String, List<ValidationMessage>> transformGlobalErrors(List<ObjectError> errors) {
        Map<String, List<ValidationMessage>> errorMap = new TreeMap<String, List<ValidationMessage>>();
        for (ObjectError error: errors) {
            ValidationMessage message = new ValidationMessage();
            message.setEntityName(GLOBAL_ERROR);
            message.setMessage(error.getDefaultMessage());
            message.setType(ValidationMessageType.FATAL_ERROR);
            addToErrorMap(errorMap, message);
        }
        return errorMap;
    }
    
    /**
     * Transform field errors.
     * @param errors field errors
     * @return Map of validation messages for each worksheet
     */
    private static Map<String, List<ValidationMessage>> transformFieldErrors(List<FieldError> errors) {
        Map<String, List<ValidationMessage>> errorMap = new TreeMap<String, List<ValidationMessage>>();
        for (FieldError error: errors) {
            ValidationMessage message = new ValidationMessage();
            message.setEntityName(error.getObjectName());
            message.setFieldName(error.getField());
            message.setFieldValue(String.valueOf(error.getRejectedValue()));
            message.setMessage(error.getDefaultMessage());
            RowMetadata rowMetadata = (RowMetadata) error.getArguments()[0];
            message.setRecordNumber(rowMetadata.getRowNum());
            if (rowMetadata.getErrorType() == RowErrorType.FATAL_ERROR) {
                message.setType(ValidationMessageType.FATAL_ERROR);
            } else if (rowMetadata.getErrorType() == RowErrorType.RECORD_ERROR){
                message.setType(ValidationMessageType.RECORD_ERROR);
            } else {
                message.setType(ValidationMessageType.WARNING);
            }
            addToErrorMap(errorMap, message);
        }
        
        return errorMap;
    }
    
    private static void addToErrorMap(Map<String, List<ValidationMessage>> errorMap, ValidationMessage message) {
        List<ValidationMessage> messages = errorMap.get(message.getEntityName());
        if (messages == null) {
            messages = new ArrayList<ValidationMessage>();
            messages.add(message);
            errorMap.put(message.getEntityName(), messages);
        } else {
            messages.add(message);
        }
    }
    
    private static List<FileValidationResult> buildValidationResult(Map<String, List<ValidationMessage>> errorMap) {
        List<FileValidationResult> validationResults = new ArrayList<FileValidationResult>();
        for (Map.Entry<String, List<ValidationMessage>> entry : errorMap.entrySet()) {
            FileValidationResult validationResult = new FileValidationResult();
            validationResult.setFormatType(entry.getKey().toUpperCase());        
            Collections.sort(entry.getValue());
            for (ValidationMessage message: entry.getValue()) {
                validationResult.addError(message); 
            }
            validationResults.add(validationResult);
        }   
        return validationResults;
    }
}

