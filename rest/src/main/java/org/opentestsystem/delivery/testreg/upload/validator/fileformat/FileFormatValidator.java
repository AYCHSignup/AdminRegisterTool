/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/

package org.opentestsystem.delivery.testreg.upload.validator.fileformat;

import static org.opentestsystem.delivery.testreg.domain.AnnotationHelper.getFieldLabel;

import java.lang.reflect.InvocationTargetException;
import java.util.Set;

import javax.validation.ConstraintViolation;
import javax.validation.Validator;

import org.apache.commons.beanutils.BeanUtils;
import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.ImportFileValidationGroup;
import org.opentestsystem.delivery.testreg.domain.TestRegistrationBase;
import org.opentestsystem.delivery.testreg.upload.FileDataRecord;
import org.opentestsystem.delivery.testreg.upload.FileUploadUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.validation.BindingResult;
import org.springframework.validation.Errors;
import org.springframework.validation.FieldError;

public abstract class FileFormatValidator extends AbstractFileHeaderValidator {

    @Autowired
    private Validator validator; // jsr303

    @Autowired
    protected FileUploadUtils fileUploadUtils;

    protected FileFormatValidator(final FormatType inFormat) {
        super(inFormat.name());
    }

    @Override
    protected boolean isValidFormat(final FileDataRecord record, final Errors errors) {
        BindingResult result = (BindingResult) errors;

        TestRegistrationBase sb11Entity = fileUploadUtils.getDomainObject(getFormat(), record.getColumns());
        return !processConstraintViolations(record, validator.validate(sb11Entity, ImportFileValidationGroup.class),
                result);
    }

    private boolean processConstraintViolations(final FileDataRecord record,
            final Set<ConstraintViolation<TestRegistrationBase>> violations, final BindingResult errors) {
        boolean hasErrors = false;
        for (ConstraintViolation<TestRegistrationBase> violation : violations) {
            errors.addError(new FieldError(getDatasetName(), getFieldLabel(violation.getLeafBean(), getPropertyName(violation)),
                    getInvalidValue(violation), false, null, new Object[] { record
                            .getRowMetadata() }, violation.getMessage()));
            hasErrors = true;
        }
        return hasErrors;
    }

    private String getInvalidValue(final ConstraintViolation<TestRegistrationBase> violation) {
        try {
            String fieldValue = BeanUtils.getProperty(violation.getLeafBean(), getPropertyName(violation));
            if (fieldValue == null) {
                return "";
            }
            return fieldValue;
        } catch (InvocationTargetException ite) {// Get the invalid value when not possible due to enum conversion issues
            return violation.getInvalidValue().toString();
        } catch (IllegalAccessException | NoSuchMethodException e) {
            throw new RuntimeException(e);
        }
    }

    private String getPropertyName(ConstraintViolation<TestRegistrationBase> violation) {
        String property = violation.getPropertyPath().toString();
        int lastDot = property.lastIndexOf('.');
        if (lastDot > 0) {
            return property.substring(lastDot + 1, property.length());
        }
        return property;
    }

    public FormatType getFormat() {
        return FormatType.valueOf(getDatasetName());
    }
}
