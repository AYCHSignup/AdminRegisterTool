/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/

package org.opentestsystem.delivery.testreg.upload.validator.fileformat;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.delivery.testreg.domain.DistrictEntity;
import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.InstitutionEntity;
import org.opentestsystem.delivery.testreg.upload.DataRecord;
import org.opentestsystem.delivery.testreg.upload.FileUploadUtils;
import org.opentestsystem.delivery.testreg.upload.RowMetadata;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;

@Component
public class DuplicateRecordProcessor {

    @Autowired
    protected FileUploadUtils fileUploadUtils;

    /**
     * Comb through the list of records and process them for duplicates based on the DataRecords
     * equals and hashCode implementations.
     * 
     * @param dataRecordList
     *        A list of DataRecords.
     * @return
     *         A Pair object that has the list of duplicate record and the unique record set. Unique record is sorted on based on
     *         row number.
     */
    public DuplicateUniquePair processDuplicates(final List<DataRecord> dataRecordList) {
        return findDuplicates(dataRecordList);
    }

    private SortedSet<DataRecord> sort(final Set<DataRecord> recordSet) {
        final SortedSet<DataRecord> sortedSet = Sets.newTreeSet(new RowIndexBasedComparator());
        sortedSet.addAll(recordSet);
        return sortedSet;
    }

    private DuplicateUniquePair findDuplicates(final List<DataRecord> dataRecordList) {
        final List<DataRecord> duplicates = Lists.newArrayList();

        final Set<DataRecord> uniqueRecordSet = Sets.newTreeSet(new DataRecordComparator());

        for (final DataRecord record : dataRecordList) {
            if (!uniqueRecordSet.add(record)) {
                duplicates.add(record);
            }
        }
        return new DuplicateUniquePair(duplicates, sort(uniqueRecordSet));
    }

    /**
     * Returns duplicate rows as list of row numbers array. For example, if row 1 has duplicates in row 8, row 10, row 11
     * and for row 3 have duplicates in row 6, row 9, this method would return a list like [{1,8,10, 11}, {3,6,9}]
     * 
     * @param duplicateUniquePair
     *        A pair object which has duplicate & unique records
     * @return
     *         An Integer array of duplicate row numbers segmented by the similar record type
     */
    public List<Integer[]> getDuplicateRowNumbers(final DuplicateUniquePair duplicateUniquePair) {
        final Map<DataRecord, List<Integer>> dataRecordDuplicateRowMap = Maps.newHashMap();

        final List<DataRecord> duplicatesList = duplicateUniquePair.getDuplicates();

        for (final DataRecord record : duplicateUniquePair.getUniqueRecordSet()) {
            if (duplicatesList.contains(record)) {
                if (dataRecordDuplicateRowMap.get(record) != null) {
                    dataRecordDuplicateRowMap.get(record).add(getRowNumber(record.getRowMetadata()));
                } else {
                    final List<Integer> recordNumbers = Lists.newArrayList();
                    recordNumbers.add(getRowNumber(record.getRowMetadata()));
                    final List<DataRecord> deseDupes = Lists.newArrayList(ImmutableList.copyOf(duplicatesList));
                    Iterables.retainAll(deseDupes, Arrays.asList(record));
                    recordNumbers.addAll(getRowNumbers(deseDupes));
                    dataRecordDuplicateRowMap.put(record, recordNumbers);
                }
            }
        }
        return getRowNumbersArray(dataRecordDuplicateRowMap.values());
    }

    private List<Integer> getRowNumbers(final List<DataRecord> recordList) {
        final List<Integer> rowNumbers = Lists.newArrayList();
        for (final DataRecord record : recordList) {
            rowNumbers.add(getRowNumber(record.getRowMetadata()));
        }
        return rowNumbers;
    }

    private List<Integer[]> getRowNumbersArray(final Collection<List<Integer>> values) {
        final List<Integer[]> duplicateRowArray = Lists.newArrayList();
        for (final List<Integer> dups : values) {
            duplicateRowArray.add(dups.toArray(new Integer[dups.size()]));
        }
        return duplicateRowArray;
    }

    private int getRowNumber(final RowMetadata rowMetadata) {
        return rowMetadata.getRowNum();
    }

    public Map<String, List<Integer>> getDuplicateNCESIds(final List<DataRecord> dataRecordList, final FormatType format) {
        final Map<String, List<Integer>> duplicates = Maps.newHashMap();
        final Set<String> duplicateNCESID = Sets.newHashSet();
        final List<String> origNCESIds = Lists.newArrayList();

        for (final DataRecord record : dataRecordList) {
            final Integer rowNum = record.getRowMetadata().getRowNum();
            if (rowNum > 1) {
                String ncesId = null;
                if (format == FormatType.DISTRICT) {
                    final DistrictEntity district = (DistrictEntity) this.fileUploadUtils.getDomainObject(FormatType.DISTRICT, record.getColumns());

                    ncesId = getNcesId(district.getNationwideIdentifier());
                } else if (format == FormatType.INSTITUTION) {
                    final InstitutionEntity institution = (InstitutionEntity) this.fileUploadUtils.getDomainObject(FormatType.INSTITUTION, record.getColumns());
                    ncesId = getNcesId(institution.getNationwideIdentifier());
                }
                origNCESIds.add(ncesId);
                if (!duplicateNCESID.add(ncesId)) {
                    addToDuplicate(duplicates, ncesId, rowNum, origNCESIds.indexOf(ncesId) + 3);
                }
            }
        }
        return duplicates;
    }

    // To make sure 00 and 0000 will be handled
    private String getNcesId(final String ncesIdValue) {
        return StringUtils.stripStart(ncesIdValue, "0");
    }

    private void addToDuplicate(final Map<String, List<Integer>> duplicates, final String ncesId, final Integer rowNum, final Integer origRowNum) {
        if (duplicates.containsKey(ncesId)) {
            final List<Integer> rowNums = duplicates.get(ncesId);
            rowNums.add(rowNum);
        } else {
            duplicates.put(ncesId, new ArrayList<Integer>(Arrays.asList(new Integer[] { origRowNum, rowNum })));
        }
    }
}
