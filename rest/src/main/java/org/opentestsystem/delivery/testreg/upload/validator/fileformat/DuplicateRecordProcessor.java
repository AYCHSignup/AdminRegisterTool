/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/

package org.opentestsystem.delivery.testreg.upload.validator.fileformat;

import static org.apache.commons.collections.ListUtils.retainAll;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.delivery.testreg.domain.DistrictEntity;
import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.InstitutionEntity;
import org.opentestsystem.delivery.testreg.upload.DataRecord;
import org.opentestsystem.delivery.testreg.upload.FileUploadUtils;
import org.opentestsystem.delivery.testreg.upload.RowMetadata;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class DuplicateRecordProcessor {

    @Autowired
    protected FileUploadUtils fileUploadUtils;

    /**
     * Comb through the list of records and process them for duplicates based on the DataRecords
     * equals and hashCode implementations.
     * 
     * @param dataRecordList
     *        A list of DataRecords.
     * @return
     *         A Pair object that has the list of duplicate record and the unique record set. Unique record is sorted on based on
     *         row number.
     */
    public DuplicateUniquePair processDuplicates(List<DataRecord> dataRecordList) {
        return findDuplicates(dataRecordList);
    }

    private SortedSet<DataRecord> sort(Set<DataRecord> recordSet) {
        SortedSet<DataRecord> sortedSet = new TreeSet<DataRecord>(new RowIndexBasedComparator());
        sortedSet.addAll(recordSet);
        return sortedSet;
    }

    private DuplicateUniquePair findDuplicates(List<DataRecord> dataRecordList) {
        final List<DataRecord> duplicates = new ArrayList<DataRecord>();

        Set<DataRecord> uniqueRecordSet = new TreeSet<DataRecord>(new DataRecordComparator());

        for (DataRecord record : dataRecordList) {
            if (!uniqueRecordSet.add(record)) {
                duplicates.add(record);
            }
        }
        return new DuplicateUniquePair(duplicates, sort(uniqueRecordSet));
    }

    /**
     * Returns duplicate rows as list of row numbers array. For example, if row 1 has duplicates in row 8, row 10, row 11
     * and for row 3 have duplicates in row 6, row 9, this method would return a list like [{1,8,10, 11}, {3,6,9}]
     * 
     * @param duplicateUniquePair
     *        A pair object which has duplicate & unique records
     * @return
     *         An Integer array of duplicate row numbers segmented by the similar record type
     */
    @SuppressWarnings("unchecked")
    public List<Integer[]> getDuplicateRowNumbers(DuplicateUniquePair duplicateUniquePair) {
        Map<DataRecord, List<Integer>> dataRecordDuplicateRowMap = new HashMap<DataRecord, List<Integer>>();
        Iterator<DataRecord> it = duplicateUniquePair.getUniqueRecordSet().iterator();
        while (it.hasNext()) {

            DataRecord record = it.next();

            if (duplicateUniquePair.getDuplicates().contains(record)) {

                if (dataRecordDuplicateRowMap.get(record) != null) {
                    dataRecordDuplicateRowMap.get(record).add(getRowNumber(record.getRowMetadata()));
                } else {
                    List<Integer> recordNumbers = new ArrayList<Integer>();
                    recordNumbers.add(getRowNumber(record.getRowMetadata()));
                    recordNumbers.addAll(getRowNumbers(retainAll(duplicateUniquePair.getDuplicates(), Arrays.asList(record))));
                    dataRecordDuplicateRowMap.put(record, recordNumbers);
                }
            }
        }
        return getRowNumbersArray(dataRecordDuplicateRowMap.values());
    }

    private List<Integer> getRowNumbers(List<DataRecord> recordList) {
        List<Integer> rowNumbers = new ArrayList<Integer>();
        for (DataRecord record : recordList) {
            rowNumbers.add(getRowNumber(record.getRowMetadata()));
        }
        return rowNumbers;

    }

    private List<Integer[]> getRowNumbersArray(Collection<List<Integer>> values) {
        List<Integer[]> duplicateRowArray = new ArrayList<Integer[]>();

        for (List<Integer> dups : values) {
            duplicateRowArray.add(dups.toArray(new Integer[dups.size()]));
        }
        return duplicateRowArray;
    }

    private int getRowNumber(RowMetadata rowMetadata) {
        return rowMetadata.getRowNum();
    }

    public Map<String, List<Integer>> getDuplicateNCESIds(List<DataRecord> dataRecordList, FormatType format) {
        final Map<String, List<Integer>> duplicates = new HashMap<String, List<Integer>>();
        Set<String> duplicateNCESID = new HashSet<String>();
        List<String> origNCESIds = new ArrayList<String>();

        for (DataRecord record : dataRecordList) {
            Integer rowNum = record.getRowMetadata().getRowNum();
            if (rowNum > 2) {
                String ncesId = null;
                if (format == FormatType.DISTRICT) {
                    DistrictEntity district = (DistrictEntity) fileUploadUtils.getDomainObject(FormatType.DISTRICT, record.getColumns());

                    ncesId = getNcesId(district.getNationwideIdentifier());
                } else if (format == FormatType.INSTITUTION) {
                    InstitutionEntity institution = (InstitutionEntity) fileUploadUtils.getDomainObject(FormatType.INSTITUTION, record.getColumns());
                    ncesId = getNcesId(institution.getNationwideIdentifier());
                }
                origNCESIds.add(ncesId);
                if (!duplicateNCESID.add(ncesId)) {
                    addToDuplicate(duplicates, ncesId, rowNum, origNCESIds.indexOf(ncesId) + 3);
                }
            }
        }
        return duplicates;
    }

    // To make sure 00 and 0000 will be handled
    private String getNcesId(String ncesIdValue) {
        return StringUtils.stripStart(ncesIdValue, "0");
    }

    private void addToDuplicate(Map<String, List<Integer>> duplicates, String ncesId, Integer rowNum, Integer origRowNum) {
        if (duplicates.containsKey(ncesId)) {
            List<Integer> rowNums = duplicates.get(ncesId);
            rowNums.add(rowNum);
        } else {
            duplicates.put(ncesId, new ArrayList<Integer>(Arrays.asList(new Integer[] { origRowNum, rowNum })));
        }
    }
}
