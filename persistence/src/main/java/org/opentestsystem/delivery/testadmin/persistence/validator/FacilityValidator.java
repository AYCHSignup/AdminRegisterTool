/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.delivery.testadmin.persistence.validator;

import java.util.List;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.delivery.testadmin.domain.Facility;
import org.opentestsystem.delivery.testadmin.domain.FacilityAvailability;
import org.opentestsystem.delivery.testadmin.domain.schedule.Schedule;
import org.opentestsystem.delivery.testadmin.service.FacilityAvailabilityService;
import org.opentestsystem.delivery.testadmin.service.FacilityService;
import org.opentestsystem.delivery.testadmin.service.ScheduleService;
import org.opentestsystem.delivery.testreg.domain.DeleteOperation;
import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.HierarchyLevel;
import org.opentestsystem.delivery.testreg.domain.Sb11Entity;
import org.opentestsystem.delivery.testreg.service.Sb11EntityRepositoryService;
import org.opentestsystem.delivery.testreg.service.impl.TestRegPersisterImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.validation.Errors;


@Component
public class FacilityValidator extends TestAdminBaseValidator {

    @Autowired
    private Sb11EntityRepositoryService sb11EntityService;
    
    @Autowired
    private TestRegPersisterImpl testRegPersister;
    
    @Autowired
    private FacilityAvailabilityService facilityAvailability;
    
    @Autowired
    private ScheduleService scheduleService;
    
    @Autowired
    private FacilityService facilityService;

    @Override
    public void validate(Object target, Errors errors, Object... validationHints) {
        //validate business rules
        final Facility facility = (Facility) target;
        
        if(isDeleteOperation(validationHints)) {
            Facility facilityInDB = facilityService.getFacility(facility.getId());
            String facilityId = facilityInDB.getId();

            if(hasAttachedAvailabilities(facilityId, facilityInDB.getInstitutionIdentifier())) {
                dependencyFoundWhileDelete(errors, facilityService.getFacility(facilityId));
            }           
        } else {
            //execute JSR-303 validations (annotations)
            super.validate(target, errors, validationHints);

            Sb11Entity institutionEntity = null;
            
            if (StringUtils.isNotBlank(facility.getInstitutionId())) {
                institutionEntity = testRegPersister.findById(facility.getInstitutionId(), FormatType.INSTITUTION);
            } else if (StringUtils.isNotBlank(facility.getInstitutionIdentifier()) 
                    && StringUtils.isNotBlank(facility.getStateAbbreviation())) {
                institutionEntity = sb11EntityService.findByEntityIdAndStateAbbreviation(facility.getInstitutionIdentifier(), 
                        facility.getStateAbbreviation(), HierarchyLevel.INSTITUTION.getEntityClass());
            }
    
            if (institutionEntity == null && StringUtils.isNotBlank(facility.getInstitutionIdentifier())
                    && StringUtils.isNotBlank(facility.getStateAbbreviation())) {
                errors.rejectValue("institutionIdentifier", facility.getInstitutionIdentifier(), "Institution identifier " +
                        facility.getInstitutionIdentifier() + " not found in the database");
            } else if (institutionEntity != null){
                facility.setInstitutionId(institutionEntity.getId());
            }
        }
    }
    
    private void dependencyFoundWhileDelete(Errors errors, Facility facility) {
        errors.rejectValue("facilityName", facility.getFacilityName(), facility.getFacilityName()+" cannot be deleted because it is associated with other entities. "
                + "Associated entities must be deleted before deleting this entity");
    }
    
    private boolean isDeleteOperation(Object[] validationHints) {
        if(validationHints !=null && validationHints.length==1) {
            if(validationHints[0] !=null && validationHints[0].equals(DeleteOperation.class)) {
                return true;
            }
        }
        return false;
    }
    
    private boolean hasAttachedAvailabilities(String facilityId, String institutionId) {
        List<FacilityAvailability> facilityAvailabilities = facilityAvailability.getAvailabilities(facilityId, institutionId);
        if(!facilityAvailabilities.isEmpty()) {
            return true;
        }
        else {
            return false;
        }
    }
    
    private boolean hasAttachedSchedules(String institutionPk) {
        List<Schedule> schedules = scheduleService.getSchedulesByInstitution(institutionPk);
        if(!schedules.isEmpty()) {
            return true;
        }
        else {
            return false;
        }
    }

}
