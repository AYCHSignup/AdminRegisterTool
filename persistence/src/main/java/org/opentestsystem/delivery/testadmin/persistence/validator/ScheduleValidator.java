/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.delivery.testadmin.persistence.validator;

import java.util.List;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.StringUtils;
import org.opentestsystem.delivery.testadmin.domain.Facility.SeatConfiguration;
import org.opentestsystem.delivery.testadmin.domain.schedule.Schedule;
import org.opentestsystem.delivery.testadmin.domain.schedule.ScheduledDay;
import org.opentestsystem.delivery.testadmin.domain.schedule.ScheduledFacility;
import org.opentestsystem.delivery.testadmin.domain.schedule.ScheduledTimeSlot;
import org.opentestsystem.delivery.testadmin.service.ScheduleService;
import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.InstitutionEntity;
import org.opentestsystem.delivery.testreg.service.impl.TestRegPersisterImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.validation.Errors;

@Component
public class ScheduleValidator extends TestAdminBaseValidator {

    @Autowired
    private ScheduleService scheduleService;

    @Autowired
    private TestRegPersisterImpl testRegPersister;

    @Override
    public void validate(Object target, Errors errors, Object... validationHints) {
        //execute JSR-303 validations (annotations)
        super.validate(target, errors, validationHints);
        if (target instanceof ScheduledDay) {
            //validate scheduleDay
            final ScheduledDay scheduleDay = (ScheduledDay) target;
            System.out.println(scheduleDay.toString());
            int totalCapacity = findTotalCapacity(scheduleDay);
            int assignedSeats = findAssignedSeats(scheduleDay);
            if (assignedSeats > totalCapacity) {
                errors.rejectValue("id", String.valueOf(totalCapacity), "Number of seats or students scheduled cannot be more than total capacity");
            }
            
        } else {
            //validate business rules
            final Schedule schedule = (Schedule) target;
            if (StringUtils.isNotBlank(schedule.getInstitutionId())) {
                InstitutionEntity institutionEntity = testRegPersister.findById(schedule.getInstitutionId(), FormatType.INSTITUTION);
    
                if (institutionEntity == null) {
                    errors.rejectValue("institutionIdentifier", schedule.getInstitutionIdentifier(), "Institution identifier " +
                            schedule.getInstitutionIdentifier() + " not found in the database");
                }
            }
            //find overlapping time interval
            List<Schedule> schedules = scheduleService.getSchedulesByInstitution(schedule.getInstitutionId());
            for (Schedule dbschedule : schedules) {
                if (schedule.getId() != null && schedule.getId().equals(dbschedule.getId())) {
                    //do not validate already saved availability
                    continue;
                }
                if ((schedule.getStartDate().isAfter(dbschedule.getStartDate()) && schedule.getStartDate().isBefore(dbschedule.getEndDate()))
                        || (schedule.getEndDate().isAfter(dbschedule.getStartDate()) && schedule.getEndDate().isBefore(dbschedule.getEndDate()))) {
                    //add error
                    errors.rejectValue("startDate", null, "Start and end date overlaps with start and end date of another schedule");
                    break;
                }
                if (schedule.getStartDate().isEqual(dbschedule.getStartDate()) || schedule.getStartDate().isEqual(dbschedule.getEndDate())
                        || schedule.getEndDate().isEqual(dbschedule.getStartDate()) || schedule.getEndDate().isEqual(dbschedule.getStartDate())) {
                    //add error
                    errors.rejectValue("startDate", null, "Start and end date overlaps with start and end date of another schedule");
                    break;
                }
                //check if from date and to date encompass other dates
                if (schedule.getStartDate().isBefore(dbschedule.getStartDate()) && schedule.getEndDate().isAfter(dbschedule.getEndDate())) {
                    //add error
                    errors.rejectValue("fromDate", null, "From date and To date overlaps with from and to date of another facility availability");
                    break;
                }
            }
        }
    }

    private int findTotalCapacity(final ScheduledDay scheduleDay) {
        int totalCapacity = 0;        
        ScheduledFacility facility  = scheduleDay.getFacilities().get(0);
        if (CollectionUtils.isNotEmpty(facility.getSeatConfigurations())) {
            for (SeatConfiguration config : facility.getSeatConfigurations()) {
                totalCapacity += config.getNumberOfSeats();
            }
        }
        return totalCapacity;
    }

    private int findAssignedSeats(final ScheduledDay scheduleDay) {
        int assignedSeats = 0;
        ScheduledFacility facility  = scheduleDay.getFacilities().get(0);
        if (CollectionUtils.isNotEmpty(facility.getTimeSlots())) {
           ScheduledTimeSlot timeslot = facility.getTimeSlots().iterator().next();
           assignedSeats = CollectionUtils.isNotEmpty(timeslot.getSeats()) ? timeslot.getSeats().size() : 0;
        }
        return assignedSeats;
    }
}
