/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.delivery.testadmin.persistence.validator;

import java.util.List;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.delivery.testadmin.domain.Facility.SeatConfiguration;
import org.opentestsystem.delivery.testadmin.domain.schedule.Schedule;
import org.opentestsystem.delivery.testadmin.domain.schedule.ScheduledDay;
import org.opentestsystem.delivery.testadmin.domain.schedule.ScheduledFacility;
import org.opentestsystem.delivery.testadmin.domain.schedule.ScheduledSeat;
import org.opentestsystem.delivery.testadmin.domain.schedule.ScheduledTimeSlot;
import org.opentestsystem.delivery.testadmin.service.ScheduleService;
import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.HierarchyLevel;
import org.opentestsystem.delivery.testreg.domain.Sb11Entity;
import org.opentestsystem.delivery.testreg.service.Sb11EntityRepositoryService;
import org.opentestsystem.delivery.testreg.service.impl.TestRegPersisterImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;
import org.springframework.validation.Errors;

@Component
public class ScheduleValidator extends TestAdminBaseValidator {

    @Autowired
    private ScheduleService scheduleService;

    @Autowired
    private Sb11EntityRepositoryService sb11EntityService;
    
    @Autowired
    private TestRegPersisterImpl testRegPersister;

    @Override
    public void validate(final Object target, final Errors errors, final Object... validationHints) {
        // execute JSR-303 validations (annotations)
        super.validate(target, errors, validationHints);
        if (target instanceof ScheduledDay) {
            // validate scheduleDay
            final ScheduledDay scheduleDay = (ScheduledDay) target;
            final int totalCapacity = findTotalCapacity(scheduleDay);
            final int assignedSeats = findAssignedSeats(scheduleDay);
            if (assignedSeats > totalCapacity) {
                errors.rejectValue("id", String.valueOf(totalCapacity), "Number of seats or students scheduled cannot be more than total capacity");
            }

        } else {
            // validate business rules
            final Schedule schedule = (Schedule) target;
            Sb11Entity institutionEntity = null;
            
            if (StringUtils.isNotBlank(schedule.getInstitutionId())) {
                institutionEntity = testRegPersister.findById(schedule.getInstitutionId(), FormatType.INSTITUTION);
            } else if (StringUtils.isNotBlank(schedule.getInstitutionIdentifier())
                    && StringUtils.isNotBlank(schedule.getStateAbbreviation())) {
                institutionEntity = sb11EntityService.findByEntityIdAndStateAbbreviation(schedule.getInstitutionIdentifier(), 
                        schedule.getStateAbbreviation(), HierarchyLevel.INSTITUTION.getEntityClass());
            }

            if (institutionEntity == null && StringUtils.isNotBlank(schedule.getInstitutionIdentifier())
                    && StringUtils.isNotBlank(schedule.getStateAbbreviation())) {
                errors.rejectValue("institutionIdentifier", schedule.getInstitutionIdentifier(), "Institution identifier " +
                        schedule.getInstitutionIdentifier() + " not found in the database");
            } else if (institutionEntity != null){
                schedule.setInstitutionId(institutionEntity.getId());
            }
            
            if (schedule.getStartDate() != null && schedule.getEndDate() != null) {
                // find overlapping time interval
                final List<Schedule> schedules = this.scheduleService.getSchedulesByInstitution(schedule.getInstitutionId());
                for (final Schedule dbschedule : schedules) {
                    if (schedule.getId() != null && schedule.getId().equals(dbschedule.getId())) {
                        // do not validate already saved availability
                        continue;
                    }
                    if (schedule.getStartDate().isAfter(dbschedule.getStartDate()) && schedule.getStartDate().isBefore(dbschedule.getEndDate())
                            || schedule.getEndDate().isAfter(dbschedule.getStartDate()) && schedule.getEndDate().isBefore(dbschedule.getEndDate())) {
                        // add error
                        errors.rejectValue("startDate", null, "Start and end date overlaps with start and end date of another schedule");
                        break;
                    }
                    if (schedule.getStartDate().isEqual(dbschedule.getStartDate()) || schedule.getStartDate().isEqual(dbschedule.getEndDate())
                            || schedule.getEndDate().isEqual(dbschedule.getStartDate()) || schedule.getEndDate().isEqual(dbschedule.getStartDate())) {
                        // add error
                        errors.rejectValue("startDate", null, "Start and end date overlaps with start and end date of another schedule");
                        break;
                    }
                    // check if from date and to date encompass other dates
                    if (schedule.getStartDate().isBefore(dbschedule.getStartDate()) && schedule.getEndDate().isAfter(dbschedule.getEndDate())) {
                        // add error
                        errors.rejectValue("fromDate", null, "From date and To date overlaps with from and to date of another facility availability");
                        break;
                    }
                }
            }
        }
    }

    private int findTotalCapacity(final ScheduledDay scheduleDay) {
        int totalCapacity = 0;
        final ScheduledFacility facility = scheduleDay.getFacilities().get(0);
        if (!CollectionUtils.isEmpty(facility.getSeatConfigurations())) {
            for (final SeatConfiguration config : facility.getSeatConfigurations()) {
                totalCapacity += config.getNumberOfSeats();
            }
        }
        return totalCapacity;
    }

    private int findAssignedSeats(final ScheduledDay scheduleDay) {
        int assignedSeats = 0;
        final ScheduledFacility facility = scheduleDay.getFacilities().get(0);
        if (!CollectionUtils.isEmpty(facility.getTimeSlots())) {
            final ScheduledTimeSlot timeslot = facility.getTimeSlots().iterator().next();
            for(ScheduledSeat seat : timeslot.getSeats()){
              if(seat.getStudent () != null)
                  assignedSeats++;
            }
        }
        return assignedSeats;
    }
   
}
