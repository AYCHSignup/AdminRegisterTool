/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.delivery.testadmin.persistence.validator;

import java.util.List;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.StringUtils;
import org.joda.time.DateTime;
import org.opentestsystem.delivery.testadmin.domain.Availability;
import org.opentestsystem.delivery.testadmin.domain.FacilityAvailability;
import org.opentestsystem.delivery.testadmin.domain.FacilityAvailability.FacilityTimeSlot;
import org.opentestsystem.delivery.testadmin.domain.TimeSlot;
import org.opentestsystem.delivery.testadmin.service.FacilityAvailabilityService;
import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.InstitutionEntity;
import org.opentestsystem.delivery.testreg.service.impl.TestRegPersisterImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.validation.Errors;

@Component
public class FacilityAvailabilityValidator extends TestAdminBaseValidator {

    @Autowired
    private FacilityAvailabilityService facilityAvailabilityService;

    @Autowired
    private TestRegPersisterImpl testRegPersister;

    @Override
    public void validate(Object target, Errors errors, Object... validationHints) {
        //execute JSR-303 validations (annotations)
        super.validate(target, errors, validationHints);
        DateTime now = new DateTime();
        String errorLabel = "time period";
        //validate business rules
        //find facility availabilities for this facility
        final FacilityAvailability favailability = (FacilityAvailability) target;
        if (StringUtils.isNotBlank(favailability.getInstitutionId())) {
            InstitutionEntity institutionEntity = testRegPersister.findById(favailability.getInstitutionId(), FormatType.INSTITUTION);

            if (institutionEntity == null) {
                errors.rejectValue("institutionIdentifier", favailability.getInstitutionIdentifier(), "Institution identifier " +
                        favailability.getInstitutionIdentifier() + " not found in the database");
            }
        }
        if (favailability.getStatus() == Availability.AVAILABLE) {
            errorLabel = "testing slot";
            if (CollectionUtils.isNotEmpty(favailability.getFacilityTimes())) {
                for (FacilityTimeSlot fts : favailability.getFacilityTimes()) {
                    if (CollectionUtils.isEmpty(fts.getSeatConfigurations())) {
                        errors.rejectValue("facilityTimes", favailability.getInstitutionIdentifier(),
                                "At least one seat configuration must be added for testing slot");
                    }
                }
            }

            if (favailability.getFromDate() != null && favailability.getToDate() != null) {
                List<FacilityAvailability> availabilities = facilityAvailabilityService.getAvailabilities(favailability.getFacilityId());

                for (FacilityAvailability fa : availabilities) {
                    if (favailability.getId() != null && favailability.getId().equals(fa.getId())) {
                        //do not validate already saved availability
                        continue;
                    }
                    if ((favailability.getFromDate().isAfter(fa.getFromDate()) && favailability.getFromDate().isBefore(fa.getToDate()))
                            || (favailability.getToDate().isAfter(fa.getFromDate()) && favailability.getToDate().isBefore(fa.getToDate()))) {
                        //add error
                        errors.rejectValue("fromDate", null, "From date and To date overlaps with from and to date of another facility availability");
                        break;
                    }
                    if (favailability.getFromDate().isEqual(fa.getFromDate()) || favailability.getFromDate().isEqual(fa.getToDate())
                            || favailability.getToDate().isEqual(fa.getFromDate()) || favailability.getToDate().isEqual(fa.getFromDate())) {
                        //add error
                        errors.rejectValue("fromDate", null, "From date and To date overlaps with from and to date of another facility availability");
                        break;
                    }
                    //check if from date and to date encompass other dates
                    if (favailability.getFromDate().isBefore(fa.getFromDate()) && favailability.getToDate().isAfter(fa.getToDate())) {
                        //add error
                        errors.rejectValue("fromDate", null, "From date and To date overlaps with from and to date of another facility availability");
                        break;
                    }
                }
            }
        }
        if (CollectionUtils.isNotEmpty(favailability.getFacilityTimes())) {
            int index = 0;
            for (FacilityTimeSlot ftcurrent : favailability.getFacilityTimes()) {
                TimeSlot currentTS = ftcurrent.getTimeSlot();
                if (currentTS.getStartTime() == null || currentTS.getEndTime() == null) {
                    //don't validate if it is null, there will already be bean validation error
                    continue;
                }
                if (favailability.getFromDate().getDayOfMonth() == now.getDayOfMonth() &&
                        favailability.getFromDate().getMonthOfYear() == now.getMonthOfYear() &&
                        favailability.getFromDate().getYear() == now.getYear() && now.isAfter(currentTS.getStartTime())) {
                    //add error
                    errors.rejectValue("facilityTimes", null, "Start time cannot be earlier than current time for today's date");
                }
                if (currentTS.getStartTime().isEqual(currentTS.getEndTime())) {
                    //add error
                    errors.rejectValue("facilityTimes", null, "Start time and End time of " + errorLabel + " cannot be same");
                }
                int subindex = 0;
                for (FacilityTimeSlot ft : favailability.getFacilityTimes()) {
                    TimeSlot ts = ft.getTimeSlot();
                    if (currentTS.compareTo(ts) != 0) {
                        if ((currentTS.getStartTime().isAfter(ts.getStartTime()) && currentTS.getStartTime().isBefore(ts.getEndTime()))
                                || (currentTS.getEndTime().isAfter(ts.getStartTime()) && currentTS.getEndTime().isBefore(ts.getEndTime()))) {
                            //add error
                            errors.rejectValue("facilityTimes", null, "Start time and End time of " + errorLabel + " overlaps with start and end time of another " + errorLabel);
                            break;

                        }
                        if (currentTS.getStartTime().isEqual(ts.getStartTime())
                                || currentTS.getEndTime().isEqual(ts.getEndTime())) {
                            //add error
                            errors.rejectValue("facilityTimes", null, "Start time and End time of " + errorLabel + " overlaps with start and end time of another " + errorLabel);
                            break;
                        }
                        if (currentTS.getStartTime().isBefore(ts.getStartTime()) && currentTS.getEndTime().isAfter(ts.getEndTime())) {
                            //add error
                            errors.rejectValue("facilityTimes", null, "Start time and End time of " + errorLabel + " overlaps with start and end time of another " + errorLabel);
                            break;
                        }
                    } else {
                        //add error
                        if (index != subindex) {
                            errors.rejectValue("facilityTimes", null, "Start time and End time of " + errorLabel + " overlaps with start and end time of another " + errorLabel);
                            break;
                        }
                    }
                    subindex += 1;
                }
                if (errors.hasErrors()) {
                    break;
                }
                index += 1;
            }
        }
    }

}
