/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.delivery.testadmin.persistence.validator;

import java.util.List;

import org.apache.commons.lang.StringUtils;
import org.joda.time.DateTime;
import org.opentestsystem.delivery.testadmin.domain.Availability;
import org.opentestsystem.delivery.testadmin.domain.FacilityAvailability;
import org.opentestsystem.delivery.testadmin.domain.FacilityAvailability.FacilityTimeSlot;
import org.opentestsystem.delivery.testadmin.domain.TimeSlot;
import org.opentestsystem.delivery.testadmin.service.FacilityAvailabilityService;
import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.HierarchyLevel;
import org.opentestsystem.delivery.testreg.domain.Sb11Entity;
import org.opentestsystem.delivery.testreg.service.Sb11EntityRepositoryService;
import org.opentestsystem.delivery.testreg.service.impl.TestRegPersisterImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;
import org.springframework.validation.Errors;

@Component
public class FacilityAvailabilityValidator extends TestAdminBaseValidator {

    @Autowired
    private FacilityAvailabilityService facilityAvailabilityService;

    @Autowired
    private TestRegPersisterImpl testRegPersister;

    @Autowired
    private Sb11EntityRepositoryService sb11EntityService;

    @Override
    public void validate(final Object target, final Errors errors, final Object... validationHints) {
        // execute JSR-303 validations (annotations)
        super.validate(target, errors, validationHints);
        final DateTime now = new DateTime();
        String errorLabel = "time period";
        // validate business rules
        // find facility availabilities for this facility
        final FacilityAvailability favailability = (FacilityAvailability) target;
        Sb11Entity institutionEntity = null;
        
        if (StringUtils.isNotBlank(favailability.getInstitutionId())) {
            institutionEntity = this.testRegPersister.findById(favailability.getInstitutionId(), FormatType.INSTITUTION);
        } else if (StringUtils.isNotBlank(favailability.getInstitutionIdentifier())
                && StringUtils.isNotBlank(favailability.getStateAbbreviation())){
            institutionEntity = this.sb11EntityService.findByEntityIdAndStateAbbreviation(favailability.getInstitutionIdentifier(), 
                    favailability.getStateAbbreviation(), HierarchyLevel.INSTITUTION.getEntityClass());
        }

        if (institutionEntity == null && StringUtils.isNotBlank(favailability.getInstitutionIdentifier())
                && StringUtils.isNotBlank(favailability.getStateAbbreviation())) {
            errors.rejectValue("institutionIdentifier", favailability.getInstitutionIdentifier(), "Institution identifier " +
                    favailability.getInstitutionIdentifier() + " not found in the database");
        } else if (institutionEntity != null){
            favailability.setInstitutionId(institutionEntity.getId());
        }
        
        if (favailability.getStatus() == Availability.AVAILABLE) {
            errorLabel = "testing slot";
            if (!CollectionUtils.isEmpty(favailability.getFacilityTimes())) {
                for (final FacilityTimeSlot fts : favailability.getFacilityTimes()) {
                    if (CollectionUtils.isEmpty(fts.getSeatConfigurations())) {
                        errors.rejectValue("facilityTimes", favailability.getInstitutionIdentifier(),
                                "At least one seat configuration must be added for testing slot");
                    }
                }
            }

            if (favailability.getFromDate() != null && favailability.getToDate() != null) {
                final List<FacilityAvailability> availabilities = this.facilityAvailabilityService.getAvailabilities(favailability.getFacilityId());

                for (final FacilityAvailability fa : availabilities) {
                    if (favailability.getId() != null && favailability.getId().equals(fa.getId())) {
                        // do not validate already saved availability
                        continue;
                    }
                    if (favailability.getFromDate().isAfter(fa.getFromDate()) && favailability.getFromDate().isBefore(fa.getToDate())
                            || favailability.getToDate().isAfter(fa.getFromDate()) && favailability.getToDate().isBefore(fa.getToDate())) {
                        // add error
                        errors.rejectValue("fromDate", null, "From date and To date overlaps with from and to date of another facility availability");
                        break;
                    }
                    if (favailability.getFromDate().isEqual(fa.getFromDate()) || favailability.getFromDate().isEqual(fa.getToDate())
                            || favailability.getToDate().isEqual(fa.getFromDate()) || favailability.getToDate().isEqual(fa.getFromDate())) {
                        // add error
                        errors.rejectValue("fromDate", null, "From date and To date overlaps with from and to date of another facility availability");
                        break;
                    }
                    // check if from date and to date encompass other dates
                    if (favailability.getFromDate().isBefore(fa.getFromDate()) && favailability.getToDate().isAfter(fa.getToDate())) {
                        // add error
                        errors.rejectValue("fromDate", null, "From date and To date overlaps with from and to date of another facility availability");
                        break;
                    }
                }
            }
        }
        if (!CollectionUtils.isEmpty(favailability.getFacilityTimes())) {
            int index = 0;
            for (final FacilityTimeSlot ftcurrent : favailability.getFacilityTimes()) {
                final TimeSlot currentTS = ftcurrent.getTimeSlot();
                if (currentTS.getStartTime() == null || currentTS.getEndTime() == null) {
                    // don't validate if it is null, there will already be bean validation error
                    continue;
                }
                if (favailability.getFromDate().getDayOfMonth() == now.getDayOfMonth() &&
                        favailability.getFromDate().getMonthOfYear() == now.getMonthOfYear() &&
                        favailability.getFromDate().getYear() == now.getYear() && now.isAfter(currentTS.getStartTime())) {
                    // add error
                    errors.rejectValue("facilityTimes", null, "Start time cannot be earlier than current time for today's date");
                }
                if (currentTS.getStartTime().isEqual(currentTS.getEndTime())) {
                    // add error
                    errors.rejectValue("facilityTimes", null, "Start time and End time of " + errorLabel + " cannot be same");
                }
                int subindex = 0;
                if (errors.hasErrors()) {
                    break;
                }
                for (final FacilityTimeSlot ft : favailability.getFacilityTimes()) {
                    final TimeSlot ts = ft.getTimeSlot();
                    if (currentTS.compareTo(ts) != 0) {
                        if (currentTS.getStartTime().isAfter(ts.getStartTime()) && currentTS.getStartTime().isBefore(ts.getEndTime())
                                || currentTS.getEndTime().isAfter(ts.getStartTime()) && currentTS.getEndTime().isBefore(ts.getEndTime())) {
                            // add error
                            errors.rejectValue("facilityTimes", null, "Start time and End time of " + errorLabel + " overlaps with start and end time of another " + errorLabel);
                            break;

                        }
                        if (currentTS.getStartTime().isEqual(ts.getStartTime())
                                || currentTS.getEndTime().isEqual(ts.getEndTime())) {
                            // add error
                            errors.rejectValue("facilityTimes", null, "Start time and End time of " + errorLabel + " overlaps with start and end time of another " + errorLabel);
                            break;
                        }
                        if (currentTS.getStartTime().isBefore(ts.getStartTime()) && currentTS.getEndTime().isAfter(ts.getEndTime())) {
                            // add error
                            errors.rejectValue("facilityTimes", null, "Start time and End time of " + errorLabel + " overlaps with start and end time of another " + errorLabel);
                            break;
                        }
                    } else {
                        // add error
                        if (index != subindex) {
                            errors.rejectValue("facilityTimes", null, "Start time and End time of " + errorLabel + " overlaps with start and end time of another " + errorLabel);
                            break;
                        }
                    }
                    subindex += 1;
                }
                if (errors.hasErrors()) {
                    break;
                }
                index += 1;
            }
        }
    }

}
