/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.delivery.testadmin.service.impl;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.joda.time.LocalDateTime;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
import org.opentestsystem.delivery.testadmin.domain.ParticipationSummaryReport;
import org.opentestsystem.delivery.testadmin.domain.TestAdminReport;
import org.opentestsystem.delivery.testadmin.domain.TestStatus;
import org.opentestsystem.delivery.testadmin.persistence.TestStatusRepository;
import org.opentestsystem.delivery.testadmin.service.ParticipationSummaryReportService;
import org.opentestsystem.delivery.testreg.domain.Assessment;
import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.HierarchyLevel;
import org.opentestsystem.delivery.testreg.domain.Sb11Entity;
import org.opentestsystem.delivery.testreg.persistence.AssessmentRepository;
import org.opentestsystem.delivery.testreg.persistence.EligibleStudentRepository;
import org.opentestsystem.delivery.testreg.service.Sb11EntityRepositoryService;
import org.opentestsystem.delivery.testreg.service.TestRegPersister;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.google.common.collect.Lists;

@Service
public class ParticipationSummaryReportServiceImpl implements ParticipationSummaryReportService {

    @Autowired
    private TestRegPersister entityService;

    @Autowired
    private TestStatusRepository studentTestRepository;

    @Autowired
    private Sb11EntityRepositoryService sb11EntityService;

    @Autowired
    private EligibleStudentRepository eligibleStudentRepository;

    @Autowired
    private AssessmentRepository assessmentRepository;

    @Override
    public Map<String, Assessment> findAssessmentsByTenantId(String tenantId, String tenantType) {

        Map<String, Assessment> testNameMap = new HashMap<String, Assessment>();
        List<Assessment> assessments = null;
        if (tenantType.equals(FormatType.CLIENT.name())) {
            assessments = assessmentRepository.findAll();
        } else {
            assessments = assessmentRepository.findByTenantId(tenantId);
        }
        for (Assessment assessment : assessments) {
            testNameMap.put(assessment.getId(), assessment);
        }
        return testNameMap;
    }

    public List<TestAdminReport> buildPartipationReport(String entityType, String entityId, HierarchyLevel levelOfReport, Map<String, Assessment> assessmentMap, int opportunity) {

        Set<String> assessmentIds = assessmentMap.keySet();
        List<TestAdminReport> reportList = new ArrayList<TestAdminReport>();
        Sb11Entity selectedEntity = entityService.findById(entityId, FormatType.valueOf(entityType));
        Map<String, List<Sb11Entity>> treeMap = new HashMap<String, List<Sb11Entity>>();

        treeMap.put(entityType, Lists.newArrayList(selectedEntity));

        Map<String, List<Sb11Entity>> loadedGroupOfReport = loadChildHierarchyByParent(entityType, treeMap, 0, levelOfReport.name());
        List<Sb11Entity> data = loadedGroupOfReport.get(levelOfReport.name());
        List<Sb11Entity> institutionList = null;
        Sb11Entity parentEntity = null;

        for (Sb11Entity reportEntity : data) {
            if (reportEntity.getFormatType() != FormatType.CLIENT) {
                parentEntity = entityService.findById(reportEntity.getParentId(), FormatType.valueOf(reportEntity.getParentEntityType().name()));
            }
            for (String assessmentId : assessmentIds) {
                if (reportEntity.getFormatType() == FormatType.INSTITUTION) {
                    institutionList = Lists.newArrayList(reportEntity);
                }
                else {
                    Map<String, List<Sb11Entity>> loadInstitutionTreeMap = new HashMap<String, List<Sb11Entity>>();
                    loadInstitutionTreeMap.put(reportEntity.getFormatType().name(), Lists.newArrayList(reportEntity));
                    Map<String, List<Sb11Entity>> returnMap = loadChildHierarchyByParent(levelOfReport.name(), loadInstitutionTreeMap, 0, HierarchyLevel.INSTITUTION.name());
                    institutionList = returnMap.get("INSTITUTION");
                }
                reportList.add(creatPartipationReport(institutionList, assessmentId, reportEntity, parentEntity, opportunity, assessmentMap.get(assessmentId)));
            }
        }

        return reportList;

    }

    private TestAdminReport creatPartipationReport(final List<Sb11Entity> institutionEntityList, final String assessmentId, final Sb11Entity selectedEntity,
            final Sb11Entity parentEntity, int opportunity, Assessment assessment) {

        long totalStudents = 0;
        long optedOutCount = 0;
        long startedCount = 0;
        long notStartedCount = 0;
        long completedCount = 0;
        for (Sb11Entity institutionEntity : institutionEntityList) {
            List<String> studentIds = eligibleStudentRepository.findByIdInstitutionIdAndAssessmentId(institutionEntity.getId(), assessmentId);
            List<TestStatus> studentReports = studentTestRepository.findStudentReport(studentIds, institutionEntity.getStateAbbreviation(), assessmentId, opportunity, null);
            notStartedCount = notStartedCount + (studentIds.size() - studentReports.size());
            totalStudents = totalStudents + studentIds.size();
            for (TestStatus testReport : studentReports) {

                switch (testReport.getStatus()) {

                case OPTED_OUT:
                    optedOutCount = optedOutCount + 1;
                    break;
                case SCHEDULED:
                    notStartedCount = notStartedCount + 1;
                    break;
                case STARTED:
                    startedCount = startedCount + 1;
                    break;
                case COMPLETED:
                    completedCount = completedCount + 1;
                    break;

                }
            }
        }
        return populateSummaryReport(selectedEntity, parentEntity, assessmentId, totalStudents, optedOutCount, notStartedCount, startedCount, completedCount, assessment);

    }

    private ParticipationSummaryReport populateSummaryReport(Sb11Entity entity, Sb11Entity parentEntity, String assessmentId, long totalStudents,
            long optedOutCount, long scheduledCount, long startedCount, long completedCount, Assessment assessment) {

        DateTimeFormatter dateFormat = DateTimeFormat.forPattern("yyyy-MM-dd HH:mm");
        String reportDate = dateFormat.print(LocalDateTime.now());
        ParticipationSummaryReport participationReport = new ParticipationSummaryReport();
        participationReport.setCurrentDateTime(reportDate);
        participationReport.setTestName(assessment.getTestName());
        participationReport.setTotalCount(totalStudents);
        participationReport.setScheduledCount(scheduledCount);
        participationReport.setOptedOutCount(optedOutCount);
        participationReport.setCompletedCount(completedCount);
        participationReport.setStartedCount(startedCount);
        participationReport.setEntityId(entity.getEntityId());
        participationReport.setEntityName(entity.getEntityName());
        if (entity.getFormatType() != FormatType.CLIENT) {
            participationReport.setParentEntityType(entity.getParentEntityType());
            participationReport.setParentEntityId(parentEntity.getEntityId());
            participationReport.setParentEntityName(parentEntity.getEntityName());
        }

        return participationReport;
    }

    public Map<String, List<Sb11Entity>> loadChildHierarchyByParent(String level, Map<String, List<Sb11Entity>> treeMap, int index, String groupByLevel) {

        if (level.equals(groupByLevel)) {
            return treeMap;
        }
        List<Sb11Entity> sb11EntityList = treeMap.get(level);

        if (sb11EntityList.size() > index) {
            Sb11Entity entity = sb11EntityList.get(index);
            String[] childHierarchyData = entityTreeMap().get(level);
            for (String child : childHierarchyData) {
                @SuppressWarnings("unchecked")
                List<Sb11Entity> childEntityList = (List<Sb11Entity>) sb11EntityService.findAllByParentEntityTypeAndParentId(level, entity.getId(), HierarchyLevel.valueOf(child).getEntityClass());
                if (treeMap.get(child) != null) {
                    treeMap.get(child).addAll(childEntityList);
                } else {
                    treeMap.put(child, childEntityList);
                }
            }
        } else {
            String[] childHierarchyData = entityTreeMap().get(level);
            for (String child : childHierarchyData) {
                if (treeMap.get(child) != null) {
                    return loadChildHierarchyByParent(child, treeMap, 0, groupByLevel);
                }
            }
            return null;
        }

        index = index + 1;
        return loadChildHierarchyByParent(level, treeMap, index, groupByLevel);

    }

    private Map<String, String[]> entityTreeMap() {
        Map<String, String[]> treeMap = new HashMap<String, String[]>();

        treeMap.put("CLIENT", new String[] { "GROUPOFSTATES", "STATE", "GROUPOFDISTRICTS", "DISTRICT", "GROUPOFINSTITUTIONS", "INSTITUTION" });
        treeMap.put("GROUPOFSTATES", new String[] { "STATE", "GROUPOFDISTRICTS", "DISTRICT", "GROUPOFINSTITUTIONS", "INSTITUTION" });
        treeMap.put("STATE", new String[] { "GROUPOFDISTRICTS", "DISTRICT", "GROUPOFINSTITUTIONS", "INSTITUTION" });
        treeMap.put("GROUPOFDISTRICTS", new String[] { "DISTRICT", "GROUPOFINSTITUTIONS", "INSTITUTION" });
        treeMap.put("DISTRICT", new String[] { "GROUPOFINSTITUTIONS", "INSTITUTION" });
        treeMap.put("GROUPOFINSTITUTIONS", new String[] { "INSTITUTION" });
        treeMap.put("INSTITUTION", null);

        return treeMap;
    }

}
