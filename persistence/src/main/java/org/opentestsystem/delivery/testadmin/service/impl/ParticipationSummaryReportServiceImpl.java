/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.delivery.testadmin.service.impl;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.joda.time.LocalDateTime;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
import org.opentestsystem.delivery.testadmin.domain.ParticipationSummaryReport;
import org.opentestsystem.delivery.testadmin.domain.TestAdminReport;
import org.opentestsystem.delivery.testadmin.domain.TestStatus;
import org.opentestsystem.delivery.testadmin.persistence.TestStatusRepository;
import org.opentestsystem.delivery.testadmin.service.ParticipationSummaryReportService;
import org.opentestsystem.delivery.testreg.domain.Assessment;
import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.HierarchyLevel;
import org.opentestsystem.delivery.testreg.domain.Sb11Entity;
import org.opentestsystem.delivery.testreg.persistence.AssessmentRepository;
import org.opentestsystem.delivery.testreg.persistence.EligibleStudentRepository;
import org.opentestsystem.delivery.testreg.service.Sb11EntityRepositoryService;
import org.opentestsystem.delivery.testreg.service.TestRegPersister;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.google.common.collect.Lists;

@Service
public class ParticipationSummaryReportServiceImpl implements ParticipationSummaryReportService {

    @Autowired
    private TestRegPersister entityService;

    @Autowired
    private TestStatusRepository studentTestRepository;

    @Autowired
    private Sb11EntityRepositoryService sb11EntityService;

    @Autowired
    private EligibleStudentRepository eligibleStudentRepository;

    @Autowired
    private AssessmentRepository assessmentRepository;

    @Override
    public Map<String, Assessment> findAssessmentsByTenantId(final String tenantId, final String tenantType) {

        final Map<String, Assessment> testNameMap = new HashMap<String, Assessment>();
        List<Assessment> assessments = null;
        if (tenantType.equals(FormatType.CLIENT.name())) {
            assessments = this.assessmentRepository.findAll();
        } else {
            assessments = this.assessmentRepository.findByTenantId(tenantId);
        }
        for (final Assessment assessment : assessments) {
            testNameMap.put(assessment.getId(), assessment);
        }
        return testNameMap;
    }

    @Override
    public List<TestAdminReport> buildParticipationReport(final String entityType, final String entityId, final HierarchyLevel levelOfReport, final Map<String, Assessment> assessmentMap,
            final int opportunity) {

        final Set<String> assessmentIds = assessmentMap.keySet();
        final List<TestAdminReport> reportList = new ArrayList<TestAdminReport>();
        final Sb11Entity selectedEntity = this.entityService.findById(entityId, FormatType.valueOf(entityType));
        final Map<String, List<Sb11Entity>> treeMap = new HashMap<String, List<Sb11Entity>>();

        treeMap.put(entityType, Lists.newArrayList(selectedEntity));

        final Map<String, List<Sb11Entity>> loadedGroupOfReport = loadChildHierarchyByParent(entityType, treeMap, 0, levelOfReport.name());
        final List<Sb11Entity> data = loadedGroupOfReport.get(levelOfReport.name());
        List<Sb11Entity> institutionList = null;
        Sb11Entity parentEntity = null;

        for (final Sb11Entity reportEntity : data) {
            if (reportEntity.getFormatType() != FormatType.CLIENT) {
                parentEntity = this.entityService.findById(reportEntity.getParentId(), FormatType.valueOf(reportEntity.getParentEntityType().name()));
            }
            for (final String assessmentId : assessmentIds) {
                if (reportEntity.getFormatType() == FormatType.INSTITUTION) {
                    institutionList = Lists.newArrayList(reportEntity);
                }
                else {
                    final Map<String, List<Sb11Entity>> loadInstitutionTreeMap = new HashMap<String, List<Sb11Entity>>();
                    loadInstitutionTreeMap.put(reportEntity.getFormatType().name(), Lists.newArrayList(reportEntity));
                    final Map<String, List<Sb11Entity>> returnMap = loadChildHierarchyByParent(levelOfReport.name(), loadInstitutionTreeMap, 0, HierarchyLevel.INSTITUTION.name());
                    institutionList = returnMap.get("INSTITUTION");
                }
                reportList.add(creatPartipationReport(institutionList, assessmentId, reportEntity, parentEntity, opportunity, assessmentMap.get(assessmentId)));
            }
        }

        return reportList;

    }

    private TestAdminReport creatPartipationReport(final List<Sb11Entity> institutionEntityList, final String assessmentId, final Sb11Entity selectedEntity,
            final Sb11Entity parentEntity, final int opportunity, final Assessment assessment) {

        long totalStudents = 0;
        long optedOutCount = 0;
        long startedCount = 0;
        long notStartedCount = 0;
        long completedCount = 0;
        for (final Sb11Entity institutionEntity : institutionEntityList) {
            final List<String> studentIds = this.eligibleStudentRepository.findByIdInstitutionIdAndAssessmentId(institutionEntity.getId(), assessmentId);
            final List<TestStatus> studentReports = this.studentTestRepository.findStudentReport(studentIds, institutionEntity.getStateAbbreviation(), assessmentId, opportunity, null);
            notStartedCount = notStartedCount + (studentIds.size() - studentReports.size());
            totalStudents = totalStudents + studentIds.size();
            for (final TestStatus testReport : studentReports) {

                switch (testReport.getStatus()) {

                case OPTED_OUT:
                    optedOutCount = optedOutCount + 1;
                    break;
                case SCHEDULED:
                    notStartedCount = notStartedCount + 1;
                    break;
                case STARTED:
                    startedCount = startedCount + 1;
                    break;
                case COMPLETED:
                    completedCount = completedCount + 1;
                    break;

                }
            }
        }
        return populateSummaryReport(selectedEntity, parentEntity, assessmentId, totalStudents, optedOutCount, notStartedCount, startedCount, completedCount, assessment);

    }

    private ParticipationSummaryReport populateSummaryReport(final Sb11Entity entity, final Sb11Entity parentEntity, final String assessmentId, final long totalStudents,
            final long optedOutCount, final long scheduledCount, final long startedCount, final long completedCount, final Assessment assessment) {

        final DateTimeFormatter dateFormat = DateTimeFormat.forPattern("yyyy-MM-dd HH:mm");
        final String reportDate = dateFormat.print(LocalDateTime.now());
        final ParticipationSummaryReport participationReport = new ParticipationSummaryReport();
        participationReport.setCurrentDateTime(reportDate);
        participationReport.setTestName(assessment.getTestName());
        participationReport.setTotalCount(totalStudents);
        participationReport.setScheduledCount(scheduledCount);
        participationReport.setOptedOutCount(optedOutCount);
        participationReport.setCompletedCount(completedCount);
        participationReport.setStartedCount(startedCount);
        participationReport.setEntityId(entity.getEntityId());
        participationReport.setEntityName(entity.getEntityName());
        if (entity.getFormatType() != FormatType.CLIENT) {
            participationReport.setParentEntityType(entity.getParentEntityType());
            participationReport.setParentEntityId(parentEntity.getEntityId());
            participationReport.setParentEntityName(parentEntity.getEntityName());
        }

        return participationReport;
    }

    public Map<String, List<Sb11Entity>> loadChildHierarchyByParent(final String level, final Map<String, List<Sb11Entity>> treeMap, int index, final String groupByLevel) {

        if (level.equals(groupByLevel)) {
            return treeMap;
        }
        final List<Sb11Entity> sb11EntityList = treeMap.get(level);

        if (sb11EntityList.size() > index) {
            final Sb11Entity entity = sb11EntityList.get(index);
            if (entity != null) {
                final String[] childHierarchyData = entityTreeMap().get(level);
                for (final String child : childHierarchyData) {
                    @SuppressWarnings("unchecked")
                    final List<Sb11Entity> childEntityList = (List<Sb11Entity>) this.sb11EntityService.findAllByParentEntityTypeAndParentId(level, entity.getId(), HierarchyLevel.valueOf(child)
                            .getEntityClass());
                    if (treeMap.get(child) != null) {
                        treeMap.get(child).addAll(childEntityList);
                    } else {
                        treeMap.put(child, childEntityList);
                    }
                }
            }
        } else {
            final String[] childHierarchyData = entityTreeMap().get(level);
            for (final String child : childHierarchyData) {
                if (treeMap.get(child) != null) {
                    return loadChildHierarchyByParent(child, treeMap, 0, groupByLevel);
                }
            }
            return null;
        }

        index = index + 1;
        return loadChildHierarchyByParent(level, treeMap, index, groupByLevel);

    }

    private Map<String, String[]> entityTreeMap() {
        final Map<String, String[]> treeMap = new HashMap<String, String[]>();

        treeMap.put("CLIENT", new String[] { "GROUPOFSTATES", "STATE", "GROUPOFDISTRICTS", "DISTRICT", "GROUPOFINSTITUTIONS", "INSTITUTION" });
        treeMap.put("GROUPOFSTATES", new String[] { "STATE", "GROUPOFDISTRICTS", "DISTRICT", "GROUPOFINSTITUTIONS", "INSTITUTION" });
        treeMap.put("STATE", new String[] { "GROUPOFDISTRICTS", "DISTRICT", "GROUPOFINSTITUTIONS", "INSTITUTION" });
        treeMap.put("GROUPOFDISTRICTS", new String[] { "DISTRICT", "GROUPOFINSTITUTIONS", "INSTITUTION" });
        treeMap.put("DISTRICT", new String[] { "GROUPOFINSTITUTIONS", "INSTITUTION" });
        treeMap.put("GROUPOFINSTITUTIONS", new String[] { "INSTITUTION" });
        treeMap.put("INSTITUTION", null);

        return treeMap;
    }

}
