/*
Educational Online Test Delivery System Copyright (c) 2013 American Institutes for Research

Distributed under the AIR Open Source License, Version 1.0 See accompanying file AIR-License-1_0.txt or at
http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 */

package org.opentestsystem.delivery.testreg.aop.trigger;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Date;
import java.util.concurrent.ScheduledFuture;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Scope;
import org.springframework.scheduling.TaskScheduler;
import org.springframework.scheduling.Trigger;
import org.springframework.scheduling.TriggerContext;
import org.springframework.stereotype.Component;

/**
 * Trigger class that allows for a definition of trigger period in milliseconds and is resettable. This means that the
 * Trigger firing is delayed if the trigger is reset.
 * 
 */
@Component
@Scope("prototype")
public class ResettableTrigger implements Trigger {

    private static final Logger LOGGER = LoggerFactory.getLogger(ResettableTrigger.class);

    @Autowired
    private TaskScheduler scheduler;

    /**
     * How long until this trigger should fire in milliseconds
     */
    private long triggerPeriod;

    private long lastReset;

    private ScheduledFuture<?> future;

    private TriggeredFunction triggeredFunction;

    private boolean triggerFired;

    public void setup(final long inTriggerPeriod, final Object inInvoker, final Method inToInvoke, final Object[] inArgs) {

        triggerFired = false;

        triggerPeriod = inTriggerPeriod;
        lastReset = System.currentTimeMillis();

        triggeredFunction = new TriggeredFunction(inInvoker, inToInvoke, inArgs);

        future = scheduler.schedule(triggeredFunction, this);

    }

    /**
     * Use this method to reset when the trigger will fire. The timer starts from when the Trigger was created and is
     * reset when the resetTrigger method is called.
     */
    public void resetTrigger() {
        lastReset = System.currentTimeMillis();

        // need to cancel the currently scheduled runnable

        if (future != null) {
            future.cancel(true);

            future = scheduler.schedule(triggeredFunction, this);
        }

    }

    @Override
    public Date nextExecutionTime(final TriggerContext triggerContext) {

        java.util.Date executeDate = null;

        // do not fire trigger if the trigger period was not set
        // do not fire trigger if the context says that the trigger was previously executed
        // otherwise, the next execution time should be lastReset in milliseconds + triggerPeriod
        if (triggerPeriod == 0) {
            executeDate = null;
        } else if (triggerContext.lastActualExecutionTime() != null || triggerContext.lastCompletionTime() != null) {
            executeDate = null;
        } else {
            executeDate = new java.util.Date(lastReset + triggerPeriod);
        }

        LOGGER.debug("************************* next execution time set to: " + executeDate
                + " *************************************");

        return executeDate;
    }

    public boolean isTriggerFired() {
        return triggerFired;
    }

    public class TriggeredFunction implements Runnable {

        private Object invoker;
        private Method toInvoke;
        private Object[] args;

        public TriggeredFunction(final Object inInvoker, final Method inToInvoke, final Object[] inArgs) {
            invoker = inInvoker;
            toInvoke = inToInvoke;
            args = inArgs;
        }

        @Override
        public void run() {

            try {
                LOGGER.debug("********************** Firing trigger at: " + new java.util.Date()
                        + " *****************************");

                toInvoke.invoke(invoker, args);
                triggerFired = true;
            } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
                e.printStackTrace();
            }

        }

    }

}
