/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.delivery.testreg.service.impl;

import java.io.StringWriter;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.annotation.Resource;

import org.joda.time.DateTime;
import org.opentestsystem.delivery.Sb11TimeZoneBuilder;
import org.opentestsystem.delivery.testreg.domain.Assessment;
import org.opentestsystem.delivery.testreg.domain.Assessment.TestWindow;
import org.opentestsystem.delivery.testreg.domain.HierarchyLevel;
import org.opentestsystem.delivery.testreg.domain.Sb11Entity;
import org.opentestsystem.delivery.testreg.service.EligibilityService;
import org.opentestsystem.delivery.testreg.service.ParentTreeFinderService;
import org.opentestsystem.delivery.testreg.service.ProctorPackageService;
import org.opentestsystem.delivery.testreg.service.Sb11EntityRepositoryService;
import org.opentestsystem.delivery.testreg.service.TestRegUserDetailsService;
import org.opentestsystem.shared.progman.client.domain.Tenant;
import org.opentestsystem.shared.progman.client.domain.TenantType;
import org.opentestsystem.shared.security.domain.SbacEntity;
import org.opentestsystem.shared.security.service.TenancyService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.convert.ConversionService;
import org.springframework.stereotype.Service;

import com.google.common.collect.Sets;
import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.converters.Converter;
import com.thoughtworks.xstream.converters.MarshallingContext;
import com.thoughtworks.xstream.converters.UnmarshallingContext;
import com.thoughtworks.xstream.io.HierarchicalStreamReader;
import com.thoughtworks.xstream.io.HierarchicalStreamWriter;

/**
 * Implementation of ProctorAssessment Service.
 */
@Service
public class ProctorPackageServiceImpl implements ProctorPackageService {

    private static final String XML_DECLARATION = "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>";
    private static final String PROCTOR_PKG_DEC_START = "<ProctorPackage version=\"1.0\">";
    private static final String PROCTOR_PKG_DEC_END = "</ProctorPackage>";
    private static final String PROCTOR_DEC_START = "<Proctor>";
    private static final String PROCTOR_DEC_END = "</Proctor>";

    @Resource(name = "reflectionConverter")
    private Converter reflectionConverter;

    @Autowired
    private XStream xstream;

    @Autowired
    private EligibilityService eligibilityService;

    @Autowired
    private Sb11TimeZoneBuilder sb11TimeZoneBuilder;

    @Autowired
    private Sb11EntityRepositoryService sb11EntityService;

    @Autowired
    private TenancyService tenancyService;

    @Resource(name = "userDetailService")
    private TestRegUserDetailsService testRegUserDetailsService;
    
    @Autowired
    private ConversionService conversionService;
    
    @Autowired
    private ParentTreeFinderService parentTreeFinder;
    

    @Override
    public String exportProctorPackage(String entityLevel, String entityName, String stateAbbreviation,
            DateTime beginTime) {


        List<? extends Sb11Entity> entities = sb11EntityService.findAllByEntityId(entityName,
                convertHierarchyLevelToClass(HierarchyLevel.valueOf(entityLevel)));

        Sb11Entity entity = null;

        if (entities.size() > 1) {
            // TODO Read on to rest of comment
            // Please change this to validate that the state passed in is a state that is valid according to the current
            // user's
            // roles. The TestRegUserDetailsService can help out here

            if (stateAbbreviation == null) {
                // cannot disambiguate, so entity = null
                entity = null;
            } else {

                entity = sb11EntityService.findByEntityIdAndStateAbbreviation(entityName, stateAbbreviation,
                        convertHierarchyLevelToClass(HierarchyLevel.valueOf(entityLevel)));
            }

        } else if (entities.size() == 1) {
            entity = entities.get(0);
        } else {
            entity = null;
        }


        List<String> tenantIdsForAssessment = new ArrayList<String>();
        Set<SbacEntity> possibleTenants = getParentTree(entity);

        if (possibleTenants.size() > 0) {

            List<Tenant> tenantsForAssessment = tenancyService.getApplicableTenants(possibleTenants);

            for (Tenant tenant : tenantsForAssessment) {
                tenantIdsForAssessment.add(tenant.getId());
            }
        }

        return new StringWriter().append(XML_DECLARATION).append(PROCTOR_PKG_DEC_START).append(PROCTOR_DEC_START)
                .append(doExportProctorPackage(tenantIdsForAssessment, beginTime)).append(PROCTOR_DEC_END)
                .append(PROCTOR_PKG_DEC_END).toString();
    }

    private String doExportProctorPackage(List<String> tenantIds, final DateTime beginTime) {
        xstream.processAnnotations(Assessment.class);
        xstream.registerConverter(new Converter() {

            @Override
            public boolean canConvert(@SuppressWarnings("rawtypes") Class type) {
                return type.equals(Assessment.class);
            }

            @Override
            public void marshal(Object source, HierarchicalStreamWriter writer, MarshallingContext context) {
                Assessment assessment = (Assessment) source;
                for (TestWindow testWindow : assessment.getTestWindow()) {
                    reflectionConverter.marshal(assessment, writer, context);
                    reflectionConverter.marshal(testWindow, writer, context);
                }
            }

            @Override
            public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {
                throw new UnsupportedOperationException("Not Supported");
            }

        });
        xstream.alias("Tests", Set.class);
        return xstream.toXML(eligibilityService.findAllAssessmentsByTenantsAndBeginWindow(tenantIds,
                beginTime.withZone(sb11TimeZoneBuilder.getDateTimeZone()))); // Use Configured TZ for TestWindows
    }

    private TenantType convertHierarchyLevelToTenantType(HierarchyLevel level) {
       return conversionService.convert(level, TenantType.class);
    }

    private Class<? extends Sb11Entity> convertHierarchyLevelToClass(HierarchyLevel level) {
       return level.getEntityClass();
    }
    
    private Set<SbacEntity> getParentTree(Sb11Entity sb11Entity) {
        Set<SbacEntity> sbacEntitySet = Sets.newHashSet();
        
        for(Map.Entry<HierarchyLevel, String> hierarchyLevelNameEntry: parentTreeFinder.getParentTree(sb11Entity).entrySet()) {
            sbacEntitySet.add(new SbacEntity(convertHierarchyLevelToTenantType(hierarchyLevelNameEntry.getKey()), hierarchyLevelNameEntry.getValue(), "nothing"));
        }
        
        return sbacEntitySet;
    }
}
