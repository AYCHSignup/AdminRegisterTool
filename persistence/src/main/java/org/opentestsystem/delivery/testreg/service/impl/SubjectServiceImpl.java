/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.delivery.testreg.service.impl;

import java.util.Collections;
import java.util.List;
import java.util.Map;

import javax.annotation.Resource;

import org.opentestsystem.delivery.testreg.domain.ARTHelpers;
import org.opentestsystem.delivery.testreg.domain.AccFamilySubject;
import org.opentestsystem.delivery.testreg.domain.MasterResourceAccommodation;
import org.opentestsystem.delivery.testreg.domain.ResourceFamily;
import org.opentestsystem.delivery.testreg.domain.Subject;
import org.opentestsystem.delivery.testreg.domain.search.SubjectSearchRequest;
import org.opentestsystem.delivery.testreg.persistence.SubjectRepository;
import org.opentestsystem.delivery.testreg.persistence.criteria.OrderComparator;
import org.opentestsystem.delivery.testreg.service.MasterResourceAccommodationService;
import org.opentestsystem.delivery.testreg.service.ResourceFamilyService;
import org.opentestsystem.delivery.testreg.service.SubjectService;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.Cache;
import org.springframework.cache.Cache.ValueWrapper;
import org.springframework.cache.CacheManager;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.stereotype.Service;

import com.google.common.base.Function;
import com.google.common.collect.FluentIterable;

@Service
public class SubjectServiceImpl implements SubjectService {

    @Autowired
    private SubjectRepository subjectRepository;
    
    @Resource
    private CacheManager cacheManager;
    
    @Resource(name = "gradeLevel")
    private Map<String, String> gradeLevel;
    
    @Autowired
    private MasterResourceAccommodationService masterResourceAccommodationService;
    
    @Autowired
    private ResourceFamilyService resourceFamilyService;

    @Override
    public Subject getSubject(String subjectId) {
        return subjectRepository.findOne(subjectId);
    }

    @Override
    public Subject saveSubject(Subject subject) {
        try {
          final Cache accommodationToCache = cacheManager.getCache("accommodationCache");
          List<MasterResourceAccommodation> accommodationResource = masterResourceAccommodationService.findAll ();
          if(accommodationToCache != null){
            Collections.sort(accommodationResource, new OrderComparator());
            if(subject.getCode () != null){
              for(String grade : gradeLevel.values ()){
                ValueWrapper cacheGet = accommodationToCache.get (ARTHelpers.generateKey(grade,subject.getCode ()));
                if(cacheGet == null)
                accommodationToCache.put (ARTHelpers.generateKey(grade,subject.getCode ()), accommodationResource);
              }
            }
          }
          return subjectRepository.save(subject);
        } catch (DuplicateKeyException dke) {
            throw new LocalizedException("subject.already.exists", new String[] {subject.getCode()});
        }
    }

    @Override
    public void removeSubject(String subjectId) {
        resolveDependency(subjectId);
        subjectRepository.delete(subjectId);
    }

    @Override
    public SearchResponse<Subject> searchSubjects(SubjectSearchRequest searchRequest) {
        return subjectRepository.search(searchRequest);
    }

    @Override
    public List<Subject> findAll() {
        return subjectRepository.findAll();
    }

    public List<String>  getAllSubjectCodes() {
        List<Subject>  subjects = this.findAll();
            
        return FluentIterable.from(subjects).transform(new Function<Subject, String>() {
            @Override
            public String apply(Subject input) {
                return input.getCode();
            }
        }).toList();
    }
    
    /**
    * @param subjectId
    */
   private void resolveDependency (String subjectId) {
   //update resource family
     Subject subjectDb = this.getSubject(subjectId);
     if(subjectDb != null){
       List<ResourceFamily> resourceFamily = resourceFamilyService.findBySubject (subjectDb.getCode());
       if(resourceFamily != null){
         for(ResourceFamily rf : resourceFamily){
           List<AccFamilySubject> subjects = rf.getSubject ();
           for(int i=0; i< subjects.size ();i++){
             AccFamilySubject sub = subjects.get(i);
             if(sub.getCode ().equalsIgnoreCase (subjectDb.getCode())){
               subjects.remove (i);
             }  
           }
           if(subjects.isEmpty ()){
             resourceFamilyService.removeResourceFamily (rf.getId ());
           }else{
           rf.setSubject (subjects);
           resourceFamilyService.saveResourceFamily (rf);
           }
         }
       }
       //update cache after removing subject
       final Cache accommodationToCache = cacheManager.getCache("accommodationCache");
       if(accommodationToCache != null && subjectDb.getCode() != null){
         for(String grade : gradeLevel.values ()){
           ValueWrapper cacheGet = accommodationToCache.get(ARTHelpers.generateKey(grade,subjectDb.getCode()));
           if (cacheGet != null) {
             accommodationToCache.evict (ARTHelpers.generateKey(grade,subjectDb.getCode()));
           }
         }
       }
     }
   }
}
