/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2016 Regents of the University of California
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 *
 * SmarterApp Open Source Assessment Software Project: http://smarterapp.org
 * Developed by Fairway Technologies, Inc. (http://fairwaytech.com)
 * for the Smarter Balanced Assessment Consortium (http://smarterbalanced.org)
 ******************************************************************************/

package org.opentestsystem.delivery.testreg.service.impl;

import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.Sb11Entity;
import org.opentestsystem.delivery.testreg.domain.Sb11SuperEntity;
import org.opentestsystem.delivery.testreg.domain.search.*;
import org.opentestsystem.delivery.testreg.service.Sb11EntityLocatorService;
import org.opentestsystem.delivery.testreg.service.Sb11EntityRepositoryService;
import org.opentestsystem.delivery.testreg.service.TestRegPersister;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Service
public class Sb11EntityLocatorServiceImpl implements Sb11EntityLocatorService {

    @Autowired
    public Sb11EntityLocatorServiceImpl(TestRegPersister testRegPersister, Sb11EntityRepositoryService entityService) {
        this.testRegPersister = testRegPersister;
        this.entityService = entityService;
    }

    private TestRegPersister testRegPersister;
    private Sb11EntityRepositoryService entityService;

    @Override
    public List<Sb11Entity> findEntities(final Map<String, String[]> parameters, final FormatType formatType) {
        List<Sb11Entity> entityList = null;
        if (parameters != null) {
            AbstractTestRegEntitySearchRequest searchRequest = getSearchRequest(parameters, formatType);
            SearchResponse<Sb11Entity> searchResponse = testRegPersister.searchDomainObjects(searchRequest, formatType);
            entityList = searchResponse.getSearchResults();
        }
        return entityList;
    }

    @Override
    public List<Sb11Entity> findParentEntities(final Map<String, String[]> parameters, final FormatType formatType) {
        List<Sb11Entity> entityList = findEntities(parameters, formatType);
        Map<String, Sb11Entity> parentEntityMap = new HashMap<>();
        for (Sb11Entity sb11Entity : entityList) {
            Sb11Entity parentEntity = null;
            if (Sb11SuperEntity.class.isAssignableFrom(sb11Entity.getParentEntityType().getEntityClass())) {
                parentEntity = entityService.findByEntityId(sb11Entity.getParentEntityId(),
                        (Class<Sb11SuperEntity>) sb11Entity.getParentEntityType().getEntityClass());
            } else {
                String stateAbbreviation = sb11Entity.getStateAbbreviation();
                parentEntity = entityService.findByEntityIdAndStateAbbreviation(sb11Entity.getParentEntityId(),
                        stateAbbreviation, sb11Entity.getParentEntityType().getEntityClass());
            }
            if (parentEntity != null) {
                parentEntityMap.put(parentEntity.getId(), parentEntity);
            }
        }
        return new ArrayList<>(parentEntityMap.values());
    }

    private AbstractTestRegEntitySearchRequest getSearchRequest(final Map<String, String[]> parameters
            , final FormatType formatType) {
        if (formatType == FormatType.GROUPOFSTATES) {
            return new GroupOfStatesEntitySearchRequest(parameters);
        } else if (formatType == FormatType.STATE) {
            return new StateEntitySearchRequest(parameters);
        } else if (formatType == FormatType.GROUPOFDISTRICTS) {
            return new GroupOfDistrictsEntitySearchRequest(parameters);
        } else if (formatType == FormatType.DISTRICT) {
            return new DistrictEntitySearchRequest(parameters);
        } else if (formatType == FormatType.GROUPOFINSTITUTIONS) {
            return new GroupOfInstitutionsEntitySearchRequest(parameters);
        } else if (formatType == FormatType.INSTITUTION) {
            return new InstitutionEntitySearchRequest(parameters);
        } else {
            throw new RuntimeException("Could not construct search request! Invalid FormatType: " + formatType);
        }
    }
}
