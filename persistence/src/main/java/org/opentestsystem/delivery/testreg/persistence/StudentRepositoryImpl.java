/*
Educational Online Test Delivery System Copyright (c) 2013 American Institutes for Research

Distributed under the AIR Open Source License, Version 1.0 See accompanying file AIR-License-1_0.txt or at
http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 */

package org.opentestsystem.delivery.testreg.persistence;

import org.bson.types.ObjectId;
import org.opentestsystem.delivery.testreg.domain.HierarchyLevel;
import org.opentestsystem.delivery.testreg.domain.Student;
import org.opentestsystem.delivery.testreg.domain.search.StudentSearchRequest;
import org.opentestsystem.shared.search.domain.AbstractSearchRequest;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Direction;
import org.springframework.data.domain.Sort.Order;
import org.springframework.data.mongodb.core.MongoOperations;
import org.springframework.data.mongodb.core.query.Query;

import java.util.ArrayList;
import java.util.List;

import static org.springframework.data.mongodb.core.query.Criteria.where;

public class StudentRepositoryImpl implements StudentRepositoryCustom {

    private static final int MAX_QUERY_LIMIT_FOR_PAGING = 1001;

    @Autowired
    private MongoOperations mongoOperations;

    @Override
    public List<Student> findAllByRangeAndLimitWithInstitutionFilter(final String mongoId, final int pageSize, final List<String> institutionMongoIdList) {

        final Query query = new Query();
        query.addCriteria(
                where("_id").gt(new ObjectId(mongoId)).and("institutionEntityMongoId").in(institutionMongoIdList))
                .with(new Sort("_id")).limit(pageSize);

        return this.mongoOperations.find(query, Student.class);
    }

    @Override
    public long getStudentCount(final String institutionId) {

        final Query query = new Query();

        query.addCriteria(where("institutionEntityMongoId").is(institutionId));

        return this.mongoOperations.count(query, Student.class);

    }

    @Override
    public List<Student> findStudentsByInstitutions(final List<String> institutionMongoIdList) {

        final Query query = new Query();

        query.addCriteria(where("institutionEntityMongoId").in(institutionMongoIdList));

        return this.mongoOperations.find(query, Student.class);

    }

    @Override
    public List<Student> findStudentsByInstitution(final String institutionMongoId) {

        final Query query = new Query();

        query.addCriteria(where("institutionEntityMongoId").is(institutionMongoId));

        return this.mongoOperations.find(query, Student.class);

    }

    @Override
    public List<Student> findStudentsByDistrict(final String districtMongoId) {

        final Query query = new Query();

        query.addCriteria(where("districtEntityMongoId").is(districtMongoId));

        return this.mongoOperations.find(query, Student.class);

    }

    @Override
    public List<Student> findStudentsByState(final String stateAbbreviation) {

        final Query query = new Query();

        query.addCriteria(where("stateAbbreviation").is(stateAbbreviation));

        return this.mongoOperations.find(query, Student.class);

    }

    @Override
    public long countByInstitutionFilter(final List<String> institutionMongoIds) {
        final Query query = new Query();

        query.addCriteria(where("institutionEntityMongoId").in(institutionMongoIds));

        return this.mongoOperations.count(query, Student.class);
    }

    @Override
    public void updateEntityForStudentsByEntityFilter(final String oldEntityId, final String newEntityId, final HierarchyLevel hierarchyLevel) {
        Sb11NonEntityUpdateHelper.updateEntityForStudentGroupsByEntityFilter(oldEntityId, newEntityId, hierarchyLevel, this.mongoOperations, Student.class);
    }

    /**
     * Executes a paginated student search.
     *
     * @param abstractSearchRequest
     * @return
     */
    @Override
    public SearchResponse<Student> search(	AbstractSearchRequest abstractSearchRequest) {
        StudentSearchRequest studentSearchRequest = (StudentSearchRequest) abstractSearchRequest;
        boolean isLastPageSearch = ((StudentSearchRequest) abstractSearchRequest).isLastPageSearch();
        // If this is a student export - we do not want to limit the query
        boolean isExportSearch = ((StudentSearchRequest) abstractSearchRequest).isExportSearch();
        final Sort sort = new Sort(getSortOrders(abstractSearchRequest));
        long totalCountWithPagination;
        Query query = abstractSearchRequest.buildQuery();
        List<Student> students;

        if (isExportSearch) {
            students = mongoOperations.find(query, Student.class);
            totalCountWithPagination = students.size();
        } else if (isLastPageSearch) {
            long totalCount = mongoOperations.count(query, Student.class);
            long lastPage = getLastPage(abstractSearchRequest, totalCount);
            students = mongoOperations.find(query.with(
                new PageRequest((int) lastPage, abstractSearchRequest.getPageSize(), sort)), Student.class);
            totalCountWithPagination = students.size() + lastPage * abstractSearchRequest.getPageSize();
        } else {
            query = query.with (
                new PageRequest(abstractSearchRequest.getCurrentPage (), MAX_QUERY_LIMIT_FOR_PAGING, sort));
            // Re-adjust the skip value
            query.skip(abstractSearchRequest.getPageSize() * (abstractSearchRequest.getCurrentPage()));
            students = mongoOperations.find(query, Student.class);
            totalCountWithPagination = students.size() + abstractSearchRequest.getCurrentPage() * abstractSearchRequest.getPageSize();
        }

        SearchResponse response = (students.size() < abstractSearchRequest.getPageSize()) ?
            new SearchResponse<>(students, abstractSearchRequest, totalCountWithPagination) :
            new SearchResponse<>(students.subList(0, abstractSearchRequest.getPageSize()), abstractSearchRequest, totalCountWithPagination);

        return response;
    }

    /**
     * Retrieves the last page based on the page size and total search result count.
     *
     * @param abstractSearchRequest
     * @param totalCount
     * @return
     */
    private List<Order> getSortOrders(AbstractSearchRequest abstractSearchRequest) {
        final List<Order> orders = new ArrayList<>();
        String[] sortKeys = abstractSearchRequest.getSortKeys ();
        Direction[] sortDirections = abstractSearchRequest.getSortDirections ();
        if (sortKeys != null) {
            for (int i = 0; i < sortKeys.length; i++) {
                Direction sortDir = null;
                final String key = sortKeys[i];
                if (sortDirections.length >= i + 1) {
                    sortDir = sortDirections[i];
                }
                final Order order = new Order(sortDir, key);
                orders.add(order);
            }
        }
        return orders;
    }

    private long getLastPage(final AbstractSearchRequest abstractSearchRequest, final long totalCount) {
        long modVal = totalCount % abstractSearchRequest.getPageSize();
        long lastPage;
        if (modVal == 0){
            lastPage = (totalCount / abstractSearchRequest.getPageSize()) - 1;
        } else{
            lastPage = totalCount / abstractSearchRequest.getPageSize();
        }
        return lastPage;
    }
}
