/*
Educational Online Test Delivery System Copyright (c) 2013 American Institutes for Research

Distributed under the AIR Open Source License, Version 1.0 See accompanying file AIR-License-1_0.txt or at
http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 */

package org.opentestsystem.delivery.testreg.transformer;

import java.util.List;

import org.joda.time.DateTime;
import org.opentestsystem.delivery.testreg.domain.ClientEntity;
import org.opentestsystem.delivery.testreg.domain.MnaAlertType;
import org.opentestsystem.delivery.testreg.domain.warehouse.DwCallbackObject;
import org.opentestsystem.delivery.testreg.domain.warehouse.DwExtract;
import org.opentestsystem.delivery.testreg.persistence.DwExtractRepository;
import org.opentestsystem.delivery.testreg.service.TestRegPersister;
import org.opentestsystem.shared.mna.client.domain.MnaSeverity;
import org.opentestsystem.shared.mna.client.service.AlertBeacon;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.integration.annotation.Header;
import org.springframework.integration.annotation.ServiceActivator;
import org.springframework.stereotype.Component;

@Component
public class DwBatchHandler {

    private static final Logger LOGGER = LoggerFactory.getLogger(DwBatchHandler.class);

    public static final String DW_CSV_TMP_PREFIX = "dw_csv_tmp_";
    public static final String DW_JSON_TMP_PREFIX = "dw_json_tmp_";
    public static final String DW_TAR_TMP_PREFIX = "dw_tar_tmp_";
    public static final String DW_COMPRESS_TMP_PREFIX = "dw_compress_tmp_";
    public static final String DW_ENC_TMP_PREFIX = "dw_enc_tmp_";

    public static final String SBAC_DW_NAME = "sbac-";
    public static final String LOCAL_DW_NAME = "local-";

    @Autowired
    private DwExtractRepository dwExtractRepository;

    @Autowired
    private AlertBeacon alertBeacon;

    @Autowired
    private TestRegPersister persister;

    @ServiceActivator(inputChannel = "dataWarehouseOutput")
    public void persistBatch(final @Header("dwBatchUuid") String dwBatchUuid,
            final @Header("recordsSent") int recordsSent) {

        DwExtract extractBean = new DwExtract();
        extractBean.setExtractCreated(new DateTime());
        extractBean.setExtractId(dwBatchUuid);
        extractBean.setExtractStatus("SENT");
        extractBean.setRecordsSent(recordsSent);

        dwExtractRepository.save(extractBean);

    }

    public void handleCallback(final DwCallbackObject callbackObject) {

        String message = "";

        DwExtract extract = dwExtractRepository.findByExtractId(callbackObject.getId());

        if (extract == null) {
            message = "DW Batch Handler could not find existing record for batch: " + callbackObject.toString();

            LOGGER.error(message);
            sendMnaAlert(message, true);

            extract = new DwExtract();
            extract.setExtractId(callbackObject.getId());
            extract.setExtractStatus("RESPONSEWITHNOBATCH");
        } else {
            String systemId = null;

            List<ClientEntity> clientEntities = persister.findAll(ClientEntity.FORMAT_TYPE);
            if (clientEntities != null && !clientEntities.isEmpty()) {
                message = "No Test Reg System Id configured, cannot verify callback: " + callbackObject.toString();

                ClientEntity clientEntity = clientEntities.get(0);

                systemId = clientEntity != null ? clientEntity.getSystemId() : null;

                if (systemId == null || systemId.trim().isEmpty()) {
                    // it's an error if there is no system id set
                    LOGGER.error(message);
                    sendMnaAlert(message, true);

                    extract.setExtractStatus("NOSYSTEMID");
                } else {
                    // check to see if the system id matches the system id in the callback object
                    message = "System id does not match Test Reg System Id from callback object: systemId: " + systemId
                            + ", callback: " + callbackObject.toString();

                    if (!systemId.equals(callbackObject.getTestRegistrationId())) {
                        LOGGER.error(message);
                        sendMnaAlert(message, true);

                        extract.setExtractStatus("SYSTEMIDNOMATCH");
                    }
                }

            } else {

                message = "No Test Reg System Id configured, cannot verify callback: " + callbackObject.toString();

                LOGGER.error(message);
                sendMnaAlert(message, true);

                extract.setExtractStatus("NOSYSTEMID");
            }

            if (!"NOSYSTEMID".equals(extract.getExtractStatus())
                    && !"SYSTEMIDNOMATCH".equals(extract.getExtractStatus())) {
                if (!"SENT".equals(extract.getExtractStatus())) {
                    message = "DW Batch Handler found unexpected batch status of " + extract.getExtractStatus()
                            + " for batch: " + callbackObject.toString();

                    LOGGER.error(message);
                    sendMnaAlert(message, true);

                    extract.setExtractStatus("INVALIDPREVSTATUSOF" + extract.getExtractStatus());
                } else {
                    // success or fail?
                    if ("Failed".equals(callbackObject.getStatus())) {
                        message = "DW Batch Handler received a failure message for batch: " + callbackObject.toString();

                        LOGGER.error(message);
                        sendMnaAlert(message, true);

                        extract.setExtractStatus("FAILED");
                    } else {
                        message = "DW Batch Handler received a success for batch id: " + callbackObject.toString();
                        LOGGER.debug(message);
                        // check processed rows

                        if (extract.getRecordsSent() == callbackObject.getRowCount()) {
                            extract.setExtractStatus("SUCCESS");
                            sendMnaAlert(message, false);
                        } else {
                            extract.setExtractStatus("SUCCESSRECORDCOUNTMISMATCH");
                            sendMnaAlert("Record Count mismatch. " + message, false);
                        }
                    }

                }
            }
        }

        extract.setErrorMessages(callbackObject.getMessage());
        extract.setExtractProcessed(new DateTime());
        extract.setRecordsProcessed(callbackObject.getRowCount());

        dwExtractRepository.save(extract);

    }

    private void sendMnaAlert(final String message, boolean error) {
        alertBeacon.sendAlert(error ? MnaSeverity.ERROR : MnaSeverity.INFO, MnaAlertType.DATAWAREHOUSE_CALLBACK.name(),
                message);
    }

}
