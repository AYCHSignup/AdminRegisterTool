/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/

package org.opentestsystem.delivery.testreg.xstream.converters;

import static org.opentestsystem.delivery.testreg.domain.HierarchyLevel.DISTRICT;
import static org.opentestsystem.delivery.testreg.domain.HierarchyLevel.GROUPOFDISTRICTS;
import static org.opentestsystem.delivery.testreg.domain.HierarchyLevel.GROUPOFINSTITUTIONS;
import static org.opentestsystem.delivery.testreg.domain.HierarchyLevel.INSTITUTION;
import static org.opentestsystem.delivery.testreg.domain.HierarchyLevel.STATE;

import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.GroupOfDistrictsEntity;
import org.opentestsystem.delivery.testreg.domain.GroupOfInstitutionsEntity;
import org.opentestsystem.delivery.testreg.domain.HierarchyLevel;
import org.opentestsystem.delivery.testreg.domain.Sb11Entity;
import org.opentestsystem.delivery.testreg.domain.Sb11SuperEntity;
import org.opentestsystem.delivery.testreg.domain.Student;
import org.opentestsystem.delivery.testreg.service.Sb11EntityRepositoryService;
import org.opentestsystem.delivery.testreg.service.impl.HierarchyLevelTreeWalker;

import com.thoughtworks.xstream.converters.Converter;
import com.thoughtworks.xstream.converters.MarshallingContext;
import com.thoughtworks.xstream.converters.UnmarshallingContext;
import com.thoughtworks.xstream.io.HierarchicalStreamReader;
import com.thoughtworks.xstream.io.HierarchicalStreamWriter;

public abstract class StudentConverter implements Converter, WriterCallback {

    private final Converter converter;
    private final Sb11EntityRepositoryService sb11EntityRepositoryService;
    private final HierarchyLevelTreeWalker hierarchyLevelTreeWalker;
    


    public StudentConverter(final Converter converter, final Sb11EntityRepositoryService sb11EntityRepositoryService) {
        this.converter = converter;
        this.sb11EntityRepositoryService = sb11EntityRepositoryService;
        this.hierarchyLevelTreeWalker = new HierarchyLevelTreeWalker(sb11EntityRepositoryService);
    }

    @Override
    public boolean canConvert(@SuppressWarnings("rawtypes") final Class type) {
        return type.equals(Student.class);
    }

    @Override
    public Object unmarshal(final HierarchicalStreamReader reader, final UnmarshallingContext context) {
        return null;
    }

    @Override
    public void marshal(final Object source, final HierarchicalStreamWriter writer, final MarshallingContext context) {
        Student student = (Student)source;

        //1. Marshall State
        doMarshal(getEntity(student, STATE), writer, context);


        //2. Marshall GroupOfDistrict
        Sb11Entity district = getEntity(student, DISTRICT);
        doMarshal(getGroupOfDistrict(district), writer, context);


        //3. Marshall District
        doMarshal(getEntity(student, DISTRICT), writer, context);


        //4. Marshall Institution Parent - Only GOI & GOS (going through Hierarchy)
        Sb11Entity institution = getEntity(student, INSTITUTION);
        doMarshal(getGroupofInstitution(institution), writer, context);
        Sb11Entity gos = getGroupOfStates(institution);
        if(gos !=null) {
            doMarshal(gos, writer, context);
        }

        //5. Marshall Institution
        doMarshal(institution, writer, context);


        //6. Finally marshall rest of student information
        doMarshal(student, writer, context); //Convert Student
        writeCallback(student, writer, context); //Now invoke callback so client can decide to handle how rest of the tree needed to be built
    }

    private Sb11Entity getEmpty(final Class<? extends Sb11Entity> sb11EntityClass) {
        try {
            return sb11EntityClass.newInstance();
        }
        catch (InstantiationException | IllegalAccessException e) {
            throw new RuntimeException("Unable to Instantiate Sb11Entity"+ sb11EntityClass.getName() + " using default constructor");
        }
    }

    private void doMarshal(final Object source, final HierarchicalStreamWriter writer, final MarshallingContext context){
        converter.marshal(source, writer, context);
    }

    private Sb11Entity getEntity(final Student student, final HierarchyLevel level) {
        String stateAbbreviation = student.getStateAbbreviation();
        Sb11Entity ret = null;
        switch(level) {
            case INSTITUTION:
                ret =  findEntity(student.getInstitutionIdentifier(), stateAbbreviation, level);
                break;
            case DISTRICT:
                ret = findEntity(student.getDistrictIdentifier(), stateAbbreviation, level);
                break;
            case STATE:
                ret = findEntity(student.getStateAbbreviation(), null, level);
                break;
            default:
                throw new RuntimeException("Not a Supported Hierarchy");
        }
        return ret == null ? getEmpty(level.getEntityClass()) : ret;
    }

    private Sb11Entity getGroupofInstitution(final Sb11Entity institution) {
        switch(institution.getParentEntityType()) {
            case GROUPOFINSTITUTIONS:
                return findEntity(institution.getEntityId(), institution.getStateAbbreviation(), GROUPOFINSTITUTIONS);
            default:
                return getEmpty(GroupOfInstitutionsEntity.class);
        }
    }
    
    private Sb11Entity getGroupOfStates(final Sb11Entity institution) {
        Sb11Entity gos = hierarchyLevelTreeWalker.getGOS(institution);
        if(gos !=null && gos.getFormatType() == FormatType.GROUPOFSTATES) {
            return gos;
        }
        return null;
    }

    private Sb11Entity getGroupOfDistrict(final Sb11Entity district) {
        Sb11Entity ret = getEmpty(GroupOfDistrictsEntity.class);
        if (district != null && district.getParentEntityType() != null) {
            switch(district.getParentEntityType()) {
            case GROUPOFDISTRICTS:
                Sb11Entity sb11Entity = findEntity(district.getEntityId(), district.getStateAbbreviation(), GROUPOFDISTRICTS);
                ret = sb11Entity == null ? ret : sb11Entity;
            default:
                break;
            }
        }
        return ret;
    }

    @SuppressWarnings("unchecked")
    private Sb11Entity findEntity(final String entityId, final String stateAbbreviation, final HierarchyLevel level) {
        if(isASuperEntity(level)) {
            return sb11EntityRepositoryService.findByEntityId(entityId, (Class<Sb11SuperEntity>) level.getEntityClass());
        }
        
        if(stateAbbreviation !=null && stateAbbreviation.length()>0) {
            return sb11EntityRepositoryService.findByEntityIdAndStateAbbreviation(entityId, stateAbbreviation, level.getEntityClass());
        } else {
            throw new RuntimeException("Unable to find Sb11Entity (no state abbrev. specified): " + entityId + ", " + level.name());
        }
    }
    
    private boolean isASuperEntity(final HierarchyLevel level) {
        return Sb11SuperEntity.class.isAssignableFrom(level.getEntityClass());
    }
}
