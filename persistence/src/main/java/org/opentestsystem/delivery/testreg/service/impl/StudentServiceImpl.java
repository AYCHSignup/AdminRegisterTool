/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/

package org.opentestsystem.delivery.testreg.service.impl;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.annotation.Resource;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.delivery.testadmin.service.TestStatusService;
import org.opentestsystem.delivery.testreg.domain.HierarchyLevel;
import org.opentestsystem.delivery.testreg.domain.Sb11Entity;
import org.opentestsystem.delivery.testreg.domain.Student;
import org.opentestsystem.delivery.testreg.persistence.StudentRepository;
import org.opentestsystem.delivery.testreg.service.AccommodationCacheService;
import org.opentestsystem.delivery.testreg.service.EligibilityService;
import org.opentestsystem.delivery.testreg.service.MasterResourceAccommodationService;
import org.opentestsystem.delivery.testreg.service.Sb11EntityRepositoryService;
import org.opentestsystem.delivery.testreg.service.StudentService;
import org.opentestsystem.shared.exception.LocalizedException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

@Service("studentService")
public class StudentServiceImpl<T extends Student> extends Sb11NonEntityServiceImpl<T> implements StudentService {

    @Autowired
    private StudentRepository studentRepository;

    @Resource(name = "sb11EntityService")
    private Sb11EntityRepositoryService sb11EntityService;

    @Autowired
    private TestStatusService testStatusService;
    
    @Autowired
    private EligibilityService eligibilityService;
    
    @Autowired
    MasterResourceAccommodationService masterResourceAccommodationService;
    
    @Autowired
    private AccommodationCacheService accommodationCacheService;
    
    @Override
    public Student findByStudentIdAndStateAbbreviation(final String studentId, final String stateAbbreviation) {
        return this.studentRepository.findByEntityIdAndStateAbbreviation(studentId, stateAbbreviation);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public T saveDomainObject(final T domainObj) {
        setAssociations(domainObj);
        Object[] accommodations = domainObj.getAccommodations ();
        if (accommodations != null && accommodations.length > 0) {
          for (int i = 0; i < accommodations.length; i++) {
            Map<String, Object> accommodation = (Map<String, Object>) accommodations[i];
            Map<String, Object> accommoMap = setDefaultAccommodations (accommodation, domainObj.getGrade ());
            accommodations[i] = accommoMap;
          }
        }
        
        return super.saveDomainObject(domainObj);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<T> updateDomainObjects(final List<T> domainObjList) {
        setParentEntityMongoId(domainObjList);
        return super.updateDomainObjects(domainObjList);
    }
    
    @Override
    public void deleteDomainObjects(final List<T> domainObjList) {
        if (!CollectionUtils.isEmpty(domainObjList)) {
            for (final T domainObj : domainObjList) {
                deleteDomainObject(domainObj);
            }
        }
    }

    @Override
    public void deleteDomainObject(final T domainObj) {
      final Student existingObject = this.studentRepository.findByEntityIdAndStateAbbreviation(domainObj.getEntityId (), domainObj.getStateAbbreviation ());
        if (existingObject == null) {
            throw createObjectNotFoundException(domainObj.getAlternateKey());
        } else {
            domainObj.setId(existingObject.getId());
            testStatusService.deleteTestStatus (existingObject.getEntityId (),existingObject.getStateAbbreviation ());
            this.studentRepository.delete (domainObj);
            
        }
    }
    
    
    private void setParentEntityMongoId(final List<T> students) {
        for (final Student student : students) {
            setAssociations(student);
        }
    }

    private void setAssociations(final Student student) {
        // get and set institution mongo id
        if (StringUtils.isNotBlank(student.getInstitutionIdentifier())) {
            final Sb11Entity institutionEntity = findSb11EntityByEntityIdAndStateAbbreviation(student.getInstitutionIdentifier(), student.getStateAbbreviation(), HierarchyLevel.INSTITUTION);
            if (institutionEntity != null) {
                student.setInstitutionEntityMongoId(institutionEntity.getId());
                if (StringUtils.isBlank(student.getDistrictIdentifier()) && institutionEntity.getParentEntityType() == HierarchyLevel.DISTRICT) {
                    student.setDistrictIdentifier(institutionEntity.getParentEntityId());
                }
            }
        }

        // get and set district mongo id
        if (StringUtils.isNotBlank(student.getDistrictIdentifier())) {
            final Sb11Entity districtEntity = findSb11EntityByEntityIdAndStateAbbreviation(student.getDistrictIdentifier(), student.getStateAbbreviation(), HierarchyLevel.DISTRICT);
            if (districtEntity != null) {
                student.setDistrictEntityMongoId(districtEntity.getId());
            }
        } else {
            student.setDistrictEntityMongoId(null);
        }

    }

 /*
	* save accommdation from file-upload into corresponding student
	*
	*	@params : studentId, stateAbbreviation and Map from file-upload
	* 
	* @return student 
	*/
    public Student saveAccommodation(String studentId, String stateAbbreviation, Map<String, Object> accommodation){
      Student student = findByStudentIdAndStateAbbreviation(studentId, stateAbbreviation);
      
      if(student != null) {
        boolean isSubjectExists = false;
        int exisitngAccomCount = 0;
        Object[] accommodations = student.getAccommodations ();
        Map<String, Object> newAcc = setDefaultAccommodations(accommodation,student.getGrade ());
        if(accommodations != null){
          exisitngAccomCount = accommodations.length;
        } 
        if(exisitngAccomCount > 0){
          for( int i=0; i< exisitngAccomCount;i++){
            Object obj = accommodations[i];
            Map<String, Object> acc = (Map<String, Object>)obj;
            if(acc.get ("subject").equals (newAcc.get ("subject"))){
              accommodations[i] = newAcc;
              isSubjectExists = true;
            }
          }
          if(!isSubjectExists){        
            ArrayList<Object> temp = new ArrayList<Object>(Arrays.asList(accommodations));
            temp.add(newAcc);
            accommodations =  temp.toArray();
          }
          student.setAccommodations (accommodations);
          studentRepository.save (student);
        }else{
          Object newAccObj = newAcc;
          Object[] accommo = new Object[] { };
          ArrayList<Object> temp = new ArrayList<Object>(Arrays.asList(accommo));
          temp.add(newAccObj);
          Object[] newObj = temp.toArray ();
          student.setAccommodations (newObj);
          studentRepository.save (student);
        }
      }
      return student;
    }
	
    // @Cacheable(value = "findSb11EntityByEntityIdAndStateAbbreviation")
    public Sb11Entity findSb11EntityByEntityIdAndStateAbbreviation(final String entityIdentifier, final String stateAbbreviation, final HierarchyLevel hierarchyLevel) {
        return this.sb11EntityService.findByEntityIdAndStateAbbreviation(entityIdentifier, stateAbbreviation, hierarchyLevel.getEntityClass());
    }

    @Override
    public Student findByExternalSsidAndStateAbbreviation(final String externalSsid, final String stateAbbreviation) {
        return this.studentRepository.findByExternalSsidAndStateAbbreviation(externalSsid, stateAbbreviation);
    }

    @Override
    public List<Student> findByInstitutionIdentifierAndStateAbbreviation(final String institutionIdentifier, final String stateId) {
        return this.studentRepository.findByInstitutionIdentifierAndStateAbbreviation(institutionIdentifier, stateId);
    }

    private LocalizedException createObjectNotFoundException(final String objectId) {
      return new LocalizedException("entity.not.found", new String[] { objectId });
    }
    
    //setting default accommodations based on subject and grade 
    private Map<String, Object> setDefaultAccommodations(Map<String, Object> accommoMap,String grade){
      List<String> headersList = masterResourceAccommodationService.getAllOptionsCodes ();
      Map<String, Object> accommodationMap = modifyAccommodation(accommoMap,headersList);
      HashMap<String, String> accDefaultOptions = accommodationCacheService.getAllDefaultOptions (accommodationMap.get ("subject").toString (), grade)  ;
      HashMap<String,String> accResourceTypes = masterResourceAccommodationService.getAllResourceTypes();
      for(int i=0;i<headersList.size ();i++){
        if(accommodationMap.get (headersList.get (i)).toString ().replaceAll ("\\[", "").replaceAll ("\\]", "").equals ("")){
          if(accDefaultOptions.containsKey (headersList.get (i))) {
            String header = headersList.get (i);
            header = header.substring (0, 1).toUpperCase ().concat (header.substring (1));
            String resourceType = accResourceTypes.get (header);
            switch(resourceType){
            case "EditResource":
            case "SingleSelectResource":
              accommodationMap.put (headersList.get (i), accDefaultOptions.get (headersList.get (i)));
              break;
            case "MultiSelectResource":
              ArrayList<String> al = new ArrayList<String>();
              al.add (accDefaultOptions.get (headersList.get (i)));
              accommodationMap.put (headersList.get (i), al);
              break;

            }
          }
        }
      }
      return accommodationMap;
    }
    
    private Map<String, Object> modifyAccommodation (Map<String, Object> map,List<String> header) {
      for(int i=0;i<header.size ();i++){
        if(map.get (header.get (i)) == null){
          map.put (header.get (i), "");
        }
      }
      return map;
    }
    
}
