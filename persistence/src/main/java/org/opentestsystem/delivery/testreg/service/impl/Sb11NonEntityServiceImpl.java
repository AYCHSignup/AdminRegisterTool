/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.delivery.testreg.service.impl;

import org.apache.commons.collections.CollectionUtils;
import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.Sb11NonEntity;
import org.opentestsystem.delivery.testreg.domain.Student;
import org.opentestsystem.delivery.testreg.domain.search.AccommodationSearchRequest;
import org.opentestsystem.delivery.testreg.domain.search.UserSearchRequest;
import org.opentestsystem.delivery.testreg.persistence.Sb11NonEntityRepository;
import org.opentestsystem.delivery.testreg.service.Sb11NonEntityRepositoryService;
import org.opentestsystem.delivery.testreg.service.TestRegistrationService;
import org.opentestsystem.delivery.testreg.service.impl.domain.AssociationCreatorInvoker;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.search.domain.AbstractSearchRequest;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import static org.opentestsystem.delivery.testreg.domain.AnnotationHelper.*;

@SuppressWarnings({ "unchecked" })
@Service("sb11NonEntityService")
public class Sb11NonEntityServiceImpl<T extends Sb11NonEntity> implements TestRegistrationService<T>,
        Sb11NonEntityRepositoryService {

    @Resource
    private Map<FormatType, Sb11NonEntityRepository<Sb11NonEntity>> nonEntityRepositoryMap;

    @Autowired
    private Sb11NonEntityRepository<Sb11NonEntity> sb11NonEntityRepository;

    @Autowired
    private AssociationCreatorInvoker assocCreatorInvoker;

    @Autowired
    private MongoTemplate mongoTemplate;

    /**
     * {@inheritDoc}
     */
    @Override
    public T findById(final String pkId, final FormatType formatType) {
        return (T) nonEntityRepositoryMap.get(formatType).findOne(pkId);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<T> findAll(final FormatType formatType) {
        if (nonEntityRepositoryMap.get(formatType) == null) {
            throw new RuntimeException("invalid or missing format type: " + formatType);
        }
        return (List<T>) nonEntityRepositoryMap.get(formatType).findAll();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public T saveDomainObject(final T domainObj) {

        try {
            T entityWithAssociations = assocCreatorInvoker.createAssociations(domainObj);

            T retObj = (T) nonEntityRepositoryMap.get(domainObj.getFormatType()).save(entityWithAssociations);

            return retObj;

        } catch (DuplicateKeyException dke) {
            throw getDuplicateKeyException(domainObj, dke);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public T updateDomainObject(final T domainObj) {

        try {
            T existingObj = (T) sb11NonEntityRepository.findByAlternateKey(domainObj.createAlternateKeySearchRequest(),
                    domainObj.getClass());

            if (existingObj != null) {
                domainObj.setId(existingObj.getId());
            }

            T retObj = (T) nonEntityRepositoryMap.get(domainObj.getFormatType()).save(domainObj);

            return retObj;

        } catch (DuplicateKeyException dke) {
            throw getDuplicateKeyException(domainObj, dke);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<T> saveDomainObjects(final List<T> domainObjList) {
        List<T> savedObjects = new ArrayList<T>();
        if (!CollectionUtils.isEmpty(domainObjList)) {
            for (T domainObj : domainObjList) {
                savedObjects.add(saveDomainObject(domainObj));
            }
        }
        return savedObjects;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<T> updateDomainObjects(final List<T> domainObjList) {
        List<T> updatedObjects = new ArrayList<T>();
        if (!CollectionUtils.isEmpty(domainObjList)) {
            for (T domainObj : domainObjList) {
                updatedObjects.add(updateDomainObject(domainObj));
            }
        }
        return updatedObjects;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void deleteDomainObject(final T domainObj) {

        T existingObject = (T) sb11NonEntityRepository.findByAlternateKey(domainObj.createAlternateKeySearchRequest(),
                domainObj.getClass());

        if (existingObject == null) {
            throw createObjectNotFoundException(domainObj.getAlternateKey());
        } else {
            domainObj.setId(existingObject.getId());
            nonEntityRepositoryMap.get(domainObj.getFormatType()).delete(domainObj);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void deleteDomainObject(final String pkId, final FormatType formatType) {

        T existingObject = (T) nonEntityRepositoryMap.get(formatType).findOne(pkId);

        if (existingObject == null) {
            throw createObjectNotFoundException(pkId);
        } else {
            nonEntityRepositoryMap.get(formatType).delete(pkId);
        }

    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void deleteDomainObjects(final List<T> domainObjList) {
        if (!CollectionUtils.isEmpty(domainObjList)) {
            for (T domainObj : domainObjList) {
                deleteDomainObject(domainObj);
            }
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public SearchResponse<T> searchDomainObjects(final AbstractSearchRequest searchRequest, final FormatType formatType) {
        if (searchRequest instanceof UserSearchRequest || searchRequest instanceof AccommodationSearchRequest) {
            ((UserSearchRequest) searchRequest).setMongoTemplate(mongoTemplate);
        }
        return (SearchResponse<T>) nonEntityRepositoryMap.get(formatType).search(searchRequest);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean hasAssociatedEntity(final T entity) {
        // This method currently supports only Sb11Entities.
        // TODO: This is the code from the sb11 service. we will probably need to add a common method to the
        // non-entity objects to return a list of the associated ids with levels so that lookups can be perfomed

        // for (HierarchyLevel level : HierarchyLevel.values()) {
        // if (level != HierarchyLevel.CLIENT
        // && level != HierarchyLevel.valueOf(entity.getFormatType().toString().toUpperCase())) {
        // Long count = sb11EntityRepository.getEntityCountByParentEntityId(entity.getEntityId(),
        // level.getEntityClass());
        // if (count != null && count > 0) {
        // return true;
        // }
        // }
        // }
        return false;
    }

    // TODO rename this
    private LocalizedException createObjectNotFoundException(final String objectId) {
        return new LocalizedException("entity.not.found", new String[] { objectId });
    }

    private LocalizedException createFormatTypeException(final FormatType type) {
        return new LocalizedException("entity.invalid.formattype", new String[] { type.toString() });
    }


    /**
     * Get duplicate key error based on entity format type.
     *
     * @param entity entity
     * @return error message
     */
    private LocalizedException getDuplicateKeyException(final T entity, DuplicateKeyException dke) {

        switch (entity.getFormatType()) {

        case ASSESSMENT:

        case EXPLICITELIGIBILITY:

        case USER:

        case STUDENTGROUP:
            String alternateKey = entity.getAlternateKey();
            return new LocalizedException("entity.already.exists", new String[] { entity.getFormatType().name(),
                    alternateKey }, dke);
        case STUDENT:
            Student student = (Student) entity;
            //duplicate exception is thrown for external ssid and state
            if (dke.getLocalizedMessage().contains("$externalSsidAndState")) {
                return new LocalizedException("student.externalssid.already.exists", new String[] { student.getStateAbbreviation() }, dke);
            } else {
                String message = entity.getAlternateKey();
                message = message.replace("entityId", getFieldLabel(entity, "entityId"));
                return new LocalizedException("entity.already.exists", new String[] { entity.getFormatType().name(),
                        message }, dke);
            }
        default:
            return createFormatTypeException(entity.getFormatType());
        }
    }

    @Override
    public <S extends Sb11NonEntity> S findByAlternateKey(final AbstractSearchRequest searchRequest,
            final Class<S> clazz) {
        return sb11NonEntityRepository.findByAlternateKey(searchRequest, clazz);
    }

}
