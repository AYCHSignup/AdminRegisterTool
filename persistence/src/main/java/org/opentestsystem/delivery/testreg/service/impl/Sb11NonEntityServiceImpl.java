/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.delivery.testreg.service.impl;

import static org.opentestsystem.delivery.testreg.domain.AnnotationHelper.getFieldLabel;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import javax.annotation.Resource;

import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.Sb11NonEntity;
import org.opentestsystem.delivery.testreg.domain.Student;
import org.opentestsystem.delivery.testreg.domain.search.AccommodationSearchRequest;
import org.opentestsystem.delivery.testreg.domain.search.UserSearchRequest;
import org.opentestsystem.delivery.testreg.persistence.Sb11NonEntityRepository;
import org.opentestsystem.delivery.testreg.service.Sb11NonEntityRepositoryService;
import org.opentestsystem.delivery.testreg.service.TestRegistrationService;
import org.opentestsystem.delivery.testreg.service.impl.domain.AssociationCreatorInvoker;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.search.domain.AbstractSearchRequest;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

@SuppressWarnings({ "unchecked" })
@Service("sb11NonEntityService")
public class Sb11NonEntityServiceImpl<T extends Sb11NonEntity> implements TestRegistrationService<T>, Sb11NonEntityRepositoryService {

    @Resource
    private Map<FormatType, Sb11NonEntityRepository<Sb11NonEntity>> nonEntityRepositoryMap;

    @Autowired
    private Sb11NonEntityRepository<Sb11NonEntity> sb11NonEntityRepository;

    @Autowired
    private AssociationCreatorInvoker assocCreatorInvoker;

    @Autowired
    private MongoTemplate mongoTemplate;

    /**
     * {@inheritDoc}
     */
    @Override
    public T findById(final String pkId, final FormatType formatType) {
        return (T) this.nonEntityRepositoryMap.get(formatType).findOne(pkId);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<T> findAll(final FormatType formatType) {
        if (this.nonEntityRepositoryMap.get(formatType) == null) {
            throw new RuntimeException("invalid or missing format type: " + formatType);
        }
        return (List<T>) this.nonEntityRepositoryMap.get(formatType).findAll();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public T saveDomainObject(final T domainObj) {
        try {
            final T entityWithAssociations = this.assocCreatorInvoker.createAssociations(domainObj);
            final T retObj = this.nonEntityRepositoryMap.get(domainObj.getFormatType()).save(entityWithAssociations);
            return retObj;
        } catch (final DuplicateKeyException dke) {
            throw getDuplicateKeyException(domainObj, dke);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<T> saveDomainObjects(final List<T> domainObjList) {
        final List<T> savedObjects = new ArrayList<>();
        if (!CollectionUtils.isEmpty(domainObjList)) {
            for (final T domainObj : domainObjList) {
                savedObjects.add(saveDomainObject(domainObj));
            }
        }
        return savedObjects;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public T updateDomainObject(final T domainObj) {
        try {
            final T existingObj = (T) this.sb11NonEntityRepository.findByAlternateKey(domainObj.createAlternateKeySearchRequest(), domainObj.getClass());
            if (existingObj != null) {
                domainObj.setId(existingObj.getId());
            }
            final T retObj = this.nonEntityRepositoryMap.get(domainObj.getFormatType()).save(domainObj);
            return retObj;
        } catch (final DuplicateKeyException dke) {
            throw getDuplicateKeyException(domainObj, dke);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<T> updateDomainObjects(final List<T> domainObjList) {
        final List<T> updatedObjects = new ArrayList<>();
        if (!CollectionUtils.isEmpty(domainObjList)) {
            try {
                for (final T domainObj : domainObjList) {
                    final T existingObj = (T) this.sb11NonEntityRepository.findByAlternateKey(domainObj.createAlternateKeySearchRequest(), domainObj.getClass());
                    if (existingObj != null) {
                        domainObj.setId(existingObj.getId());
                    }
                }
                updatedObjects.addAll(this.nonEntityRepositoryMap.get(domainObjList.get(0).getFormatType()).save(domainObjList));
            } catch (final DuplicateKeyException dke) {
                throw getDuplicateKeyException(domainObjList.get(0), dke);
            }
        }
        return updatedObjects;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void deleteDomainObject(final T domainObj) {
        final T existingObject = (T) this.sb11NonEntityRepository.findByAlternateKey(domainObj.createAlternateKeySearchRequest(), domainObj.getClass());
        if (existingObject == null) {
            throw createObjectNotFoundException(domainObj.getAlternateKey());
        } else {
            domainObj.setId(existingObject.getId());
            this.nonEntityRepositoryMap.get(domainObj.getFormatType()).delete(domainObj);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void deleteDomainObject(final String pkId, final FormatType formatType) {
        final T existingObject = (T) this.nonEntityRepositoryMap.get(formatType).findOne(pkId);
        if (existingObject == null) {
            throw createObjectNotFoundException(pkId);
        } else {
            this.nonEntityRepositoryMap.get(formatType).delete(existingObject);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void deleteDomainObjects(final List<T> domainObjList) {
        if (!CollectionUtils.isEmpty(domainObjList)) {
            for (final T domainObj : domainObjList) {
                deleteDomainObject(domainObj);
            }
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public SearchResponse<T> searchDomainObjects(final AbstractSearchRequest searchRequest, final FormatType formatType) {
        if (searchRequest instanceof UserSearchRequest || searchRequest instanceof AccommodationSearchRequest) {
            ((UserSearchRequest) searchRequest).setMongoTemplate(this.mongoTemplate);
        }
        return (SearchResponse<T>) this.nonEntityRepositoryMap.get(formatType).search(searchRequest);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean hasAssociatedEntity(final T entity) {
        return false;
    }

    private LocalizedException createObjectNotFoundException(final String objectId) {
        return new LocalizedException("entity.not.found", new String[] { objectId });
    }

    private LocalizedException createFormatTypeException(final FormatType type) {
        return new LocalizedException("entity.invalid.formattype", new String[] { type.toString() });
    }

    /**
     * Get duplicate key error based on entity format type.
     * 
     * @param entity entity
     * @return error message
     */
    private LocalizedException getDuplicateKeyException(final T entity, final DuplicateKeyException dke) {
        switch (entity.getFormatType()) {
        case ASSESSMENT:
        case EXPLICITELIGIBILITY:
        case USER:
        case STUDENTGROUP:
            final String alternateKey = entity.getAlternateKey();
            return new LocalizedException("entity.already.exists", new String[] { entity.getFormatType().name(), alternateKey }, dke);
        case STUDENT:
            final Student student = (Student) entity;
            // duplicate exception is thrown for external ssid and state
            if (dke.getLocalizedMessage().contains("$externalSsidAndState")) {
                return new LocalizedException("student.externalssid.already.exists", new String[] { student.getStateAbbreviation() }, dke);
            } else {
                String message = entity.getAlternateKey();
                message = message.replace("entityId", getFieldLabel(entity, "entityId"));
                return new LocalizedException("entity.already.exists", new String[] { entity.getFormatType().name(),
                        message }, dke);
            }
        default:
            return createFormatTypeException(entity.getFormatType());
        }
    }

    @Override
    public <S extends Sb11NonEntity> S findByAlternateKey(final AbstractSearchRequest searchRequest, final Class<S> clazz) {
        return this.sb11NonEntityRepository.findByAlternateKey(searchRequest, clazz);
    }
}
