/*
Educational Online Test Delivery System Copyright (c) 2013 American Institutes for Research

Distributed under the AIR Open Source License, Version 1.0 See accompanying file AIR-License-1_0.txt or at
http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 */

package org.opentestsystem.delivery.testreg.eligibility;

import static org.apache.commons.collections.CollectionUtils.isNotEmpty;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.beanutils.PropertyUtils;
import org.joda.time.DateTime;
import org.opentestsystem.delivery.testreg.domain.Accommodation;
import org.opentestsystem.delivery.testreg.domain.Action;
import org.opentestsystem.delivery.testreg.domain.Assessment;
import org.opentestsystem.delivery.testreg.domain.CacheMap;
import org.opentestsystem.delivery.testreg.domain.ExplicitEligibility;
import org.opentestsystem.delivery.testreg.domain.HierarchyLevel;
import org.opentestsystem.delivery.testreg.domain.ImplicitEligibilityRule;
import org.opentestsystem.delivery.testreg.domain.InstitutionEntity;
import org.opentestsystem.delivery.testreg.domain.Sb11Entity;
import org.opentestsystem.delivery.testreg.domain.Sb11SuperEntity;
import org.opentestsystem.delivery.testreg.domain.Student;
import org.opentestsystem.delivery.testreg.domain.event.AssessmentModificationEvent;
import org.opentestsystem.delivery.testreg.domain.event.ExplicitEligibilityModificationEvent;
import org.opentestsystem.delivery.testreg.domain.event.StudentModificationEvent;
import org.opentestsystem.delivery.testreg.domain.exception.EligibilityException;
import org.opentestsystem.delivery.testreg.persistence.AssessmentRepository;
import org.opentestsystem.delivery.testreg.persistence.ExplicitEligibilityRepository;
import org.opentestsystem.delivery.testreg.persistence.StudentRepository;
import org.opentestsystem.delivery.testreg.service.CacheMapService;
import org.opentestsystem.delivery.testreg.service.EligibilityService;
import org.opentestsystem.delivery.testreg.service.Sb11EntityRepositoryService;
import org.opentestsystem.shared.progman.client.ProgManClient;
import org.opentestsystem.shared.progman.client.domain.Tenant;
import org.opentestsystem.shared.progman.client.domain.TenantType;
import org.opentestsystem.shared.security.domain.SbacEntity;
import org.opentestsystem.shared.security.service.TenancyService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.integration.annotation.ServiceActivator;
import org.springframework.stereotype.Component;

import com.google.common.collect.Sets;

@Component
public class EligibilityEvaluatorImpl implements EligibilityEvaluator {

    private static final Logger LOGGER = LoggerFactory.getLogger(EligibilityEvaluatorImpl.class);

    private static final long PAGE_SIZE = 5000;

    @Autowired
    private EligibilityService eligibilityService;

    @Autowired
    private AssessmentRepository assessmentRepository;

    @Autowired
    private StudentRepository studentRepository;

    @Autowired
    private ExplicitEligibilityRepository explicitEligRepository;

    @Autowired
    private TenancyService tenancyService;

    @Autowired
    private ProgManClient progmanClient;

    @Autowired
    private Sb11EntityRepositoryService sb11EntityService;

    @Autowired
    private CacheMapService cacheMapService;

    // change this class to be EligibilityEvaluator
    // use to evaluate explicit eligibility also
    // those rules don't need to be "run", but we do need to create EligibleAssessment/EligibleStudent from them
    // and like implicit eligibility, they only count if the assessment is in one of its test windows

    // implicit eligibility rules need to be evaluated under the following circumstances:
    // - student modification (upload or UI)
    // - accommodation modification (upload or UI)
    // - rule change
    // - assessment modified (change of eligibility type)

    // if a student is inserted or modified, the student must be checked against all
    // implicit rules on all assessments marked as implicit

    // if a student is deleted, then corresponding EligibleStudent must be deleted
    // and each EligibleAssessment that includes the student must be modified to remove the student

    // if accommodations are inserted or modified treat the same as student data insert or modification

    // if accommodations are deleted treat the same as student data modification

    // if the implicit eligibility rules for an assessment are changed (any create, update, delete)
    // then each student in the system must be tested against the rules

    // if an assessment changes from implicit to explicit eligibility,
    // the corresponding EligibleAssessment must be removed
    // and each EligibleStudent that includes the assessment must be modified to remove the assessment
    // then re-evaluate explicit eligibility to see if any records exist for the assessment

    // if an assessment changes from explicit to implicit eligibility,
    // the corresponding EligibleAssessment must be removed
    // and each EligibleStudent that includes the assessment must be modified to remove the assessment
    // then each student in the system must be checked against the new implicit rules

    @Override
    public void evaluateImplicitRules(final Assessment assessment, final Student student) {
        List<ImplicitEligibilityRule> enablerRules = assessment.getEnablerRules();
        List<ImplicitEligibilityRule> disablerRules = assessment.getDisablerRules();

        boolean disabled = false;
        boolean enabled = false;

        if (isNotEmpty(disablerRules)) {
            disabled = true;
            // run disabler rules first
            for (ImplicitEligibilityRule rule : disablerRules) {
                if (!(disabled = applyRule(assessment, rule, student, rule.getField())))
                    break;
            }
        }

        if (!disabled) {
            // run enabler rules
            if (isNotEmpty(enablerRules)) {
                enabled = true;
                for (ImplicitEligibilityRule rule : enablerRules) {
                    if (!(enabled = applyRule(assessment, rule, student, rule.getField())))
                        break;
                }
            }
        }

        if (!disabled && enabled) {
            // student is eligible for the assessment, make the associations
            eligibilityService.saveAssociation(assessment, student);
        }

    }

    /**
     * This version of evaluateImplicitRules returns a list of eligible students. It does not persist the association to
     * the database.
     * 
     * @param assessment
     * @param students
     * @return
     */
    public List<Student> evaluateImplicitRules(final Assessment assessment, final List<Student> students) {

        List<Student> eligibleStudents = new ArrayList<Student>();

        List<ImplicitEligibilityRule> enablerRules = assessment.getEnablerRules();
        List<ImplicitEligibilityRule> disablerRules = assessment.getDisablerRules();

        boolean disabled = false;
        boolean enabled = false;

        for (Student student : students) {
            disabled = false;
            enabled = false;

            if (isNotEmpty(disablerRules)) {
                disabled = true;
                // run disabler rules first
                for (ImplicitEligibilityRule rule : disablerRules) {
                    if (!(disabled = applyRule(assessment, rule, student, rule.getField())))
                        break;
                }
            }

            if (!disabled) {
                // run enabler rules
                if (isNotEmpty(enablerRules)) {
                    enabled = true;
                    for (ImplicitEligibilityRule rule : enablerRules) {
                        if (!(enabled = applyRule(assessment, rule, student, rule.getField())))
                            break;
                    }
                }
            }

            if (!disabled && enabled) {
                eligibleStudents.add(student);
            }

        }

        return eligibleStudents;

    }

    private boolean applyRule(final Assessment assessment, final ImplicitEligibilityRule rule, final Student student,
            final String fieldName) {
        Object reflectedValue = null;
        try {
            reflectedValue = PropertyUtils.getProperty(student, fieldName);
            if (reflectedValue == null || !evaluateOperator(reflectedValue, rule)) {
                return false;
            }
        } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e) {
            LOGGER.debug("Field '" + fieldName + "' is not on Student, looking at Accommodations");
            Accommodation accommodation = student.getAccommodation(assessment);
            if (accommodation != null) {
                try {
                    reflectedValue = PropertyUtils.getProperty(accommodation, fieldName);
                } catch (IllegalAccessException | InvocationTargetException | NoSuchMethodException e1) {
                    LOGGER.error("Failure in eligibility eval can't find field called " + fieldName
                            + " in accommodation, invalid rule", e1);
                    throw new EligibilityException("eligibility.invalid.compare.field", new String[] { fieldName }, e);
                }
            } else {
                LOGGER.debug("Accommodation not found for assessment with subject " + assessment.getSubjectCode()
                        + " skipping getProperty");
            }

            if (reflectedValue == null || !evaluateOperator(reflectedValue, rule)) {
                return false;
            }
        }
        return true;
    }

    @SuppressWarnings("unchecked")
    private boolean evaluateOperator(final Object value, final ImplicitEligibilityRule rule) {

        if (rule.getOperatorType().isValidFor(value.getClass())) {
            switch (rule.getOperatorType()) {
                case EQUALS:
                    return value.equals(convertTo(rule.getValue(), value.getClass()));
                case GREATER_THAN:
                    return ((Comparable<Object>) value).compareTo(convertTo(rule.getValue(), value.getClass())) >= 1;
                case GREATER_THAN_EQUALS:
                    return ((Comparable<Object>) value).compareTo(convertTo(rule.getValue(), value.getClass())) >= 0;
                case LESS_THAN:
                    return ((Comparable<Object>) value).compareTo(convertTo(rule.getValue(), value.getClass())) <= 1;
                case LESS_THAN_EQUALS:
                    return ((Comparable<Object>) value).compareTo(convertTo(rule.getValue(), value.getClass())) <= 0;
                default:
                    LOGGER.error("The class type " + value.getClass().toString()
                            + " cannot be compared using the operator " + rule.getOperatorType().name());
                    throw new EligibilityException("eligiblity.invalid.operator.forclass", new String[] {
                            value.getClass().toString(), rule.getOperatorType().name() });
            }
        } else {
            LOGGER.error("The class type " + value.getClass().toString() + " cannot be compared using the operator "
                    + rule.getOperatorType().name());
            throw new EligibilityException("eligiblity.invalid.operator.forclass", new String[] {
                    value.getClass().toString(), rule.getOperatorType().name() });
        }

    }

    @SuppressWarnings("unchecked")
    private <T> T convertTo(final String value, final Class<T> clazz) {

        try {
            if (String.class.isAssignableFrom(clazz)) {
                return (T) value;
            } else if (Number.class.isAssignableFrom(clazz)) {
                return clazz.getConstructor(String.class).newInstance(value);
            } else if (DateTime.class.isAssignableFrom(clazz)) {
                return (T) DateTime.parse(value);
            } else if (Enum.class.isAssignableFrom(clazz)) {
                Method getEnum = null;
                try {
                    getEnum = clazz.getDeclaredMethod("getEnumByValue", String.class);
                } catch (NoSuchMethodException me) {
                    getEnum = clazz.getMethod("valueOf", String.class);
                }
                return (T) getEnum.invoke(null, value);
            } else {
                LOGGER.error("Failure to convert value \"" + value + "\" into class type " + clazz.toString());
                throw new EligibilityException("eligibility.value.convert.error", new String[] { value,
                        clazz.toString() });
            }
        } catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException
                | NoSuchMethodException | SecurityException e) {
            LOGGER.error("Failure to convert value \"" + value + "\" into class type " + clazz.toString(), e);
            throw new EligibilityException("eligibility.value.convert.error", new String[] { value, clazz.toString() },
                    e);
        }

    }

    @ServiceActivator(inputChannel = "studentModificationEventsInbound")
    @Override
    public void evaluateStudentModification(final StudentModificationEvent event) {

        LOGGER.debug("Handling a StudentModificationEvent: " + event);

        switch (event.getAction()) {
            case UPD:
                studentOrAccommodationModified(event);
                break;
            case DEL:
                studentDeleted(event);
                break;
            default:
                // unknown, throw error here
                LOGGER.error("Unknown action: " + event.getAction());
                throw new EligibilityException("eligibility.unknown.event");
        }

    }

    public void studentOrAccommodationModified(final StudentModificationEvent event) {

        // if a student is inserted or modified, the student must be checked against all
        // implicit rules on all assessments marked as implicit

        // remove EligibleStudent for this student
        // find all EligibleAssessments with this student id and modify to remove student

        // find all Assessments that use IMPLICIT eligibility and run all rules against this student

        eligibilityService.removeAllAssociationsForStudent(event.getSource());

        // go up the hierarchy to find all the entities up to the client and add to the hash set
        // we need to know if any of the levels are tenants so we grab all possible assessments for the hierarchy

        // create the initial set with the institution level
        HashSet<SbacEntity> possibleTenants = Sets.newHashSet(new SbacEntity(TenantType.INSTITUTION, event.getSource()
                .getInstitutionIdentifier(), "nothing"));

        Sb11Entity entity = sb11EntityService.findByEntityIdAndStateAbbreviation(event.getSource()
                .getInstitutionIdentifier(), event.getSource().getStateAbbreviation(), InstitutionEntity.class);

        while (entity != null) {
            possibleTenants.add(new SbacEntity(convertHierarchyLevelToTenantType(entity.getParentEntityType()), entity
                    .getParentEntityId(), "nothing"));

            if (entity.getParentEntityId() != null) {
                entity = sb11EntityService.getParentEntity(entity);
            } else {
                entity = null;
            }
        }

        // filter assessments returned by tenant. need to find tenant for the student
        // entity name is just hardcoded because the tenancy service just checks to see if it exists and doesn't use it
        // for anything
        // this gets around having to make another db call to find the actual entity name
        List<Tenant> tenantsForAssessment = tenancyService.getApplicableTenants(possibleTenants);

        List<String> tenantIdsForAssessment = new ArrayList<String>();

        for (Tenant tenant : tenantsForAssessment) {
            tenantIdsForAssessment.add(tenant.getId());
        }

        List<Assessment> implicitAssessments = assessmentRepository.findByEligibilityTypeAndTenantIdIsIn("IMPLICIT",
                tenantIdsForAssessment);

        for (Assessment assess : implicitAssessments) {
            evaluateImplicitRules(assess, event.getSource());
        }

        // lookup explicit eligibility for this student
        // for all rows that exist, add to eligibleStudent

        Student student = studentRepository.findByEntityIdAndStateAbbreviation(event.getSource().getEntityId(), event
                .getSource().getStateAbbreviation());

        List<Assessment> assessments;

        List<ExplicitEligibility> explicitEligibilities = explicitEligRepository.findByStudentIdAndStateAbbreviation(
                event.getSource().getEntityId(), event.getSource().getStateAbbreviation());

        if (explicitEligibilities != null && !explicitEligibilities.isEmpty()) {
            for (ExplicitEligibility explicitEligibility : explicitEligibilities) {
                assessments = assessmentRepository.findByTestNameAndVersion(explicitEligibility.getTestName(),
                        explicitEligibility.getTestVersion());
                if (assessments != null) {
                    if (assessments.size() == 1) {
                        eligibilityService.saveAssociation(assessments.get(0), student);
                    } else {
                        LOGGER.error("More than one assessment returned for test name = "
                                + explicitEligibility.getTestName() + " and version = "
                                + explicitEligibility.getTestVersion()
                                + " cannot set explicit eligibility for student id = "
                                + event.getSource().getEntityId() + ".");
                    }
                } else {
                    LOGGER.error("No assessment found for test name = " + explicitEligibility.getTestName()
                            + " and version = " + explicitEligibility.getTestVersion()
                            + " cannot set explicit eligibility for student id = " + event.getSource().getEntityId()
                            + ".");
                }

            }
        }

    }

    public void studentDeleted(final StudentModificationEvent event) {

        // if a student is deleted, then corresponding EligibleStudent must be deleted
        // and each EligibleAssessment that includes the student must be modified to remove the student

        // remove EligibleStudent for this student
        // find all EligibleAssessments with this student id and modify to remove student

        eligibilityService.removeAllAssociationsForStudent(event.getSource());

    }

    @ServiceActivator(inputChannel = "assessmentModificationEventsInbound")
    @Override
    public void evaluateAssessmentModification(final AssessmentModificationEvent event) {

        LOGGER.debug("Handling an AssessmentModificationEvent: " + event);

        switch (event.getAction()) {
            case UPD:
                assessmentModified(event);
                break;
            case DEL:
                assessmentDeleted(event);
                break;
            default:
                // unknown, throw error here
                LOGGER.error("Unknown action: " + event.getAction());
                throw new EligibilityException("eligibility.unknown.event");
        }
    }

    public void assessmentModified(final AssessmentModificationEvent event) {
        // if the implicit eligibility rules for an assessment are changed (any create, update, delete)
        // then each student in the system must be tested against the rules

        // if an assessment changes from implicit to explicit eligibility,
        // the corresponding EligibleAssessment must be removed
        // and each EligibleStudent that includes the assessment must be modified to remove the assessment
        // then re-evaluate explicit eligibility to see if any records exist for the assessment

        // if an assessment changes from explicit to implicit eligibility,
        // the corresponding EligibleAssessment must be removed
        // and each EligibleStudent that includes the assessment must be modified to remove the assessment
        // then each student in the system must be checked against the new implicit rules

        Assessment source = event.getSource();

        LOGGER.debug("Removing all associations for assessment with id: " + source.getId());
        eligibilityService.removeAllAssociationsForAssessment(source);

        switch (source.getEligibilityType()) {
            case IMPLICIT:
                // this has potential to run really slow, but we should be able to filter by
                // the tenant on the assessment

                // find all applicable students
                // add filtering to find only applicable students, for now this will get ALL students
                // assessment has a tenant, convert tenant back into possible institution ids that can be used to
                // filter students

                String tenantId = source.getTenantId();
                Tenant tenant = progmanClient.getTenantById(tenantId);

                // get the entity that corresponds to the tenant

                Sb11SuperEntity entity = sb11EntityService.findByEntityId(tenant.getName(), tenant.getType());

                CacheMap cacheMap = cacheMapService.getCacheMap("UberEntityRelationshipMap");
                Map<String, Set<String>> uberMap = null;
                if (cacheMap != null) {
                    uberMap = cacheMap.getMap();
                }

                Set<String> validEntityMongoIds = uberMap.get(entity.getId());

                validEntityMongoIds.add(entity.getId());

                LOGGER.debug("Counting students in the DB");
                long numStudents = studentRepository
                        .countByInstitutionFilter(new ArrayList<>(validEntityMongoIds));
                LOGGER.debug("Calculating implicit eligibility for " + numStudents + " students");

                long numPages = numStudents / PAGE_SIZE;
                long remain = numStudents % PAGE_SIZE;

                if (remain > 0) {
                    numPages++;
                }

                LOGGER.debug("Chunking students into " + numPages + " pages of size " + PAGE_SIZE);

                List<Student> students = null;
                List<Student> eligStudents = null;
                String studentMongoId = "000000000000000000000000";

                // TODO Another speedup can be obtained by sending each chunk to an @Async method, will have to see how
                // many executors is a good number

                for (long curPage = 0; curPage < numPages; curPage++) {
                    long timestamp = System.currentTimeMillis();
                    // students = studentRepository.findAll(
                    // new PageRequest((int) curPage, (int) PAGE_SIZE, new Sort("_id"))).getContent();
                    students = studentRepository.findAllByRangeAndLimitWithInstitutionFilter(studentMongoId,
                            (int) PAGE_SIZE, new ArrayList<>(validEntityMongoIds));

                    LOGGER.debug("Time to get another page of students: " + (System.currentTimeMillis() - timestamp));

                    LOGGER.debug("Running rule evaluation for page " + curPage + " of " + numPages);
                    LOGGER.debug("Evaluating " + students.size() + " students");

                    studentMongoId = students.get(students.size() - 1).getId();

                    long timestamp2 = System.currentTimeMillis();
                    eligStudents = evaluateImplicitRules(source, students);
                    LOGGER.debug("Time to run rule eval for chunk of students: "
                            + (System.currentTimeMillis() - timestamp2));

                    LOGGER.debug("Evaluation found " + eligStudents.size() + " eligible students, calling save");

                    long timestamp3 = System.currentTimeMillis();

                    if (!eligStudents.isEmpty()) {
                        eligibilityService.saveAssociations(source, eligStudents);
                    }

                    LOGGER.debug("Time to save new EligibleStudents for one chunk of students: "
                            + (System.currentTimeMillis() - timestamp3));
                    LOGGER.debug("Time to run one chunk of evaluation rules plus save: "
                            + (System.currentTimeMillis() - timestamp));
                }

                break;

            case EXPLICIT:
                // search for any explicit eligibility records for this assessment and associate
                List<ExplicitEligibility> eligRecs = explicitEligRepository.findByTestNameAndTestVersion(
                        source.getTestName(), source.getVersion());

                List<Student> tmpStudents = new ArrayList<>();

                for (ExplicitEligibility explicitElig : eligRecs) {
                    // look up Student
                    tmpStudents.add(studentRepository.findByEntityIdAndStateAbbreviation(explicitElig.getStudentId(),
                            explicitElig.getStateAbbreviation()));
                }

                if (!tmpStudents.isEmpty()) {
                    eligibilityService.saveAssociations(source, tmpStudents);
                }

                break;

            default:
                LOGGER.error("Unknown eligbility type: " + source.getEligibilityType());
                throw new EligibilityException("eligibility.unknown.type");

        }

    }

    public void assessmentDeleted(final AssessmentModificationEvent event) {
        eligibilityService.removeAllAssociationsForAssessment(event.getSource());
    }

    @ServiceActivator(inputChannel = "explicitEligibilityModificationEventsInbound")
    @Override
    public void evaluateExplicitEligibilityModification(final ExplicitEligibilityModificationEvent event) {

        LOGGER.debug("Handling an ExplicitEligibilityModificationEvent: " + event);

        switch (event.getAction()) {
            case UPD:
                explicitEligibilityModified(event);
                break;
            case DEL:
                explicitEligibilityDeleted(event);
                break;
            default:
                // unknown, throw error here
                LOGGER.error("Unknown action: " + event.getAction());
                throw new EligibilityException("eligibility.unknown.event");
        }

    }

    public void explicitEligibilityModified(final ExplicitEligibilityModificationEvent event) {
        // this is really just ADD, there is no update of explicit eligibility
        // find the student by student id
        // find the assessment by alternate key
        final ExplicitEligibility explicitEligibility = event.getSource();

        final Student student = studentRepository.findByEntityIdAndStateAbbreviation(
                explicitEligibility.getStudentId(), event.getSource().getStateAbbreviation());
        final List<Assessment> assess = assessmentRepository.findByTestNameAndVersion(
                explicitEligibility.getTestName(), event.getSource().getTestVersion());

        if (assess != null && assess.size() > 1) {
            // more than one assessment exists with the name and version
            // this is an error condition

            throw new EligibilityException("More than one assessment exists with the same name and version: "
                    + explicitEligibility.getTestName() + ", " + event.getSource().getTestVersion());

        }

        // associate the two
        eligibilityService.saveAssociation(assess.get(0), student);
    }

    public void explicitEligibilityDeleted(final ExplicitEligibilityModificationEvent event) {
        // find the student by student id
        // find the assessment by alternate key

        Student student = studentRepository.findByEntityIdAndStateAbbreviation(event.getSource().getStudentId(), event
                .getSource().getStateAbbreviation());
        List<Assessment> assess = assessmentRepository.findByTestNameAndVersion(event.getSource().getTestName(), event
                .getSource().getTestVersion());

        if (assess != null && assess.size() > 1) {
            // more than one assessment exists with the name and version
            // this is an error condition

            throw new EligibilityException("More than one assessment exists with the same name and version: "
                    + event.getSource().getTestName() + ", " + event.getSource().getTestVersion());

        }

        // remove the association
        eligibilityService.removeAssociation(assess.get(0), student);

    }

    @Override
    public void recalculateAllEligibility() {

        // remove the eligible student collection
        eligibilityService.removeEligibleStudentCollection();

        // load all the Assessments in the system and create assessment modified events for each
        // loop and call assessmentModified() for each

        List<Assessment> allAssessments = assessmentRepository.findAll();

        AssessmentModificationEvent modEvent = null;
        List<AssessmentModificationEvent> events = new ArrayList<AssessmentModificationEvent>();

        for (Assessment assess : allAssessments) {
            modEvent = new AssessmentModificationEvent(assess, assess, Action.UPD);
            events.add(modEvent);
        }

        for (AssessmentModificationEvent event : events) {
            try {
                evaluateAssessmentModification(event);
            } catch (Exception e) {
                LOGGER.warn("Caught exception while re-evaluating all eligibility, ignoring: ", e);
            }
        }

        // done!

    }

    private TenantType convertHierarchyLevelToTenantType(HierarchyLevel level) {
        TenantType converted = null;

        switch (level) {
            case DISTRICT:
                converted = TenantType.DISTRICT;
                break;
            case GROUPOFDISTRICTS:
                converted = TenantType.DISTRICT_GROUP;
                break;
            case GROUPOFINSTITUTIONS:
                converted = TenantType.INSTITUTION_GROUP;
                break;
            case GROUPOFSTATES:
                converted = TenantType.STATE_GROUP;
                break;
            case STATE:
                converted = TenantType.STATE;
                break;
            default:
                converted = null;
                break;
        }

        return converted;
    }

}
