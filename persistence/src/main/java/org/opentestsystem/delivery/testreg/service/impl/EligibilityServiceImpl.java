/*
Educational Online Test Delivery System Copyright (c) 2013 American Institutes for Research

Distributed under the AIR Open Source License, Version 1.0 See accompanying file AIR-License-1_0.txt or at
http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 */

package org.opentestsystem.delivery.testreg.service.impl;


import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.joda.time.DateTime;
import org.opentestsystem.delivery.testadmin.domain.Status;
import org.opentestsystem.delivery.testadmin.domain.TestStatus;
import org.opentestsystem.delivery.testadmin.persistence.TestStatusRepository;
import org.opentestsystem.delivery.testadmin.service.TestStatusService;
import org.opentestsystem.delivery.testreg.domain.ARTHelpers;
import org.opentestsystem.delivery.testreg.domain.Accommodation;
import org.opentestsystem.delivery.testreg.domain.Assessment;
import org.opentestsystem.delivery.testreg.domain.Assessment.TestWindow;
import org.opentestsystem.delivery.testreg.domain.EligibleStudent;
import org.opentestsystem.delivery.testreg.domain.ExplicitEligibility;
import org.opentestsystem.delivery.testreg.domain.Student;
import org.opentestsystem.delivery.testreg.domain.exception.EligibilityException;
import org.opentestsystem.delivery.testreg.domain.search.EligibleStudentSearchRequest;
import org.opentestsystem.delivery.testreg.persistence.AssessmentRepository;
import org.opentestsystem.delivery.testreg.persistence.EligibleStudentRepository;
import org.opentestsystem.delivery.testreg.persistence.ExplicitEligibilityRepository;
import org.opentestsystem.delivery.testreg.persistence.StudentRepository;
import org.opentestsystem.delivery.testreg.service.EligibilityService;
import org.opentestsystem.delivery.testreg.service.TestRegPersister;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;

@Service
public class EligibilityServiceImpl implements EligibilityService {

    private static final Logger LOGGER = LoggerFactory.getLogger(EligibilityServiceImpl.class);

    private static final long PAGE_SIZE = 5000;

    @Autowired
    private EligibleStudentRepository eligStudentRepo;
    
    @Autowired
    private TestStatusRepository testStatusRepo;

    @Autowired
    private StudentRepository studentRepo;

    @Autowired
    private AssessmentRepository assessmentRepo;

    @Autowired
    private TestRegPersister testRegPersister;
    
    @Autowired
    private TestStatusService testStatusService;

    @Autowired
    private ExplicitEligibilityRepository explicitEligibilityRepository;

    @Override
    public List<Assessment> findEligibleAssessmentsByStudent(final String studentMongoId) {
        // lookup in elig student by student mongo id

        try {
            final EligibleStudent eligStudent = this.eligStudentRepo.findByStudentMongoId(studentMongoId);

            if (eligStudent == null) {
                return Lists.newArrayList();
            }

            return eligStudent.getAssessmentsAsList();
        } catch (final IllegalArgumentException e) {
            return Lists.newArrayList();
        }

    }

    @Override
    public List<Assessment> findEligibleAssessmentsByTestWindow(final String entityId, final String stateAbbreviation) {
        final List<Assessment> filteredAssessments = Lists.newArrayList();
        // look up for the student for the given key
        final List<Assessment> assessments = findEligibleAssessmentsByStudentIdAndState(entityId, stateAbbreviation);
        for (final Assessment assessment : assessments) {
            final TestWindow testWindow[] = assessment.getTestWindow();
            for (final TestWindow window : testWindow) {
                if (dateCompare(window.getBeginWindow(), window.getEndWindow())) {
                    filteredAssessments.add(assessment);
                }
            }
        }
        return filteredAssessments;
    }

    // To compare the current day
    private boolean dateCompare(final DateTime windowBeginTime, final DateTime windowEndTime) {

        if ((windowBeginTime.isBeforeNow() || windowBeginTime.isEqualNow())
                && (windowEndTime.isEqualNow() || windowEndTime.isAfterNow())) {
            return true;
        }
        return false;
    }

    private void doSaveAssociation(final Assessment assess, final Student student) {

        verifyIds(assess, student);

        LOGGER.debug("Looking up eligible student by student mongo id: " + student.getId());

        // lookup eligible student
        EligibleStudent eligStudent = this.eligStudentRepo.findByStudentMongoId(student.getId());

        LOGGER.debug("Found EligibleStudent: " + eligStudent);

        if (eligStudent == null) {
            eligStudent = new EligibleStudent(student);
        } else {
            eligStudent.setStudent(student);
        }

        eligStudent.addAssessment(assess);

        determineInvalidSubjects(eligStudent);
        
        addTestStatuses(eligStudent);
        this.eligStudentRepo.save(eligStudent);
    }

    private boolean isSubjectExists(final List<Assessment> eligAssessments, final String accSubject) {
        for (final Assessment assessment : eligAssessments) {
            if (assessment.getSubjectCode().equals(accSubject)) {
                return true;
            }
        }
        return false;
    }

    @Override
    public void saveAssociation(final Assessment assess, final Student student) {
        doSaveAssociation(assess, student);
    }

    // TODO do we need explicit eligibility object here?
    @Override
    public void saveAssociations(final Assessment assess, final List<Student> students) {
        // same as saveAssociation except multiple students at a time

        verifyIds(assess, students);

        // lookup eligible students

        final List<EligibleStudent> eligStudents = Lists.newArrayList();

        for (final Student student : students) {

            // lookup eligible student
            EligibleStudent eligStudent = this.eligStudentRepo.findByStudentMongoId(student.getId());

            if (LOGGER.isDebugEnabled()) {
                LOGGER.debug("Lookup for EligibleStudent by student mongo id [" + student.getId() + "] found:" + eligStudent);
            }
            if (eligStudent == null) {
                eligStudent = new EligibleStudent(student);
            } else {
                eligStudent.setStudent(student);
            }

            eligStudent.addAssessment(assess);

            determineInvalidSubjects(eligStudent);
            
            addTestStatuses(eligStudent);

            eligStudents.add(eligStudent);

        }

        this.eligStudentRepo.save(eligStudents);

    }

    @Override
    public void removeAssociation(final Assessment assess, final Student student) {

        // lookup elig student
        final EligibleStudent eligStudent = this.eligStudentRepo.findByStudentIdAndState(student.getEntityId(), student.getStateAbbreviation());

        if (eligStudent == null) {
            throw new EligibilityException("eligibility.association.eligstudent.notfound", new String[] { student.getId() });
        }

        // remove assessment id from associated assessments
        eligStudent.removeAssessment(assess);

        // is assessment id list empty?
        if (!eligStudent.hasAssessments()) {

            // if so, delete elig student
            this.eligStudentRepo.delete(eligStudent);
        } else {
            determineInvalidSubjects(eligStudent);

            // if not, update
            this.eligStudentRepo.save(eligStudent);
        }

    }

    @Override
    public void removeAssociations(final Assessment assess, final List<Student> students) {

        EligibleStudent eligStudent = null;

        for (final Student student : students) {

            // lookup elig student
            eligStudent = this.eligStudentRepo.findByStudentIdAndState(student.getEntityId(), student.getStateAbbreviation());

            if (eligStudent == null) {
                throw new EligibilityException("eligibility.association.eligstudent.notfound", new String[] { student.getId() });
            }

            // remove assessment id from associated assessments
            eligStudent.removeAssessment(assess);

            // is assessment id list empty?
            if (!eligStudent.hasAssessments()) {

                // if so, delete elig student
                this.eligStudentRepo.delete(eligStudent);
            } else {
                determineInvalidSubjects(eligStudent);

                // if not, update
                this.eligStudentRepo.save(eligStudent);
            }
        }

    }

    private void verifyIds(final Assessment assessment, final Student student) {
        verifyAssessmentId(assessment);
        verifyStudentIds(Lists.newArrayList(student));
    }

    private void verifyIds(final Assessment assessment, final List<Student> students) {
        verifyAssessmentId(assessment);
        verifyStudentIds(students);
    }

    private void verifyAssessmentId(final Assessment assessment) {
        if (assessment == null) {
            throw new EligibilityException("eligibility.association.assessment.required");
        }

        if (assessment.getId() == null) {
            throw new EligibilityException("eligibility.association.assessment.id.required");
        }

        // lookup the assessment to see if it exists
        final Assessment existingAssess = this.assessmentRepo.findOne(assessment.getId());
        if (existingAssess == null) {
            throw new EligibilityException("eligibility.association.assessment.nonexist", new String[] { assessment.getId() });
        }
    }

    private void verifyStudentIds(final List<Student> students) {
        if (CollectionUtils.isEmpty(students)) {
            throw new EligibilityException("eligibility.association.student.required");
        }

        for (final Student student : students) {
            if (student == null) {
                throw new EligibilityException("eligibility.association.student.required");
            }

            if (student.getId() == null) {
                throw new EligibilityException("eligibility.association.student.id.required");
            }

            final Student existingStudent = this.studentRepo.findOne(student.getId());
            if (existingStudent == null) {
                throw new EligibilityException("eligibility.association.student.nonexist", new String[] { student.getId() });
            }
        }

    }

    @Override
    public void removeAllAssociationsForStudent(final Student student) {
        final EligibleStudent eligStudent = this.eligStudentRepo.findByStudentMongoId (student.getId ());

        if (eligStudent != null) {
            this.eligStudentRepo.delete(eligStudent);
        }
    }

    @Override
    public void removeAllAssociationsForAssessment(final Assessment assess) {

        final long numEligStudents = this.eligStudentRepo.countByAssessmentMongoId(assess.getId());

        long numPages = numEligStudents / PAGE_SIZE;
        final long remain = numEligStudents % PAGE_SIZE;

        if (remain > 0) {
            numPages++;
        }

        List<EligibleStudent> eligStudents = null;

        for (long curPage = 0; curPage < numPages; curPage++) {
            eligStudents = this.eligStudentRepo.findByAssessmentMongoId(assess.getId(), new PageRequest((int) curPage, (int) PAGE_SIZE));

            if (eligStudents != null) {
                for (final EligibleStudent eligStudent : eligStudents) {
                    removeAssociation(assess, eligStudent.getStudent());
                }
            }
        }

    }

    private void determineInvalidSubjects(final EligibleStudent eligStudent) {
        final Student student = eligStudent.getStudent();

        student.setInValidAccommodationsSubject(false);
        for (final Accommodation accommodation : student.getAccommodations()) {
            final String accSubject = accommodation.getSubject();
            if (!isSubjectExists(eligStudent.getAssessmentsAsList(), accSubject)) {
                student.setInValidAccommodationsSubject(true);
                break;
            }
        }
    }

    @Override
    public List<Assessment> findEligibleAssessmentsByStudentIdAndState(final String studentId, final String state) {

        List<Assessment> assessmentList = Lists.newArrayList();
        final EligibleStudent eligStudent = this.eligStudentRepo.findByStudentIdAndState(studentId, state);
        
        if (eligStudent != null) {
            assessmentList = eligStudent.getAssessmentsAsList();
        }
        return assessmentList;
    }

    @Override
    public Set<Assessment> findAllAssessmentsByTenantsAndBeginWindow(final Collection<String> tenantsList, final DateTime date) {
        final Set<Assessment> assessments = Sets.newHashSet();
        final List<Assessment> found = this.assessmentRepo.findAllByTenantsAndBeginWindow(tenantsList, date);
        if (found != null) {
            for (final Assessment assessment : found) {
                assessment.setTestWindow(filterTestWindowsForDate(assessment.getTestWindow(), date));
                if (assessment.getTestWindow().length != 0) {
                    if (this.eligStudentRepo.findAtLeastOneEligibleStudent(assessment.getId())) {
                        assessments.add(assessment);
                    }
                }
            }
        }
        return assessments;
    }

    @Override
    public SearchResponse<Student> findStudents(final EligibleStudentSearchRequest searchRequest) {
        final SearchResponse<EligibleStudent> eligibilityList = this.eligStudentRepo.search(searchRequest);
        final List<Student> studentList = Lists.newArrayList();
        for (final EligibleStudent eligibleStudent : eligibilityList.getSearchResults()) {
            studentList.add(eligibleStudent.getStudent());
        }
        final SearchResponse<Student> studentResposne = new SearchResponse<Student>(studentList, searchRequest, eligibilityList.getTotalCount());
        return studentResposne;
    }

    @Override
    public SearchResponse<EligibleStudent> findEligibleStudents(final EligibleStudentSearchRequest searchRequest) {
        return this.eligStudentRepo.search(searchRequest);
    }

    @Override
    public Map<ExplicitEligibility, DateTime> findAllEligibilityByStudentIdStateAbbreviationAndBeginWindow(final String studentId, final String stateAbbreviation, final DateTime date) {

        // Sorted Map based on ExplicitEligibility indices
        final Map<ExplicitEligibility, DateTime> eligibilityWindowMap = Maps.newTreeMap(ARTHelpers.EXPLICIT_ELIGIBILITY_COMPARATOR);

        // 1. First Check if the student is eligible
        final EligibleStudent eligStudent = this.eligStudentRepo.findByStudentIdAndState(studentId, stateAbbreviation);

        if (eligStudent == null || eligStudent.getAssessments().isEmpty()) {
            return Maps.newHashMap();
        }
        
        // 2. For each Eligible Assessment, check if it has any window that are open as of date that is passed
        for (final Assessment assessment : eligStudent.getAssessments ()) {
          TestStatus tests = testStatusService.findByAlternateId(studentId, stateAbbreviation, assessment.getId (),1);
            if(!tests.getStatus ().equals (Status.OPTED_OUT)){
              // If a window is open
              final TestWindow[] testWindowsOpen = filterTestWindowsForDate (assessment.getTestWindow (), date);
              if (testWindowsOpen.length > 0) {
    
                ExplicitEligibility eligibility = null;
                switch (assessment.getEligibilityType ()) {
                case EXPLICIT:
                  // For all Forms
                  if (assessment.getTestForm () != null) {
                    for (final String testForm : assessment.getTestForm ()) {
                      eligibility = new ExplicitEligibility ();
                      eligibility.setSubject (assessment.getSubjectCode ());
                      eligibility.setTestName (assessment.getEntityId ());
                      eligibility.setTestForm (testForm);
                      eligibility.setAssessmentMongoId (assessment.getId ());
                      eligibilityWindowMap.put (eligibility, getEarliestWindowOpenDate (testWindowsOpen));
                    }
                  } else {
                    eligibility = new ExplicitEligibility ();
                    eligibility.setSubject (assessment.getSubjectCode ());
                    eligibility.setTestName (assessment.getEntityId ());
                    eligibility.setTestForm (null);
                    eligibility.setAssessmentMongoId (assessment.getId ());
                    eligibilityWindowMap.put (eligibility, getEarliestWindowOpenDate (testWindowsOpen));
                  }
                  break;
                case IMPLICIT:
                  eligibility = new ExplicitEligibility ();
                  eligibility.setSubject (assessment.getSubjectCode ());
                  eligibility.setTestName (assessment.getEntityId ());
                  eligibility.setTestForm (null); // When Assessment is Implicit,
                                                  // Test Forms are not needed
                  eligibility.setAssessmentMongoId (assessment.getId ());
                  eligibilityWindowMap.put (eligibility, getEarliestWindowOpenDate (testWindowsOpen));
                  break;
                }
              }
            }//opt_out end
        }
        return eligibilityWindowMap;
    }

    private TestWindow[] filterTestWindowsForDate(final TestWindow[] testWindows, final DateTime date) {

        final List<TestWindow> testWindowList = Lists.newArrayList();
        for (final TestWindow testWindow : testWindows) {

            final DateTime beginDate = testWindow.getBeginWindow();
            final DateTime endDate = testWindow.getEndWindow();

            final boolean isOnOrAfterBeginDate = beginDate.isEqual(date) || beginDate.isBefore(date);
            final boolean isOnOrBeforeEndDate = endDate.isEqual(date) || endDate.isAfter(date);
            final boolean isBetweenBeginAndEndDates = isOnOrAfterBeginDate && isOnOrBeforeEndDate;

            if (isBetweenBeginAndEndDates) {
                testWindowList.add(testWindow);
            }
        }
        return testWindowList.toArray(new TestWindow[testWindowList.size()]);
    }

    private DateTime getEarliestWindowOpenDate(final TestWindow[] testWindows) {
        DateTime earliestStartDate = testWindows[0].getBeginWindow();

        for (int i = 1; i < testWindows.length; i++) {
            if (testWindows[i].getBeginWindow().isBefore(earliestStartDate)) {
                earliestStartDate = testWindows[i].getBeginWindow();
            }
        }
        return earliestStartDate;
    }

    @Override
    public void removeEligibleStudentCollection() {
        this.eligStudentRepo.dropCollection();
    }
    
    private void addTestStatuses(final EligibleStudent eligStudent){
      List<Assessment> assessments = eligStudent.getAssessmentsAsList ();
      Student std = eligStudent.getStudent ();
      for(Assessment assessme : assessments){
        TestStatus statusObj = testStatusService.findByStudentIdStateAbbrAssessmentId(std.getEntityId (), std.getStateAbbreviation (), assessme.getId ());
        if(statusObj == null){
          statusObj = new TestStatus();
          statusObj.setAssessmentId(assessme.getId ());
          statusObj.setOpportunity(1);
          statusObj.setStateAbbreviation(std.getStateAbbreviation ());
          statusObj.setStatus(Status.SCHEDULED);
          statusObj.setStudentId(std.getEntityId ());

          testStatusService.saveTestStatus (statusObj);
        }
      }
    }

    
}
