/*
Educational Online Test Delivery System Copyright (c) 2013 American Institutes for Research

Distributed under the AIR Open Source License, Version 1.0 See accompanying file AIR-License-1_0.txt or at
http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 */

package org.opentestsystem.delivery.testreg.service.impl;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

import org.joda.time.DateTime;
import org.opentestsystem.delivery.testreg.domain.Accommodation;
import org.opentestsystem.delivery.testreg.domain.Assessment;
import org.opentestsystem.delivery.testreg.domain.Assessment.TestWindow;
import org.opentestsystem.delivery.testreg.domain.EligibleStudent;
import org.opentestsystem.delivery.testreg.domain.ExplicitEligibility;
import org.opentestsystem.delivery.testreg.domain.Student;
import org.opentestsystem.delivery.testreg.domain.exception.EligibilityException;
import org.opentestsystem.delivery.testreg.domain.search.EligibleStudentSearchRequest;
import org.opentestsystem.delivery.testreg.persistence.AssessmentRepository;
import org.opentestsystem.delivery.testreg.persistence.EligibleStudentRepository;
import org.opentestsystem.delivery.testreg.persistence.ExplicitEligibilityRepository;
import org.opentestsystem.delivery.testreg.persistence.StudentRepository;
import org.opentestsystem.delivery.testreg.service.EligibilityService;
import org.opentestsystem.delivery.testreg.service.TestRegPersister;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.PageRequest;
import org.springframework.stereotype.Service;

@Service
public class EligibilityServiceImpl implements EligibilityService {

    private static final Logger LOGGER = LoggerFactory.getLogger(EligibilityServiceImpl.class);

    private static final long PAGE_SIZE = 5000;

    @Autowired
    private EligibleStudentRepository eligStudentRepo;

    @Autowired
    private StudentRepository studentRepo;

    @Autowired
    private AssessmentRepository assessmentRepo;

    @Autowired
    private TestRegPersister testRegPersister;

    @Autowired
    private ExplicitEligibilityRepository explicitEligibilityRepository;

    @Override
    public List<Assessment> findEligibleAssessmentsByStudent(final String studentMongoId) {
        // lookup in elig student by student mongo id

        try {
            EligibleStudent eligStudent = eligStudentRepo.findByStudentMongoId(studentMongoId);

            if (eligStudent == null) {
                return Collections.emptyList();
            }

            return eligStudent.getAssessmentsAsList();
        } catch (IllegalArgumentException e) {
            return Collections.emptyList();
        }

    }

    @Override
    public List<Assessment> findEligibleAssessmentsByTestWindow(final String entityId, final String stateAbbreviation) {
        List<Assessment> filteredAssessments = new ArrayList<Assessment>();
        // look up for the student for the given key
        List<Assessment> assessments = findEligibleAssessmentsByStudentIdAndState(entityId, stateAbbreviation);
        for (Assessment assessment : assessments) {
            TestWindow testWindow[] = assessment.getTestWindow();
            for (TestWindow window : testWindow) {
                if (dateCompare(window.getBeginWindow(), window.getEndWindow())) {
                    filteredAssessments.add(assessment);
                }
            }
        }
        return filteredAssessments;
    }

    // To compare the current day
    private boolean dateCompare(final DateTime windowBeginTime, final DateTime windowEndTime) {

        if ((windowBeginTime.isBeforeNow() || windowBeginTime.isEqualNow())
                && (windowEndTime.isEqualNow() || windowEndTime.isAfterNow())) {
            return true;
        }
        return false;
    }

    private void doSaveAssociation(final Assessment assess, final Student student) {

        verifyIds(assess, student);

        LOGGER.debug("Looking up eligible student by student mongo id: " + student.getId());

        // lookup eligible student
        EligibleStudent eligStudent = eligStudentRepo.findByStudentMongoId(student.getId());

        LOGGER.debug("Found EligibleStudent: " + eligStudent);

        if (eligStudent == null) {
            eligStudent = new EligibleStudent(student);
        } else {
            eligStudent.setStudent(student);
        }

        eligStudent.addAssessment(assess);

        determineInvalidSubjects(eligStudent);

        eligStudentRepo.save(eligStudent);
    }

    private boolean isSubjectExists(final List<Assessment> eligAssessments, final String accSubject) {
        for (Assessment assessment : eligAssessments) {
            if (assessment.getSubjectCode().equals(accSubject)) {
                return true;
            }
        }
        return false;
    }

    @Override
    public void saveAssociation(final Assessment assess, final Student student) {
        doSaveAssociation(assess, student);
    }

    // TODO do we need explicit eligibility object here?
    @Override
    public void saveAssociations(final Assessment assess, final List<Student> students) {
        // same as saveAssociation except multiple students at a time

        verifyIds(assess, students);

        // lookup eligible students

        List<EligibleStudent> eligStudents = new ArrayList<EligibleStudent>();

        for (Student student : students) {

            LOGGER.debug("Looking up eligible student by student mongo id: " + student.getId());

            // lookup eligible student
            EligibleStudent eligStudent = eligStudentRepo.findByStudentMongoId(student.getId());

            LOGGER.debug("Found EligibleStudent: " + eligStudent);

            if (eligStudent == null) {
                eligStudent = new EligibleStudent(student);
            } else {
                eligStudent.setStudent(student);
            }

            eligStudent.addAssessment(assess);

            determineInvalidSubjects(eligStudent);

            eligStudents.add(eligStudent);

        }

        eligStudentRepo.save(eligStudents);

    }

    @Override
    public void removeAssociation(final Assessment assess, final Student student) {

        // lookup elig student
        EligibleStudent eligStudent = eligStudentRepo.findByStudentIdAndState(student.getEntityId(),
                student.getStateAbbreviation());

        if (eligStudent == null) {
            throw new EligibilityException("eligibility.association.eligstudent.notfound",
                    new String[] { student.getId() });
        }

        // remove assessment id from associated assessments
        eligStudent.removeAssessment(assess);

        // is assessment id list empty?
        if (!eligStudent.hasAssessments()) {

            // if so, delete elig student
            eligStudentRepo.delete(eligStudent);
        } else {
            determineInvalidSubjects(eligStudent);

            // if not, update
            eligStudentRepo.save(eligStudent);
        }

    }

    @Override
    public void removeAssociations(final Assessment assess, final List<Student> students) {

        EligibleStudent eligStudent = null;

        for (Student student : students) {

            // lookup elig student
            eligStudent = eligStudentRepo
                    .findByStudentIdAndState(student.getEntityId(), student.getStateAbbreviation());

            if (eligStudent == null) {
                throw new EligibilityException("eligibility.association.eligstudent.notfound",
                        new String[] { student.getId() });
            }

            // remove assessment id from associated assessments
            eligStudent.removeAssessment(assess);

            // is assessment id list empty?
            if (!eligStudent.hasAssessments()) {

                // if so, delete elig student
                eligStudentRepo.delete(eligStudent);
            } else {
                determineInvalidSubjects(eligStudent);

                // if not, update
                eligStudentRepo.save(eligStudent);
            }
        }

    }

    private void verifyIds(final Assessment assessment, final Student student) {
        verifyAssessmentId(assessment);
        List<Student> students = new ArrayList<Student>();
        students.add(student);
        verifyStudentIds(students);
    }

    private void verifyIds(final Assessment assessment, final List<Student> students) {
        verifyAssessmentId(assessment);
        verifyStudentIds(students);
    }

    private void verifyAssessmentId(final Assessment assessment) {
        if (assessment == null) {
            throw new EligibilityException("eligibility.association.assessment.required");
        }

        if (assessment.getId() == null) {
            throw new EligibilityException("eligibility.association.assessment.id.required");
        }

        // lookup the assessment to see if it exists
        Assessment existingAssess = assessmentRepo.findOne(assessment.getId());
        if (existingAssess == null) {
            throw new EligibilityException("eligibility.association.assessment.nonexist",
                    new String[] { assessment.getId() });
        }
    }

    private void verifyStudentIds(final List<Student> students) {
        if (students == null || students.isEmpty()) {
            throw new EligibilityException("eligibility.association.student.required");
        }

        for (Student student : students) {
            if (student == null) {
                throw new EligibilityException("eligibility.association.student.required");
            }

            if (student.getId() == null) {
                throw new EligibilityException("eligibility.association.student.id.required");
            }

            Student existingStudent = studentRepo.findOne(student.getId());
            if (existingStudent == null) {
                throw new EligibilityException("eligibility.association.student.nonexist",
                        new String[] { student.getId() });
            }
        }

    }

    @Override
    public void removeAllAssociationsForStudent(final Student student) {
        EligibleStudent eligStudent = eligStudentRepo.findByStudentIdAndState(student.getEntityId(),
                student.getStateAbbreviation());

        if (eligStudent != null) {
            eligStudentRepo.delete(eligStudent);
        }

    }

    @Override
    public void removeAllAssociationsForAssessment(final Assessment assess) {

        long numEligStudents = eligStudentRepo.countByAssessmentMongoId(assess.getId());

        long numPages = numEligStudents / PAGE_SIZE;
        long remain = numEligStudents % PAGE_SIZE;

        if (remain > 0) {
            numPages++;
        }

        List<EligibleStudent> eligStudents = null;

        for (long curPage = 0; curPage < numPages; curPage++) {
            eligStudents = eligStudentRepo.findByAssessmentMongoId(assess.getId(), new PageRequest((int) curPage,
                    (int) PAGE_SIZE));

            if (eligStudents != null) {
                for (EligibleStudent eligStudent : eligStudents) {
                    removeAssociation(assess, eligStudent.getStudent());
                }
            }
        }

    }

    private void determineInvalidSubjects(final EligibleStudent eligStudent) {
        Student student = eligStudent.getStudent();

        student.setInValidAccommodationsSubject(false);
        for (Accommodation accommodation : student.getAccommodations()) {
            String accSubject = accommodation.getSubject();
            if (!isSubjectExists(eligStudent.getAssessmentsAsList(), accSubject)) {
                student.setInValidAccommodationsSubject(true);
                break;
            }
        }
    }

    @Override
    public List<Assessment> findEligibleAssessmentsByStudentIdAndState(final String studentId, final String state) {

        List<Assessment> assessmentList = new ArrayList<Assessment>();
        EligibleStudent eligStudent = eligStudentRepo.findByStudentIdAndState(studentId, state);
        if (eligStudent != null) {
            assessmentList = eligStudent.getAssessmentsAsList();
        }
        return assessmentList;
    }

    @Override
    public Set<Assessment> findAllAssessmentsByTenantsAndBeginWindow(final Collection<String> tenantsList,
            final DateTime date) {
        Set<Assessment> assessments = new HashSet<>();
        List<Assessment> found = assessmentRepo.findAllByTenantsAndBeginWindow(tenantsList, date);
        if (found != null) {
            for (Assessment assessment : found) {
                assessment.setTestWindow(filterTestWindowsForDate(assessment.getTestWindow(), date));
                if (assessment.getTestWindow().length != 0) {
                    if (eligStudentRepo.findAtLeastOneEligibleStudent(assessment.getId())){
                        assessments.add(assessment);
                    }
                }
            }
        }
        return assessments;
    }

    @Override
    public SearchResponse<Student> findStudents(final EligibleStudentSearchRequest searchRequest) {
        SearchResponse<EligibleStudent> eligibilityList = eligStudentRepo.search(searchRequest);
        List<Student> studentList = new ArrayList<Student>();
        for (EligibleStudent eligibleStudent : eligibilityList.getSearchResults()) {
            studentList.add(eligibleStudent.getStudent());
        }
        SearchResponse<Student> studentResposne = new SearchResponse<Student>(studentList, searchRequest,
                eligibilityList.getTotalCount());
        return studentResposne;
    }

    @Override
    public SearchResponse<EligibleStudent> findEligibleStudents(final EligibleStudentSearchRequest searchRequest) {
        return eligStudentRepo.search(searchRequest);
    }


    @Override
    public Map<ExplicitEligibility, DateTime> findAllEligibilityByStudentIdStateAbbreviationAndBeginWindow(
            final String studentId, final String stateAbbreviation, final DateTime date) {

        // Sorted Map based on ExplicitEligibility indices
        final Map<ExplicitEligibility, DateTime> eligibilityWindowMap = new TreeMap<>(
                new Comparator<ExplicitEligibility>() {
                    @Override
                    public int compare(final ExplicitEligibility elig1, final ExplicitEligibility elig2) {
                        String concat1 = elig1.getStudentId() + elig1.getTestName() + elig1.getTestVersion()
                                + elig1.getStateAbbreviation();
                        String concat2 = elig2.getStudentId() + elig2.getTestName() + elig2.getTestVersion()
                                + elig2.getStateAbbreviation();
                        return concat1.compareTo(concat2);
                    }
                });

        // 1. First Check if the student is eligible
        final EligibleStudent eligStudent = eligStudentRepo.findByStudentIdAndState(studentId, stateAbbreviation);

        if (eligStudent == null || eligStudent.getAssessments().isEmpty()) {
            return Collections.emptyMap();
        }

        // 2. For each Eligible Assessment, check if it has any window that are open as of date that is passed
        for (final Assessment assessment : eligStudent.getAssessments()) {

            // If a window is open
            TestWindow[] testWindowsOpen = filterTestWindowsForDate(assessment.getTestWindow(), date);
            if (testWindowsOpen.length > 0) {

                ExplicitEligibility eligibility = null;
                switch (assessment.getEligibilityType()) {
                case EXPLICIT:
                    // For all Forms
                    for (String testForm : assessment.getTestForm()) {
                        eligibility = new ExplicitEligibility();
                        eligibility.setSubject(assessment.getSubjectCode());
                        eligibility.setTestName(assessment.getTestName());
                        eligibility.setTestForm(testForm);
                        eligibility.setAssessmentMongoId(assessment.getId());
                        eligibilityWindowMap.put(eligibility, getEarliestWindowOpenDate(testWindowsOpen));
                    }
                    break;
                case IMPLICIT:
                    eligibility = new ExplicitEligibility();
                    eligibility.setSubject(assessment.getSubjectCode());
                    eligibility.setTestName(assessment.getTestName());
                    eligibility.setTestForm(null); // When Assessment is Implicit, Test Forms are not needed
                    eligibility.setAssessmentMongoId(assessment.getId());
                    eligibilityWindowMap.put(eligibility, getEarliestWindowOpenDate(testWindowsOpen));
                    break;
                }
            }
        }
        return eligibilityWindowMap;
    }

    private TestWindow[] filterTestWindowsForDate(final TestWindow[] testWindows, final DateTime date) {

        List<TestWindow> testWindowList = new ArrayList<>();
        for (TestWindow testWindow : testWindows) {

            DateTime beginDate = testWindow.getBeginWindow();
            DateTime endDate = testWindow.getEndWindow();

            boolean isOnOrAfterBeginDate = beginDate.isEqual(date) || beginDate.isBefore(date);
            boolean isOnOrBeforeEndDate = endDate.isEqual(date) || endDate.isAfter(date);
            boolean isBetweenBeginAndEndDates = isOnOrAfterBeginDate && isOnOrBeforeEndDate;

            if (isBetweenBeginAndEndDates) {
                testWindowList.add(testWindow);
            }
        }
        return testWindowList.toArray(new TestWindow[testWindowList.size()]);
    }

    private DateTime getEarliestWindowOpenDate(final TestWindow[] testWindows) {
        DateTime earliestStartDate = testWindows[0].getBeginWindow();

        for (int i = 1; i < testWindows.length; i++) {
            if (testWindows[i].getBeginWindow().isBefore(earliestStartDate)) {
                earliestStartDate = testWindows[i].getBeginWindow();
            }
        }
        return earliestStartDate;
    }

    @Override
    public void removeEligibleStudentCollection() {
        eligStudentRepo.dropCollection();
    }

}
