/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.delivery.testreg.service.impl;

import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.annotation.Resource;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.HierarchyLevel;
import org.opentestsystem.delivery.testreg.domain.Sb11Entity;
import org.opentestsystem.delivery.testreg.domain.Sb11NonEntity;
import org.opentestsystem.delivery.testreg.domain.Sb11SuperEntity;
import org.opentestsystem.delivery.testreg.domain.User;
import org.opentestsystem.delivery.testreg.domain.User.RoleAssociation;
import org.opentestsystem.delivery.testreg.domain.search.UserSearchRequest;
import org.opentestsystem.delivery.testreg.persistence.Sb11NonEntityRepository;
import org.opentestsystem.delivery.testreg.persistence.UserRepository;
import org.opentestsystem.delivery.testreg.service.Sb11EntityRepositoryService;
import org.opentestsystem.delivery.testreg.service.TestRegPersister;
import org.opentestsystem.delivery.testreg.service.TestRegistrationService;
import org.opentestsystem.delivery.testreg.service.UserService;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.search.domain.AbstractSearchRequest;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;

/**
 * Implementation of User Service.
 */
@Service("userService")
public class UserServiceImpl<T extends User> extends Sb11NonEntityServiceImpl<T> implements UserService {

    @Autowired
    private UserRepository userRepository;

    @Resource
    private Map<FormatType, Sb11NonEntityRepository<Sb11NonEntity>> nonEntityRepositoryMap;

    @Resource(name = "sb11NonEntityService")
    private TestRegistrationService<? extends Sb11NonEntity> sb11NonEntityService;

    @Resource(name = "sb11EntityService")
    private Sb11EntityRepositoryService sb11EntityService;
    
    @Autowired
    private TestRegPersister testRegPersister;
    
    @SuppressWarnings ("unchecked")
    @Override
    public T findById(final String pkId, final FormatType formatType) {
      return (T) performJoins(super.findById (pkId, formatType));
    }

    @Override
    // we are treating all updates and saves as upserts
    public T saveDomainObject(final T user) {
        List<T> list = Lists.newArrayList();
        if (user != null && StringUtils.isNotBlank(user.getId())) {
            // this is from the ui no need of upsert
            try {
                final Map<String, T> userMap = Maps.newHashMap();
                userMap.put(user.getEmail(), user);
                list = this.userRepository.save(userMap.values());
            } catch (final DuplicateKeyException dke) {
                final String alternateKey = user.getAlternateKey();
                throw new LocalizedException("entity.already.exists", new String[] { user.getFormatType().name(), alternateKey }, dke);
            }
        } else {
            list = saveDomainObjects(Collections.singletonList(user));
        }

        return list.size() > 0 ? list.get(0) : null;
    }

    @Override
    // we are treating all updates and saves as upserts
    public List<T> saveDomainObjects(final List<T> userList) {
        return upsertDomainObjects(userList);
    }

    @Override
    // we are treating all updates and saves as upserts
    public List<T> updateDomainObjects(final List<T> userList) {
        return upsertDomainObjects(userList);
    }

    private List<T> upsertDomainObjects(final List<T> userList) {
        final Map<String, T> userMap = combineDuplicateUsers(userList);
        mergeExistingRolesFromDB(userMap);
        setAssociatedEntityMongoIds(userMap);
        return this.userRepository.save(userMap.values());
    }

    // when given a list of users to act on we should combine duplicates such that
    // we combine all role associations (other differing attributes might get munged)
    private Map<String, T> combineDuplicateUsers(final List<T> users) {
      final Map<String, T> userMap = Maps.newHashMap();
        for (final T user : users) {
            if (!userMap.containsKey(user.getEmail().toLowerCase ())) {
                userMap.put(user.getEmail().toLowerCase (), user);
            } else {
                final T userInMap = userMap.get(user.getEmail().toLowerCase ());
                userInMap.addRoleAssociations(user.getRoleAssociations());
                userInMap.setFirstName(user.getFirstName());
                userInMap.setLastName(user.getLastName());
                userInMap.setPhone(user.getPhone());
            }
        }
        return userMap;
    }

    @SuppressWarnings("unchecked")
    @Override
    public void deleteDomainObjects(final List<T> domainObjList) {
        // User is not deleted instead roles are deleted
        if (!CollectionUtils.isEmpty(domainObjList)) {
            for (final T domainObj : domainObjList) {
                final User dbUser = findUserByCustomAlternateKey(domainObj);
                if (dbUser != null) {
                    final RoleAssociation uploadedRole = domainObj.getRoleAssociations().get(0);
                    for (final RoleAssociation role : dbUser.getRoleAssociations()) {
                        if (uploadedRole.equals(role)) {
                            dbUser.removeRoleAssociation(uploadedRole);
                            break;
                        }
                    }
                    updateDomainObject((T) dbUser);
                    if(dbUser.getRoleAssociations().size() == 0){
                      sb11NonEntityService.deleteDomainObject (dbUser.getId(), User.FORMAT_TYPE);
                  }
                }
            }
        }
    }

    private void mergeExistingRolesFromDB(final Map<String, T> userMap) {
        for (final T userInMap : userMap.values()) {
            final User dbUser = findByAlternateKey(userInMap.createAlternateKeySearchRequest(), User.class);
            if (dbUser != null) {
                performJoins(dbUser);
                userInMap.addRoleAssociations(dbUser.getRoleAssociations());
                userInMap.setId(dbUser.getId());
            }
        }
    }

    // Note: Building custom search request using exact email match (rather than userObj.getAlternateKey() which uses REGEX)
    private User findUserByCustomAlternateKey(final User user) {
        final Map<String, String[]> params = new HashMap<>();
        params.put(UserSearchRequest.SEARCH_KEY_EMAIL_EXACT, new String[] { user.getEmail() });
        final AbstractSearchRequest searchRequest = new UserSearchRequest(params);
        return performJoins(super.findByAlternateKey(searchRequest, User.class));
    }

    @SuppressWarnings("unchecked")
    private void setAssociatedEntityMongoIds(final Map<String, T> userMap) {
        final Map<String, Sb11Entity> sb11EntityMap = new HashMap<>();
        for (final User userInMap : userMap.values()) {
            for (final RoleAssociation role : userInMap.getRoleAssociations()) {
                if (role.getAssociatedEntityMongoId() == null) {
                    Sb11Entity associatedEntity;
                    if (Sb11SuperEntity.class.isAssignableFrom(role.getLevel().getEntityClass())) {
                        final String key = role.getAssociatedEntityId() + "-" + role.getLevel().getEntityClass().getSimpleName();
                        if (!sb11EntityMap.containsKey(key)) {
                            associatedEntity = this.sb11EntityService.findByEntityId(role.getAssociatedEntityId(), (Class<Sb11SuperEntity>) role.getLevel().getEntityClass());
                            sb11EntityMap.put(key, associatedEntity);
                        } else {
                            associatedEntity = sb11EntityMap.get(key);
                        }
                    } else {
                        final String stateAbbreviation = role.getStateAbbreviation();
                        final String key = role.getAssociatedEntityId() + "-" + stateAbbreviation + "-" + role.getLevel().getEntityClass().getSimpleName();
                        if (!sb11EntityMap.containsKey(key)) {
                            associatedEntity = this.sb11EntityService.findByEntityIdAndStateAbbreviation(role.getAssociatedEntityId(), stateAbbreviation, role.getLevel().getEntityClass());
                            sb11EntityMap.put(key, associatedEntity);
                        } else {
                            associatedEntity = sb11EntityMap.get(key);
                        }
                    }
                    if (associatedEntity != null) {
                        role.setAssociatedEntityMongoId(associatedEntity.getId());
                    }
                }
            }
        }
    }
    
    @Override
    public SearchResponse<T> searchDomainObjects(final AbstractSearchRequest searchRequest,final FormatType formatType) {
        return performJoins(super.searchDomainObjects(searchRequest, formatType));
    }

    @Override
    public List<User> findAllByRoleAssociationLevel(final String associatedEntityId, final HierarchyLevel level) {
        return performJoins(this.userRepository.findAllByRoleAssociationLevel(associatedEntityId, level));
    }

    @Override
    public List<User> findUserByLevel(final String associatedEntityId, final String stateAbbreviation, final HierarchyLevel level) {
        return performJoins(this.userRepository.findAllByRoleAssociationLevel(associatedEntityId, stateAbbreviation, level));
    }

    @Override
    public List<User> findUserByLevel(final String level) {
        return performJoins(this.userRepository.findAllByRoleAssociationLevel(level));
    }

    @Override
    public User findByEmail(final String email) {
        return performJoins(this.userRepository.findByEmail(email));
    }

    @Override
    public List<User> findUsersByRoleName(final String roleName) {
        return performJoins(this.userRepository.findAllByRoleName(roleName));
    }
    
    @SuppressWarnings ("unchecked")
    protected SearchResponse<T> performJoins(SearchResponse<T> searchResponse) {
      if (searchResponse == null)
        return null;
      performJoins((List<User>) searchResponse.getSearchResults());
      return searchResponse;
    }

    protected List<User> performJoins(List<User> users) {
      if (users == null)
        return null;
      for (User user : users)
        performJoins(user);
      return users;
    }

    protected User performJoins(User user) {
      if (user == null)
        return null;
      // right now we are only interested in associated entity information.
      // but there could be others in the future. this is a placeholder for
      // that.
      return updateUserWithEntityInformation(user);
    }

    private User updateUserWithEntityInformation(User u) {
      if (u == null)
        return null;
      // Update the user with any entity information here e.g.
      // associated entity name.
      if(u.getRoleAssociations() != null) {
        List<User.RoleAssociation> roles = u.getRoleAssociations();
        if (roles != null) {
          for (User.RoleAssociation role : roles) {
            if(role.getAssociatedEntityMongoId() != null) {
              Sb11Entity resEntity = testRegPersister.findById(role.getAssociatedEntityMongoId(), FormatType.valueOf(role.getLevel().toString()));
              role.setAssociatedEntityName (resEntity.getEntityName());
            }
          }
        }
      }
      return u;
    }
}
