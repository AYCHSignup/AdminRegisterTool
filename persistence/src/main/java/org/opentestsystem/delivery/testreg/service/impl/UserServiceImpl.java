/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.delivery.testreg.service.impl;

import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.annotation.Resource;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.HierarchyLevel;
import org.opentestsystem.delivery.testreg.domain.Sb11Entity;
import org.opentestsystem.delivery.testreg.domain.Sb11NonEntity;
import org.opentestsystem.delivery.testreg.domain.Sb11SuperEntity;
import org.opentestsystem.delivery.testreg.domain.User;
import org.opentestsystem.delivery.testreg.domain.User.RoleAssociation;
import org.opentestsystem.delivery.testreg.domain.search.UserSearchRequest;
import org.opentestsystem.delivery.testreg.persistence.Sb11NonEntityRepository;
import org.opentestsystem.delivery.testreg.persistence.UserRepository;
import org.opentestsystem.delivery.testreg.service.Sb11EntityRepositoryService;
import org.opentestsystem.delivery.testreg.service.TestRegistrationService;
import org.opentestsystem.delivery.testreg.service.UserService;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.search.domain.AbstractSearchRequest;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;

/**
 * Implementation of User Service.
 */
@Service("userService")
public class UserServiceImpl<T extends User> extends Sb11NonEntityServiceImpl<T> implements UserService {

    @Autowired
    private UserRepository userRepository;

    @Resource
    private Map<FormatType, Sb11NonEntityRepository<Sb11NonEntity>> nonEntityRepositoryMap;

    @Resource(name = "sb11NonEntityService")
    private TestRegistrationService<? extends Sb11NonEntity> sb11NonEntityService;

    @Resource(name = "sb11EntityService")
    private Sb11EntityRepositoryService sb11EntityService;

    @Override
    // we are treating all updates and saves as upserts
    public T saveDomainObject(final T user) {
        List<T> list = Lists.newArrayList();
        if (user != null && StringUtils.isNotBlank(user.getId())) {
            // this is from the ui no need of upsert
            try {
                final Map<String, T> userMap = Maps.newHashMap();
                userMap.put(user.getEmail(), user);
                list = this.userRepository.save(userMap.values());
            } catch (final DuplicateKeyException dke) {
                final String alternateKey = user.getAlternateKey();
                throw new LocalizedException("entity.already.exists", new String[] { user.getFormatType().name(), alternateKey }, dke);
            }
        } else {
            list = saveDomainObjects(Collections.singletonList(user));
        }

        return list.size() > 0 ? list.get(0) : null;
    }

    @Override
    // we are treating all updates and saves as upserts
    public List<T> saveDomainObjects(final List<T> userList) {
        return upsertDomainObjects(userList);
    }

    @Override
    // we are treating all updates and saves as upserts
    public List<T> updateDomainObjects(final List<T> userList) {
        return upsertDomainObjects(userList);
    }

    private List<T> upsertDomainObjects(final List<T> userList) {
        final Map<String, T> userMap = combineDuplicateUsers(userList);
        mergeExistingRolesFromDB(userMap);
        setAssociatedEntityMongoIds(userMap);
        return this.userRepository.save(userMap.values());
    }

    // when given a list of users to act on we should combine duplicates such that
    // we combine all role associations (other differing attributes might get munged)
    private Map<String, T> combineDuplicateUsers(final List<T> users) {
        final Map<String, T> userMap = Maps.newHashMap();
        for (final T user : users) {
            if (!userMap.containsKey(user.getEmail())) {
                userMap.put(user.getEmail(), user);
            } else {
                final T userInMap = userMap.get(user.getEmail());
                userInMap.addRoleAssociations(user.getRoleAssociations());
                userInMap.setFirstName(user.getFirstName());
                userInMap.setLastName(user.getLastName());
                userInMap.setPhone(user.getPhone());
            }
        }
        return userMap;
    }

    @SuppressWarnings("unchecked")
    @Override
    public void deleteDomainObjects(final List<T> domainObjList) {
        // User is not deleted instead roles are deleted
        if (!CollectionUtils.isEmpty(domainObjList)) {
            for (final T domainObj : domainObjList) {
                final User dbUser = findUserByCustomAlternateKey(domainObj);
                if (dbUser != null) {
                    final RoleAssociation uploadedRole = domainObj.getRoleAssociations().get(0);
                    for (final RoleAssociation role : dbUser.getRoleAssociations()) {
                        if (uploadedRole.equals(role)) {
                            dbUser.removeRoleAssociation(uploadedRole);
                            break;
                        }
                    }
                    updateDomainObject((T) dbUser);
                }
            }
        }
    }

    private void mergeExistingRolesFromDB(final Map<String, T> userMap) {
        for (final T userInMap : userMap.values()) {
            final User dbUser = findByAlternateKey(userInMap.createAlternateKeySearchRequest(), User.class);
            if (dbUser != null) {
                userInMap.addRoleAssociations(dbUser.getRoleAssociations());
                userInMap.setId(dbUser.getId());
            }
        }
    }

    // Note: Building custom search request using exact email match (rather than userObj.getAlternateKey() which uses REGEX)
    private User findUserByCustomAlternateKey(final User user) {
        final Map<String, String[]> params = new HashMap<>();
        params.put(UserSearchRequest.SEARCH_KEY_EMAIL_EXACT, new String[] { user.getEmail() });
        final AbstractSearchRequest searchRequest = new UserSearchRequest(params);
        return super.findByAlternateKey(searchRequest, User.class);
    }

    @SuppressWarnings("unchecked")
    private void setAssociatedEntityMongoIds(final Map<String, T> userMap) {
        final Map<String, Sb11Entity> sb11EntityMap = new HashMap<>();
        for (final User userInMap : userMap.values()) {
            for (final RoleAssociation role : userInMap.getRoleAssociations()) {
                if (role.getAssociatedEntityMongoId() == null) {
                    Sb11Entity associatedEntity;
                    if (Sb11SuperEntity.class.isAssignableFrom(role.getLevel().getEntityClass())) {
                        final String key = role.getAssociatedEntityId() + "-" + role.getLevel().getEntityClass().getSimpleName();
                        if (!sb11EntityMap.containsKey(key)) {
                            associatedEntity = this.sb11EntityService.findByEntityId(role.getAssociatedEntityId(), (Class<Sb11SuperEntity>) role.getLevel().getEntityClass());
                            sb11EntityMap.put(key, associatedEntity);
                        } else {
                            associatedEntity = sb11EntityMap.get(key);
                        }
                    } else {
                        final String stateAbbreviation = role.getStateAbbreviation();
                        final String key = role.getAssociatedEntityId() + "-" + stateAbbreviation + "-" + role.getLevel().getEntityClass().getSimpleName();
                        if (!sb11EntityMap.containsKey(key)) {
                            associatedEntity = this.sb11EntityService.findByEntityIdAndStateAbbreviation(role.getAssociatedEntityId(), stateAbbreviation, role.getLevel().getEntityClass());
                            sb11EntityMap.put(key, associatedEntity);
                        } else {
                            associatedEntity = sb11EntityMap.get(key);
                        }
                    }
                    if (associatedEntity != null) {
                        role.setAssociatedEntityMongoId(associatedEntity.getId());
                    }
                }
            }
        }
    }

    @Override
    public List<User> findAllByRoleAssociationLevel(final String associatedEntityId, final HierarchyLevel level) {
        return this.userRepository.findAllByRoleAssociationLevel(associatedEntityId, level);
    }

    @Override
    public List<User> findUserByLevel(final String associatedEntityId, final String stateAbbreviation, final HierarchyLevel level) {
        return this.userRepository.findAllByRoleAssociationLevel(associatedEntityId, stateAbbreviation, level);
    }

    @Override
    public List<User> findUserByLevel(final String level) {
        return this.userRepository.findAllByRoleAssociationLevel(level);
    }

    @Override
    public User findByEmail(final String email) {
        return this.userRepository.findByEmail(email);
    }

    @Override
    public List<User> findUsersByRoleName(final String roleName) {
        return this.userRepository.findAllByRoleName(roleName);
    }

}