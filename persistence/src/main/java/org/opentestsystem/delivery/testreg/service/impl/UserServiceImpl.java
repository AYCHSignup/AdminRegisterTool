/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.delivery.testreg.service.impl;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.annotation.Resource;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.delivery.testadmin.domain.Proctor;
import org.opentestsystem.delivery.testadmin.domain.ProctorRole;
import org.opentestsystem.delivery.testadmin.service.ProctorRoleService;
import org.opentestsystem.delivery.testadmin.service.ProctorService;
import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.HierarchyLevel;
import org.opentestsystem.delivery.testreg.domain.Sb11Entity;
import org.opentestsystem.delivery.testreg.domain.Sb11NonEntity;
import org.opentestsystem.delivery.testreg.domain.Sb11SuperEntity;
import org.opentestsystem.delivery.testreg.domain.User;
import org.opentestsystem.delivery.testreg.domain.User.RoleAssociation;
import org.opentestsystem.delivery.testreg.domain.search.UserSearchRequest;
import org.opentestsystem.delivery.testreg.persistence.Sb11NonEntityRepository;
import org.opentestsystem.delivery.testreg.persistence.UserRepository;
import org.opentestsystem.delivery.testreg.persistence.UserSearchRepository;
import org.opentestsystem.delivery.testreg.persistence.UserServiceHelper;
import org.opentestsystem.delivery.testreg.service.Sb11EntityRepositoryService;
import org.opentestsystem.delivery.testreg.service.TestRegPersister;
import org.opentestsystem.delivery.testreg.service.TestRegistrationService;
import org.opentestsystem.delivery.testreg.service.UserService;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.progman.client.domain.TenantType;
import org.opentestsystem.shared.search.domain.AbstractSearchRequest;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.opentestsystem.shared.security.domain.SbacUser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;

/**
 * Implementation of User Service.
 */
@Service("userService")
public class UserServiceImpl<T extends User> extends Sb11NonEntityServiceImpl<T> implements UserService {
    
    @Resource(name = "sb11NonEntityService")
    private TestRegistrationService<? extends Sb11NonEntity> sb11NonEntityService;

    @Resource(name = "sb11EntityService")
    private Sb11EntityRepositoryService sb11EntityService;
    
    @Autowired
    private ProctorRoleService proctorRoleService;
    
    @Autowired
    private ProctorService proctorService;
    
    @Autowired
    private TestRegPersister testRegPersister;
    
    @Autowired
    private org.opentestsystem.shared.security.service.UserService userServiceSecurity;
    
    @Autowired
    private UserRepository userRepository;

    @Autowired
    private UserSearchRepository userSearchRepository;
    
    @Resource
    private Map<FormatType, Sb11NonEntityRepository<Sb11NonEntity>> nonEntityRepositoryMap;
    
    @SuppressWarnings ("unchecked")
    @Override
    public T findById(final String pkId, final FormatType formatType) {
      return (T) performJoins(super.findById (pkId, formatType));
    }

    @Override
    // we are treating all updates and saves as upserts
    public T saveDomainObject(final T user) {
        List<T> list = Lists.newArrayList();
        if (user != null && StringUtils.isNotBlank(user.getId())) {
            // this is from the ui no need of upsert
            try {
                final Map<String, T> userMap = Maps.newHashMap();
                userMap.put(user.getEmail(), user);
                
                list = this.userRepository.save(userMap.values());
                if(list != null){
                  modifyProctors(user);
                }  
            } catch (final DuplicateKeyException dke) {
                final String alternateKey = user.getAlternateKey();
                throw new LocalizedException("entity.already.exists", new String[] { user.getFormatType().name(), alternateKey }, dke);
            }
        } else {
            list = saveDomainObjects(Collections.singletonList(user));
         }
        return list.size() > 0 ? list.get(0) : null;
    }


    @Override
    // we are treating all updates and saves as upserts
    public List<T> saveDomainObjects(final List<T> userList) {
        return upsertDomainObjects(userList);
    }

    @Override
    // we are treating all updates and saves as upserts
    public List<T> updateDomainObjects(final List<T> userList) {
        return upsertDomainObjects(userList);
    }

    private List<T> upsertDomainObjects(final List<T> userList) {
      
        final Map<String, T> userMap = combineDuplicateUsers(userList);
        mergeExistingRolesFromDB(userMap);
        setAssociatedEntityMongoIds(userMap);
        this.userSearchRepository.clearAccessibleUsersCache();
        List<T> savedUsersList = this.userRepository.save(userMap.values());
        
        for(T user: savedUsersList){
          modifyProctors(user);
        }
        return savedUsersList;
    }

    // when given a list of users to act on we should combine duplicates such that
    // we combine all role associations (other differing attributes might get munged)
    private Map<String, T> combineDuplicateUsers(final List<T> users) {
      final Map<String, T> userMap = Maps.newHashMap();
        for (final T user : users) {
            if (!userMap.containsKey(user.getEmail().toLowerCase ())) {
                userMap.put(user.getEmail().toLowerCase (), user);
            } else {
                final T userInMap = userMap.get(user.getEmail().toLowerCase ());
                userInMap.addRoleAssociations(user.getRoleAssociations());
                userInMap.setFirstName(user.getFirstName());
                userInMap.setLastName(user.getLastName());
                userInMap.setPhone(user.getPhone());
            }
        }
        return userMap;
    }
    
    /**
     * Deleting User/User.Role.
     *
     * @param pkId                  mongoId  
     * @param accessibleEntityIds   Set of all entities( mongoIds ) that current user has access to
     * @param formatType            formatType of entity( User )
     *  
     */
    
    @Override
    public void deleteDomainObject(final String pkId, final FormatType formatType, Set<String> accessibleIds) {
      // User performs delete action from UI then 
      // we check if user has roles outside logged-in-user jurisdiction
      // true will only modify the roles of existing dbUser
      // otherwise delete corresponding user
      User modifiedUser = this.findById (pkId, formatType, accessibleIds);
      User dbUser = findUserByCustomAlternateKey(modifiedUser);
      List<User.RoleAssociation> dbRoles = dbUser.getRoleAssociations();
      if(modifiedUser != null){
        if(modifiedUser.getHasRolesOutside ()){
          dbRoles.removeAll (modifiedUser.getRoleAssociations ());
          // checking user.Roles size greater than Zero or not 
          // yes will perform saving of modified user.roles record 
          // otherwise delete user record
          if(dbRoles.size () > 0){
            this.userRepository.save (dbUser) ;
            this.userSearchRepository.clearAccessibleUsersCache();
          }else{
            this.deleteDomainObject (pkId, formatType);
          }
        }else{
          this.deleteDomainObject (pkId, formatType);
        }
      }
    }
    
    @Override
    public void deleteDomainObject(final String pkId, final FormatType formatType) {
      super.deleteDomainObject(pkId, formatType);
      Proctor dbProctor = proctorService.findProctorByUserId (pkId);
      if(dbProctor != null){
        proctorService.removeProctor (dbProctor);
      }
      this.userSearchRepository.clearAccessibleUsersCache();
    }

    @SuppressWarnings("unchecked")
    @Override
    public void deleteDomainObjects(final List<T> domainObjList) {
        // User is not deleted instead roles are deleted
        if (!CollectionUtils.isEmpty(domainObjList)) {
            for (final T domainObj : domainObjList) {
                final User dbUser = findUserByCustomAlternateKey(domainObj);
                if (dbUser != null) {
                    final RoleAssociation uploadedRole = domainObj.getRoleAssociations().get(0);
                    for (final RoleAssociation role : dbUser.getRoleAssociations()) {
                        if (uploadedRole.equals(role)) {
                            dbUser.removeRoleAssociation(uploadedRole);
                            break;
                        }
                    }
                    updateDomainObject((T) dbUser);
                    modifyProctors(dbUser);
                    if(dbUser.getRoleAssociations().size() == 0){
                      sb11NonEntityService.deleteDomainObject (dbUser.getId(), User.FORMAT_TYPE);
                  }
                }
            }
            this.userSearchRepository.clearAccessibleUsersCache();
        }
    }

    private void mergeExistingRolesFromDB(final Map<String, T> userMap) {
        for (final T userInMap : userMap.values()) {
            final User dbUser = findByAlternateKey(userInMap.createAlternateKeySearchRequest(), User.class);
            if (dbUser != null) {
                performJoins(dbUser);
                userInMap.addRoleAssociations(dbUser.getRoleAssociations());
                userInMap.setId(dbUser.getId());
            }
        }
    }

    // Note: Building custom search request using exact email match (rather than userObj.getAlternateKey() which uses REGEX)
    private User findUserByCustomAlternateKey(final User user) {
        final Map<String, String[]> params = new HashMap<>();
        params.put(UserSearchRequest.SEARCH_KEY_EMAIL_EXACT, new String[] { user.getEmail() });
        final AbstractSearchRequest searchRequest = new UserSearchRequest(params);
        return performJoins(super.findByAlternateKey(searchRequest, User.class));
    }

    @SuppressWarnings("unchecked")
    private void setAssociatedEntityMongoIds(final Map<String, T> userMap) {
        final Map<String, Sb11Entity> sb11EntityMap = new HashMap<>();
        for (final User userInMap : userMap.values()) {
            for (final RoleAssociation role : userInMap.getRoleAssociations()) {
                if (role.getAssociatedEntityMongoId() == null) {
                    Sb11Entity associatedEntity;
                    if (Sb11SuperEntity.class.isAssignableFrom(role.getLevel().getEntityClass())) {
                        final String key = role.getAssociatedEntityId() + "-" + role.getLevel().getEntityClass().getSimpleName();
                        if (!sb11EntityMap.containsKey(key)) {
                            associatedEntity = this.sb11EntityService.findByEntityId(role.getAssociatedEntityId(), (Class<Sb11SuperEntity>) role.getLevel().getEntityClass());
                            sb11EntityMap.put(key, associatedEntity);
                        } else {
                            associatedEntity = sb11EntityMap.get(key);
                        }
                    } else {
                        final String stateAbbreviation = role.getStateAbbreviation();
                        final String key = role.getAssociatedEntityId() + "-" + stateAbbreviation + "-" + role.getLevel().getEntityClass().getSimpleName();
                        if (!sb11EntityMap.containsKey(key)) {
                            associatedEntity = this.sb11EntityService.findByEntityIdAndStateAbbreviation(role.getAssociatedEntityId(), stateAbbreviation, role.getLevel().getEntityClass());
                            sb11EntityMap.put(key, associatedEntity);
                        } else {
                            associatedEntity = sb11EntityMap.get(key);
                        }
                    }
                    if (associatedEntity != null) {
                        role.setAssociatedEntityMongoId(associatedEntity.getId());
                    }
                }
            }
        }
    }
    
    @SuppressWarnings("unchecked")
	  @Override
    public SearchResponse<T> searchDomainObjects(final AbstractSearchRequest searchRequest,final FormatType formatType) {
        return performJoins((SearchResponse<T>) this.userSearchRepository.search(searchRequest), searchRequest);
    }

    @Override
    public List<User> findAllByRoleAssociationLevel(final String associatedEntityId, final HierarchyLevel level) {
        return performJoins(this.userRepository.findAllByRoleAssociationLevel(associatedEntityId, level));
    }

    @Override
    public List<User> findUserByLevel(final String associatedEntityId, final String stateAbbreviation, final HierarchyLevel level) {
        return performJoins(this.userRepository.findAllByRoleAssociationLevel(associatedEntityId, stateAbbreviation, level));
    }

    @Override
    public List<User> findUserByLevel(final String level) {
        return performJoins(this.userRepository.findAllByRoleAssociationLevel(level));
    }

    @Override
    public User findByEmail(final String email) {
      return performJoins(this.userRepository.findByEmail(email));
    }

    @Override
    public List<User> findUsersByRoleName(final String roleName) {
        return performJoins(this.userRepository.findAllByRoleName(roleName));
    }
    
    /**
     * Getting logged-in-User .
     *  
     * @param accessibleEntityIds   Set of all entities( mongoIds ) that current user has access to
     * @return                      User( logged-in-user ) 
     */
    
    @Override
    // getting logged-in-user 
    public User getLoggedInUser(Set<String> accessibleIds) {
      SbacUser sbacUser = userServiceSecurity.getCurrentUser();    
      User user = this.findByEmail (sbacUser.getEmail ());
      modifyUserVisibilityRoles(user, accessibleIds);
      return user;
    }
    
    /**
     * Finding User.
     *
     * @param pkId                  mongoId  
     * @param accessibleEntityIds   Set of all entities( mongoIds ) that current user has access to
     * @param formatType            formatType of entity( User )
     * @return                      User 
     */
    
    @Override
    public User findById(final String pkId, final FormatType formatType, Set<String> accessibleIds) {
      User user = performJoins(super.findById (pkId, formatType));
      modifyUserVisibilityRoles(user, accessibleIds);
      return user;
    }
    
    @SuppressWarnings ("unchecked")
    protected SearchResponse<T> performJoins(SearchResponse<T> searchResponse, AbstractSearchRequest abstractSearchRequest) {
      if (searchResponse == null)
        return null;
      List<User> users = performJoins((List<User>) searchResponse.getSearchResults());
      UserSearchRequest userSearchRequest = (UserSearchRequest) abstractSearchRequest;
      modifyUsers(users, userSearchRequest.getAccessibleEntityIds ());
      return searchResponse;
    }

    protected List<User> performJoins(List<User> users) {
      if (users == null)
        return null;
      for (User user : users)
        performJoins(user);
      return users;
    }

    protected User performJoins(User user) {
      if (user == null)
        return null;
      // right now we are only interested in associated entity information.
      // but there could be others in the future. this is a placeholder for
      // that.
      return updateUserWithEntityInformation(user);
    }

    private User updateUserWithEntityInformation(User u) {
      if (u == null)
        return null;
      // Update the user with any entity information here e.g.
      // associated entity name.
      if(u.getRoleAssociations() != null) {
        List<User.RoleAssociation> roles = u.getRoleAssociations();
        if (roles != null) {
          for (User.RoleAssociation role : roles) {
            if(role.getAssociatedEntityMongoId() != null) {
              Sb11Entity resEntity = testRegPersister.findById(role.getAssociatedEntityMongoId(), FormatType.valueOf(role.getLevel().toString()));
              if(resEntity != null)
              role.setAssociatedEntityName (resEntity.getEntityName());
            }
          }
        }
      }
      return u;
    }
    
    private void modifyProctors(User user){
      if(user != null){
        List<RoleAssociation> userRoles = user.getRoleAssociations ();
        List<ProctorRole> proctorRoles = proctorRoleService.getAllProctorRolesAvailable ();
        List<String> userRoleNames = new ArrayList<String> ();
        List<String> proctorRoleNames = new ArrayList<String>();
        Proctor proctor = null;
        proctor = new Proctor ();
        proctor.setUser (user);

        for(RoleAssociation role : userRoles)
          userRoleNames.add (role.getRole ());

        for(ProctorRole procRole : proctorRoles)
          proctorRoleNames.add (procRole.getName ());
        Proctor dbProctor = proctorService.findProctorByUserId (user.getId ());
        for (String proctorRoleName : proctorRoleNames) {
          if (userRoleNames.contains (proctorRoleName)){
            if(dbProctor == null){
              proctorService.saveProctor (proctor);
              break;
            } else {
              dbProctor.setUser (user);
              proctorService.saveProctor (dbProctor);
              break;
            }

          } else {
            if(dbProctor != null){
              proctorService.removeProctor (dbProctor);
              break;
            }

          }
        }
      }
    }
    
    /**
     * Getting logged-in-user Sb11Entity.
     *
     * @return   Sb11Entity 
     */
    
    private Sb11Entity getLoginUserEntity(){
      SbacUser sbacUser = userServiceSecurity.getCurrentUser();
      User user = null;
      String sbacEntityId = null;
      if(sbacUser != null){
        String username = sbacUser.getUsername ();
        user = userRepository.findByEmail(username);
      } 
      List<String> sbacEntityIds =  UserServiceHelper.getLoginUserEntityId(sbacUser);
      if(sbacEntityIds != null){
        sbacEntityId = sbacEntityIds.get (0);
      }
      TenantType sbacEntityLevel =  UserServiceHelper.getLoginUserRoleLevel(sbacUser);
      Sb11Entity resEntity = null;
      if(user != null && sbacEntityId != null) {
        List<User.RoleAssociation> roles = user.getRoleAssociations();
        for (User.RoleAssociation role : roles) {
          if(role.getAssociatedEntityId ().equalsIgnoreCase (sbacEntityId) && role.getAssociatedEntityMongoId() != null){
            resEntity = testRegPersister.findById(role.getAssociatedEntityMongoId(), FormatType.valueOf(role.getLevel().toString()));
            break;
          }  
        }
      }else if(user == null && sbacEntityId != null && sbacEntityLevel != null){
          List<? extends Sb11Entity> entities = sb11EntityService.findAllByEntityId (sbacEntityId,  UserServiceHelper.convertTenantTypeToClass(sbacEntityLevel));
          resEntity = entities.get (0);
      }
      return resEntity;
    }
    
    private void modifyUsers(List<User> users, Set<String> accessibleEntityIds){
      if (users != null){ 
        for(User user : users){
          modifyUserVisibilityRoles(user,accessibleEntityIds);
        }
      }
    }
    
    /**
     * Modify the user roles based on logged-in user( list of allowed associatedEntityIds ).
     *
     * @param user                  userEntity which we need to modify 
     * @param accessibleEntityIds   Set of all entities( mongoIds ) that current user has access to
     * 
     */
    private void modifyUserVisibilityRoles(User user, Set<String> accessibleEntityIds){
      if(user != null){
        List<RoleAssociation> userRoles = user.getRoleAssociations ();
        SbacUser sbacUser = userServiceSecurity.getCurrentUser();
        TenantType level =  UserServiceHelper.getLoginUserRoleLevel(sbacUser);
        // checking if logged-in-user role.level is client or not
        // true we will not perform roles-modification on user
        // otherwise we will perform roles-modification
        if(level != null && !level.toString ().equalsIgnoreCase (FormatType.CLIENT.toString ())){
          Sb11Entity entity =  getLoginUserEntity();
          if(entity != null){
            List<String> allowedEntities = getAllowableEntityIds(entity,accessibleEntityIds);
            List<RoleAssociation> modifiedUserRoles = new ArrayList<RoleAssociation>();
            for(RoleAssociation role : userRoles){
              if(allowedEntities.contains (role.getAssociatedEntityId ())){
                modifiedUserRoles.add (role);
              }
            }
            // Checking user being edited has roles outside the logged-in user’s jurisdiction or not 
            if(userRoles.size () > modifiedUserRoles.size ()){
              user.setHasRolesOutside (true);
            }else{
              user.setHasRolesOutside (false);
            }
            user.setRoleAssociations (modifiedUserRoles);
          }
        }else if(level != null && level.toString ().equalsIgnoreCase (FormatType.CLIENT.toString ())){
          user.setHasRolesOutside (false);
        }
      }
    }
    
    /**
     * Getting list of all allowed associatedEntityIds for logged-in user.
     *
     * @param entity                Sb11Entity of logged-in user
     * @param accessibleEntityIds   Set of all entities( mongoIds ) that current user has access to
     * @return                      list of all accessible associatedEntityIds current user has access 
     */
    private List<String> getAllowableEntityIds(Sb11Entity entity, Set<String> accessibleEntityIds){
      // getting list of allowed associatedEntityIds for logged-in user
      List<String> allowedEntities = new ArrayList<String>();
      List<TenantType> entityLevels = UserServiceHelper.getOrderedSb11EntityTenantTypes (entity.getTenantType ());
      for(TenantType type : entityLevels){
          List<? extends Sb11Entity> entities = sb11EntityService.findById (accessibleEntityIds, UserServiceHelper.convertTenantTypeToClass(type));
          if(entities != null){
            for(Sb11Entity temp : entities){
              allowedEntities.add (temp.getEntityId ());
            }
          }
      }
      return allowedEntities;
    }

}
