/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.delivery.testreg.service.impl;

import org.apache.commons.collections.CollectionUtils;
import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.HierarchyLevel;
import org.opentestsystem.delivery.testreg.domain.Sb11Entity;
import org.opentestsystem.delivery.testreg.domain.Sb11NonEntity;
import org.opentestsystem.delivery.testreg.domain.Sb11SuperEntity;
import org.opentestsystem.delivery.testreg.domain.User;
import org.opentestsystem.delivery.testreg.domain.User.RoleAssociation;
import org.opentestsystem.delivery.testreg.domain.search.UserSearchRequest;
import org.opentestsystem.delivery.testreg.persistence.Sb11NonEntityRepository;
import org.opentestsystem.delivery.testreg.persistence.UserRepository;
import org.opentestsystem.delivery.testreg.service.Sb11EntityRepositoryService;
import org.opentestsystem.delivery.testreg.service.TestRegistrationService;
import org.opentestsystem.delivery.testreg.service.UserService;
import org.opentestsystem.shared.search.domain.AbstractSearchRequest;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Implementation of User Service.
 */
@Service("userService")
public class UserServiceImpl<T extends User> extends Sb11NonEntityServiceImpl<T> implements UserService {

    @Autowired
    private UserRepository userRepository;

    @Resource
    private Map<FormatType, Sb11NonEntityRepository<Sb11NonEntity>> nonEntityRepositoryMap;

    @Resource(name = "sb11NonEntityService")
    private TestRegistrationService<? extends Sb11NonEntity> sb11NonEntityService;

    @Resource(name = "sb11EntityService")
    private Sb11EntityRepositoryService sb11EntityService;

    /**
     * {@inheritDoc}
     */
    @Override
    public List<T> saveDomainObjects(List<T> domainObjList) {
        List<T> savedObjects = new ArrayList<T>();
        Set<T> userSet = new HashSet<T>();

        if (!CollectionUtils.isEmpty(domainObjList)) {
            userSet.addAll(domainObjList);

            for (T domainObj : userSet) {
                domainObj = mergeRoleAssociations(domainObj, domainObjList);
                mergeExistingRolesFromDB(domainObj);
                setAssociatedEntityMongoId(domainObj);
                savedObjects.add(saveDomainObject(domainObj));
            }
        }
        return savedObjects;
    }

    @Override
    public T saveDomainObject(T domainObj) {
        // for non-UI entry points we need to squash duplicates here...
        List<RoleAssociation> distinctRoleAssociations = new ArrayList<>(new LinkedHashSet<>(domainObj.getRoleAssociations()));
        domainObj.setRoleAssociations(distinctRoleAssociations);
        return super.saveDomainObject(domainObj);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<T> updateDomainObjects(List<T> domainObjList) {
        List<T> updatedObjects = new ArrayList<T>();
        Set<T> userSet = new HashSet<T>();

        if (!CollectionUtils.isEmpty(domainObjList)) {
            userSet.addAll(domainObjList);

            for (T domainObj : userSet) {
                domainObj = mergeRoleAssociations(domainObj, domainObjList);
                mergeExistingRolesFromDB(domainObj);
                setAssociatedEntityMongoId(domainObj);
                updatedObjects.add(updateDomainObject(domainObj));
            }
        }
        return updatedObjects;

    }

    @SuppressWarnings("unchecked")
    @Override
    public void deleteDomainObjects(final List<T> domainObjList) {
        //User is not deleted instead roles are deleted
        if (!CollectionUtils.isEmpty(domainObjList)) {
            for (T domainObj : domainObjList) {
                User dbUser = findUserByAlternateKey(domainObj);
                if (dbUser != null) {
                    RoleAssociation uploadedRole = domainObj.getRoleAssociations().get(0);
                    for (RoleAssociation role : dbUser.getRoleAssociations()) {
                        if (uploadedRole.equals(role)) {
                            dbUser.removeRoleAssociation(uploadedRole);
                            break;
                        }
                    }
                    updateDomainObject((T) dbUser);
                }
            }
        }
    }

    private T mergeRoleAssociations(T userObj, List<T> userList) {
        for (T user : userList) {
            if (userObj.equals(user)) {
                for (RoleAssociation role : user.getRoleAssociations()) {
                    if (userObj.addRoleAssociation(role)) {
                        /**
                         * If not added, then Role Association already exists for the User, but update the
                         * role association attributes
                         */
                        int index = Collections.binarySearch(user.getRoleAssociations(), role); //Find the RoleAssociation
                        if (index > -1) {//Once found then set the attributes
                            setRoleAttributes(user.getRoleAssociations().get(index), role);
                        }
                    }
                }
                setUserAttributes(userObj, user);
            }
        }
        return userObj;
    }

    private void setUserAttributes(T userToSet, T fromUser) {
        userToSet.setFirstName(fromUser.getFirstName());
        userToSet.setLastName(fromUser.getLastName());
        userToSet.setPhone(fromUser.getPhone());
    }

    private void setRoleAttributes(RoleAssociation roleAssocToSet, RoleAssociation roleAssocFrom) {
        roleAssocToSet.setStateAbbreviation(roleAssocFrom.getStateAbbreviation());
    }

    private void mergeExistingRolesFromDB(T userObj) {
        User dbUser = findUserByAlternateKey(userObj);
        //merge roles from dbUser
        if (dbUser != null) {
            for (RoleAssociation role : dbUser.getRoleAssociations()) {
                userObj.addRoleAssociation(role);
            }
        }
    }

    private User findUserByAlternateKey(User userObj) {
        //find user
        Map<String, String[]> params = new HashMap<String, String[]>();
        params.put(UserSearchRequest.SEARCH_KEY_EMAIL, new String[] { userObj.getEmail() });
        AbstractSearchRequest searchRequest = new UserSearchRequest(params);
        return findByAlternateKey(searchRequest, User.class);
    }

    @SuppressWarnings("unchecked")
    private void setAssociatedEntityMongoId(User user) {
        for (RoleAssociation role : user.getRoleAssociations()) {
            if (role.getAssociatedEntityMongoId() == null) {
                Sb11Entity associatedEntity;
                if (Sb11SuperEntity.class.isAssignableFrom(role.getLevel().getEntityClass())) {
                    associatedEntity = sb11EntityService.findByEntityId(role.getAssociatedEntityId(), (Class<Sb11SuperEntity>) role.getLevel().getEntityClass());
                } else {
                    String stateAbbreviation = role.getStateAbbreviation();
                    associatedEntity = sb11EntityService.findByEntityIdAndStateAbbreviation(role.getAssociatedEntityId(), stateAbbreviation, role.getLevel().getEntityClass());
                }
                if (associatedEntity != null) {
                    role.setAssociatedEntityMongoId(associatedEntity.getId());
                }
            }
        }
    }

    @Override
    public List<User> findAllByRoleAssociationLevel(String associatedEntityId, HierarchyLevel level) {
        return userRepository.findAllByRoleAssociationLevel(associatedEntityId, level);
    }

    @Override
    public List<User> findUserByLevel(String associatedEntityId, String stateAbbreviation, HierarchyLevel level) {
        return userRepository.findAllByRoleAssociationLevel(associatedEntityId, stateAbbreviation, level);
    }

    @Override
    public List<User> findUserByLevel(String level) {
        return userRepository.findAllByRoleAssociationLevel(level);
    }

    public User findByEmail(String email) {
        return userRepository.findByEmail(email);
    }

}
