/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/

package org.opentestsystem.delivery.testreg.persistence.criteria;

import static org.opentestsystem.delivery.testreg.persistence.criteria.verifiers.VerifierUtils.addFieldError;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.opentestsystem.delivery.testreg.domain.Accommodation;
import org.opentestsystem.delivery.testreg.domain.Action;
import org.opentestsystem.delivery.testreg.domain.DistrictEntity;
import org.opentestsystem.delivery.testreg.domain.ExplicitEligibility;
import org.opentestsystem.delivery.testreg.domain.InstitutionEntity;
import org.opentestsystem.delivery.testreg.domain.Sb11Entity;
import org.opentestsystem.delivery.testreg.domain.Sb11NonEntity;
import org.opentestsystem.delivery.testreg.domain.Sb11SuperEntity;
import org.opentestsystem.delivery.testreg.domain.Student;
import org.opentestsystem.delivery.testreg.domain.StudentGroup;
import org.opentestsystem.delivery.testreg.domain.TestRegistrationBase;
import org.opentestsystem.delivery.testreg.domain.User;
import org.opentestsystem.delivery.testreg.persistence.StudentRepository;
import org.opentestsystem.delivery.testreg.persistence.UserServiceHelper;
import org.opentestsystem.delivery.testreg.service.Sb11EntityRepositoryService;
import org.opentestsystem.delivery.testreg.service.TestRegUserDetailsService;
import org.opentestsystem.delivery.testreg.service.UserService;
import org.opentestsystem.shared.progman.client.domain.TenantType;
import org.opentestsystem.shared.security.domain.SbacRole;
import org.opentestsystem.shared.security.domain.SbacUser;
import org.opentestsystem.shared.security.domain.permission.UserRole;
import org.opentestsystem.shared.security.integration.PermissionClient;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;
import org.springframework.validation.FieldError;

@Component
public class FileUploadSecurityValidator implements BusinessValidator<TestRegistrationBase> {

    private static final Logger LOGGER = LoggerFactory.getLogger(FileUploadSecurityValidator.class);

    @Autowired
    private Sb11EntityRepositoryService sb11EntityService;

    @Qualifier("userDetailService")
    @Autowired
    private TestRegUserDetailsService testRegUserDetailsService;

    @Autowired
    private StudentRepository studentRepository;
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private PermissionClient permissionClient;

    @Override
    public Action getAction() {
        throw new UnsupportedOperationException("This operation is not supported for this object");
    }

    @Override
    public boolean supports(final Class<? extends TestRegistrationBase> clazz) {
        return TestRegistrationBase.class.isAssignableFrom(clazz);
    }

    @Override
    public List<FieldError> validate(final TestRegistrationBase testRegistrationBase) {

        List<FieldError> errors = new ArrayList<>();
        Set<String> map = testRegUserDetailsService.getMongoIdsOfEntitiesCurrentUserHasAccessTo();

        if (testRegistrationBase instanceof Sb11Entity) {
            LOGGER.trace("validating an Sb11Entity...");
            validateSb11Entity((Sb11Entity) testRegistrationBase, errors, map);
        } else if (testRegistrationBase instanceof Sb11NonEntity) {
            LOGGER.trace("validating an Sb11NonEntity...");
            if (testRegistrationBase instanceof Accommodation) {
                validateAccommodation((Accommodation) testRegistrationBase, errors, map);
            } else if (testRegistrationBase instanceof ExplicitEligibility) {
                validateExplicitEligibility((ExplicitEligibility) testRegistrationBase, errors, map);
            } else if (testRegistrationBase instanceof Student) {
                validateStudent((Student) testRegistrationBase, errors, map);
            } else if (testRegistrationBase instanceof StudentGroup) {
                validateStudentGroup((StudentGroup) testRegistrationBase, errors, map);
            } else if (testRegistrationBase instanceof User) {
                validateUser((User) testRegistrationBase, errors, map);
            } else {
                throw new UnsupportedOperationException("Validation doesn't support this type of Sb11NonEntity.");
            }
        }
        return errors;
    }

    @SuppressWarnings("unchecked")
    private void validateUser(final User user, final List<FieldError> errors, final Set<String> map) {
        Set<String> associatedEntityMongoIds = new HashSet<>();
        List<String> protectedRoles = userService.getProctedRoles ();
        SbacUser sbacUser = testRegUserDetailsService.getCurrentUser ();
        List<String> notAllowedRolesForLoggedInUser = UserServiceHelper.getNotAllowedProtectedRoles (sbacUser, protectedRoles);
        HashMap<String,String> associatedEntityMap = new HashMap<String,String>();
        for (User.RoleAssociation roleAssociation : user.getRoleAssociations()) {
            if (roleAssociation.getAssociatedEntityMongoId() != null) {
                associatedEntityMongoIds.add(roleAssociation.getAssociatedEntityMongoId());
                associatedEntityMap.put (roleAssociation.getAssociatedEntityMongoId(), roleAssociation.getAssociatedEntityId ());
            } else if (roleAssociation.getAssociatedEntityId() != null) {
                Sb11Entity sb11EntityLookup = null;
                if (roleAssociation.getLevel().isSuperEntity()) {
                    sb11EntityLookup = sb11EntityService.findByEntityId(roleAssociation.getAssociatedEntityId(),
                            (Class<Sb11SuperEntity>) roleAssociation.getLevel().getEntityClass());
                } else {
                    String stateAbbrev = roleAssociation.getStateAbbreviation();
                    sb11EntityLookup = sb11EntityService.findByEntityIdAndStateAbbreviation(roleAssociation
                            .getAssociatedEntityId(), stateAbbrev, roleAssociation.getLevel().getEntityClass());
                }
                if (sb11EntityLookup != null) {
                    associatedEntityMongoIds.add(sb11EntityLookup.getId());
                    associatedEntityMap.put (sb11EntityLookup.getId(), roleAssociation.getAssociatedEntityId ());
                }
            } else {
                LOGGER.warn("unable to find this role association's associated entity: " + roleAssociation.getLevel() + "," + roleAssociation.getAssociatedEntityId() + ", " + roleAssociation.getAssociatedEntityMongoId());
            }
            
            // Adding new validation based on SB-1474
            // protected UserRoleNames that the logged-in-User does not have access
            if (notAllowedRolesForLoggedInUser.contains (roleAssociation.getRole ())) {
              String message = "Access Denied: You do not have permission to assign this role ( " + roleAssociation.getRole () + " )";
              addFieldError(errors, user, "Role", roleAssociation.getRole (), message);
            }
        }
        
        if (!associatedEntityMongoIds.isEmpty()) {
            for (String associatedEntityMongoId : associatedEntityMongoIds) {
                if (!map.contains(associatedEntityMongoId)) {
                  String message = "Access Denied: You do not have access to AssociatedEntityId ( " + associatedEntityMap.get (associatedEntityMongoId) + " )";
                    addFieldError(errors, user, "---", "---", message);
                    return;
                }
            }
        }
        
        User dbUser = userService.findByEmail (user.getEmail ());
        if(dbUser != null ){
          // Adding new validation based on TO-15( SB-1426 ) requirement 6 
          // Not allowing logged-in-user to update Name,EmailAddress and PhoneNumber if user being edited or viewed has roles outside logged-in-user jurisdiction
          User modifiedUser = userService.findById (dbUser.getId (), dbUser.getFormatType (), map);
          if(modifiedUser != null && modifiedUser.getHasRolesOutside ()){
            if(!user.getFirstName ().equalsIgnoreCase (modifiedUser.getFirstName ()) || !user.getLastName ().equalsIgnoreCase (modifiedUser.getLastName ()) || !user.getPhone ().equalsIgnoreCase (modifiedUser.getPhone ())){
              addFieldError(errors, user, "---", "---", "This user has either roles outside your jurisdiction, or protected roles, so you cannot edit their contact information");
              return;
            }
          }
        }
        
    }

    @SuppressWarnings("unchecked")
    private void validateSb11Entity(final Sb11Entity sb11Entity, final List<FieldError> errors, final Set<String> map) {

        // check if we have access to this entity itself
        String mongoEntityId = sb11Entity.getId();
        Sb11Entity sb11EntityLookup = null;
        if (mongoEntityId == null) {
            if (sb11Entity instanceof Sb11SuperEntity) {
                sb11EntityLookup = sb11EntityService.findByEntityId(sb11Entity.getEntityId(),
                        (Class<Sb11SuperEntity>) sb11Entity.getEntityType().getEntityClass());
            } else {
                String stateAbbreviation = sb11Entity.getStateAbbreviation();
                sb11EntityLookup = sb11EntityService.findByEntityIdAndStateAbbreviation(sb11Entity.getEntityId(),
                        stateAbbreviation, sb11Entity.getEntityType().getEntityClass());
            }
            if (sb11EntityLookup != null) {
                mongoEntityId = sb11EntityLookup.getId();
            }
        }

        // check if we have access to this entity's parent
        String parentMongoEntityId = sb11Entity.getParentId();
        if (mongoEntityId == null) {
            if (parentMongoEntityId == null) {
                Sb11Entity parentEntityLookup;
                if (Sb11SuperEntity.class.isAssignableFrom(sb11Entity.getParentEntityType().getEntityClass())) {
                    parentEntityLookup = sb11EntityService.findByEntityId(sb11Entity.getParentEntityId(),
                            (Class<Sb11SuperEntity>) sb11Entity.getParentEntityType().getEntityClass());
                } else {
                    String stateAbbreviation = sb11Entity.getStateAbbreviation();
                    parentEntityLookup = sb11EntityService.findByEntityIdAndStateAbbreviation(sb11Entity
                            .getParentEntityId(), stateAbbreviation, sb11Entity.getParentEntityType().getEntityClass());
                }
                if (parentEntityLookup != null) {
                    parentMongoEntityId = parentEntityLookup.getId();
                }
            }
        }

        if (mongoEntityId == null && parentMongoEntityId == null) {
            //since valid parent validation is done in HierarchyLevelPermissionValidator no need to throw error here
            LOGGER.debug("Access Denied: entity or parent entity id not found");
        } else {
            if (mongoEntityId != null && (map != null && !map.contains(mongoEntityId))) {
                addFieldError(errors, sb11Entity, "---", "---", "Access Denied");
            } else if (parentMongoEntityId != null && (map != null && !map.contains(parentMongoEntityId))) {
                addFieldError(errors, sb11Entity, "---", "---", "Access Denied: Parent Entity");
            }
        }
    }

    private void validateAccommodation(final Accommodation accommodation, final List<FieldError> errors, final Set<String> map) {
        Student student = studentRepository.findByEntityIdAndStateAbbreviation(accommodation.getStudentId(),
                accommodation.getStateAbbreviation());
        validateStudent(student, errors, map);
    }

    private void validateExplicitEligibility(final ExplicitEligibility explicitEligibility, final List<FieldError> errors,
            final Set<String> map) {
        String stateAbbreviation = explicitEligibility.getStateAbbreviation();
        String studentId = explicitEligibility.getStudentId();
        Student student = studentRepository.findByEntityIdAndStateAbbreviation(studentId, stateAbbreviation);
        validateStudent(student, errors, map);
        if (errors.size() == 0) {
            String districtMongoId = explicitEligibility.getResponsibleDistrictMongoId();
            String districtId = explicitEligibility.getResponsibleDistrictId();
            checkAccessToDistrict(districtMongoId, districtId, stateAbbreviation, errors, map, explicitEligibility);
        }
    }

    private void validateStudent(final Student student, final List<FieldError> errors, final Set<String> map) {
        if (student != null) {
            String stateAbbreviation = student.getStateAbbreviation();
            String districtMongoId = student.getDistrictEntityMongoId();
            String districtId = student.getDistrictIdentifier();
            checkAccess(districtMongoId, districtId, stateAbbreviation, errors, map, student);

            String institutionMongoId = student.getInstitutionEntityMongoId();
            String institutionId = student.getInstitutionIdentifier();
            checkAccessToInstitution(institutionMongoId, institutionId, stateAbbreviation, errors, map, student);
        }
    }

    private void validateStudentGroup(final StudentGroup studentGroup, final List<FieldError> errors, final Set<String> map) {
        if (studentGroup != null) {
            String stateAbbreviation = studentGroup.getStateAbbreviation();
            String districtMongoId = studentGroup.getDistrictEntityMongoId();
            String districtId = studentGroup.getDistrictIdentifier();
            checkAccess(districtMongoId, districtId, stateAbbreviation, errors, map, studentGroup);
            
            String institutionMongoId = studentGroup.getInstitutionEntityMongoId();
            String institutionId = studentGroup.getInstitutionIdentifier();
            checkAccessToInstitution(institutionMongoId, institutionId, stateAbbreviation, errors, map, studentGroup);
        }
    }

    // -----------------------------------------------------------------------------------------------

    private void checkAccessToDistrict(String districtMongoId, final String districtId, final String stateAbbreviation,
            final List<FieldError> errors, final Set<String> map, final TestRegistrationBase testRegistrationBase) {
        if (districtMongoId == null) {
            DistrictEntity districtEntity = sb11EntityService.findByEntityIdAndStateAbbreviation(districtId,
                    stateAbbreviation, DistrictEntity.class);
            if (districtEntity != null) {
                districtMongoId = districtEntity.getId();
            }
        }
        if (districtMongoId != null && !map.contains(districtMongoId)) {
            String message = "Access Denied: You do not have access to DistrictIdentifier ( " + districtId + " )";
            addFieldError(errors, testRegistrationBase, "---", "---", message);
        }
    }

    private void checkAccessToInstitution(String institutionMongoId, final String institutionId, final String stateAbbreviation,
            final List<FieldError> errors, final Set<String> map, final TestRegistrationBase testRegistrationBase) {
        if (institutionMongoId == null) {
            InstitutionEntity institutionEntity = sb11EntityService.findByEntityIdAndStateAbbreviation(institutionId,
                    stateAbbreviation, InstitutionEntity.class);
            if (institutionEntity != null) {
                institutionMongoId = institutionEntity.getId();
            }
        }
        if (institutionMongoId != null && !map.contains(institutionMongoId)) {
            String message = "Access Denied: You do not have access to InstitutionIdentifier ( " + institutionId + " )";
            addFieldError(errors, testRegistrationBase, "---", "---", message);
        }
    }

    private void checkAccess(String districtMongoId, final String districtId, final String stateAbbreviation,
        final List<FieldError> errors, final Set<String> map, final TestRegistrationBase testRegistrationBase) {
      SbacUser sbacUser = testRegUserDetailsService.getCurrentUser ();
      Collection<SbacRole> roles = sbacUser.getRoles ();
      if(roles != null){
        for(SbacRole role : roles){
          if(role.getRoleEntityLevel () != TenantType.INSTITUTION && role.getRoleEntityLevel () != TenantType.INSTITUTION_GROUP){
            checkAccessToDistrict(districtMongoId, districtId, stateAbbreviation, errors, map, testRegistrationBase);
            break;
          }
        }
      }

    }

}
