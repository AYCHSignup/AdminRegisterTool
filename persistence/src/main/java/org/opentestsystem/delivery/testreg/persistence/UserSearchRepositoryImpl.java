/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2015 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/

package org.opentestsystem.delivery.testreg.persistence;

import java.util.*;

import javax.annotation.Resource;

import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.User;
import org.opentestsystem.delivery.testreg.domain.search.UserSearchRequest;
import org.opentestsystem.delivery.testreg.service.Sb11EntityRepositoryService;
import org.opentestsystem.delivery.testreg.service.TestRegPersister;
import org.opentestsystem.shared.search.domain.AbstractSearchRequest;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.opentestsystem.shared.security.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.Cache;
import org.springframework.cache.Cache.ValueWrapper;
import org.springframework.cache.CacheManager;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Direction;
import org.springframework.data.domain.Sort.Order;
import org.springframework.data.mongodb.core.MongoOperations;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;

import com.google.common.base.Function;
import com.google.common.base.Predicate;
import com.google.common.collect.FluentIterable;

public class UserSearchRepositoryImpl implements UserSearchRepository  {

    private static final int MAX_QUERY_LIMIT_FOR_PAGING = 1001;

    private static final String ACCESSIBLE_USERS_CACHE = "accessibleUsersCache";
    
    @Autowired
    private MongoOperations mongoOperations;
        
    @Resource
    private CacheManager cacheManager;
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private TestRegPersister sb11Entity;
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private Sb11EntityRepositoryService sb11EntityService;

    @Override
   	public SearchResponse<User> search(	AbstractSearchRequest abstractSearchRequest) {
        SearchResponse<User> emptyList =  new SearchResponse<User>(Collections.<User>emptyList(), abstractSearchRequest, 0);
		UserSearchRequest userSearchRequest = (UserSearchRequest) abstractSearchRequest;
		Set<String> accessibleEntityIds = userSearchRequest.getAccessibleEntityIds();

        updateEntitySearchCriteria(userSearchRequest, accessibleEntityIds);
		Query query = abstractSearchRequest.buildQuery();
        query.limit(MAX_QUERY_LIMIT_FOR_PAGING);

		if (abstractSearchRequest.isSearchCriteriaRequired()) {
		    if ((query.getQueryObject() == null || query.getQueryObject().keySet().size() == 0)) {
		        return emptyList;
		    }
		}
		if (accessibleEntityIds == null || accessibleEntityIds.size() == 0 || query.getQueryObject().keySet().size() > 1) {
		    SearchResponse<User> response;
		    List<User> results = mongoOperations.find(query, User.class);
            long totalCountWithPagination = getTotalCountWithPagination(abstractSearchRequest, results.size());
		    if (results == null || results.size() == 0) {
		        response = emptyList;
            } else if (results.size() < 10 ) {
                response = new SearchResponse<>(results, abstractSearchRequest, totalCountWithPagination);
            } else {
                response = new SearchResponse<>(results.subList(0, 10), abstractSearchRequest, totalCountWithPagination);
            }
            return response;
		}

		final List<Order> orders = new ArrayList<Order>();
		String[] sortKeys = abstractSearchRequest.getSortKeys ();
		Sort.Direction[] sortDirections = abstractSearchRequest.getSortDirections ();
		if (sortKeys != null) {
		  for (int i = 0; i < sortKeys.length; i++) {
		    Direction sortDir = null;
		    final String key = sortKeys[i];
		    if (sortDirections.length >= i + 1) {
		      sortDir = sortDirections[i];
		    }
		    final Order order = new Order(sortDir, key);
		    orders.add(order);
		  }
		}
		final Sort sort = new Sort(orders);

		// Previously, the cached list of "visible" users was used as a filtering criteria for the search query.
		// For large loads (100k+ users), the size of the query resulting from having each userId can grow dramatically and effect performance.
		// Instead, let us filter by the list of accessible entity ids which is a much smaller query but should
		// yield the same results.
		Query allQuery = new Query(Criteria.where("roleAssociations").elemMatch(Criteria.where("associatedEntityMongoId").in(accessibleEntityIds)));
		List<User> users = mongoOperations.find(allQuery.with (
				new PageRequest(abstractSearchRequest.getCurrentPage (), MAX_QUERY_LIMIT_FOR_PAGING, sort)), User.class);
		SearchResponse response;
        long totalCountWithPagination = getTotalCountWithPagination(abstractSearchRequest, users.size());
		if (users.size() < 10) {
			response = new SearchResponse<>(users, abstractSearchRequest, totalCountWithPagination);
		} else {
			response = new SearchResponse<>(users.subList(0, 10), abstractSearchRequest, totalCountWithPagination);
		}

		return response;
	}

    private long getTotalCountWithPagination(AbstractSearchRequest abstractSearchRequest, int size) {
        return size + abstractSearchRequest.getCurrentPage() * 10;
    }

    private void updateEntitySearchCriteria(UserSearchRequest userSearchRequest, Set<String> accessibleEntityIds) {
        boolean isDistrictNameSearch = userSearchRequest.getSearchCriteria().containsKey(UserSearchRequest.SEARCH_KEY_DISTRICT_NAME);
        boolean isInstitutionNameSearch = userSearchRequest.getSearchCriteria().containsKey(UserSearchRequest.SEARCH_KEY_INSTITUTION_NAME);
        Map<String, String[]> searchCriteria = userSearchRequest.getSearchCriteria();
        List<String> matchingEntityIds = new ArrayList<>();
        if (isDistrictNameSearch) {
            String districtName = userSearchRequest.getSearchCriteria().get(UserSearchRequest.SEARCH_KEY_DISTRICT_NAME)[0];
            matchingEntityIds.addAll(sb11EntityService.findAllMatchingEntities(accessibleEntityIds, districtName, FormatType.DISTRICT));
        }
        if (isInstitutionNameSearch) {
            String institutionName = userSearchRequest.getSearchCriteria().get(UserSearchRequest.SEARCH_KEY_INSTITUTION_NAME)[0];
            matchingEntityIds.addAll(sb11EntityService.findAllMatchingEntities(accessibleEntityIds, institutionName, FormatType.INSTITUTION));
        }
        if (matchingEntityIds.size() > 0) {
            updateEntityNameFilter(searchCriteria, matchingEntityIds);
        }
    }

    private void updateEntityNameFilter(Map<String, String[]> searchCriteria, List<String> matchingEntityIds) {
        searchCriteria.remove(UserSearchRequest.SEARCH_KEY_INSTITUTION_NAME);
        searchCriteria.remove(UserSearchRequest.SEARCH_KEY_DISTRICT_NAME);
        searchCriteria.put(UserSearchRequest.SEARCH_KEY_NAME_ASSOCIATED_ENTITY_ID, matchingEntityIds.toArray(new String[0]));
    }

	private List<String> getFilteredAccessibleUserIds(List<User> users, final Set<String> accessibleEntityIds) {
    	Predicate<User> filteredUsers = new Predicate<User>() {
            @Override
			public boolean apply(User user) {
				for (User.RoleAssociation role : user.getRoleAssociations()) {
					if (accessibleEntityIds.contains(role.getAssociatedEntityMongoId())) {
						return true;
					}
				}
				return false;
			}
        };
        Function<User, String> accessibleIds = new Function<User, String>() {
            @Override
            public String apply(User user) {
                return user.getId();
            }
        };
        return FluentIterable.from(users).filter(filteredUsers).transform(accessibleIds).toList();
    }
    
    @SuppressWarnings("unchecked")
	private List<String> getCachedAccessibleUserIds(String userName) {
   	    Cache accessibleUsersCache = cacheManager.getCache(ACCESSIBLE_USERS_CACHE);
	    List<String> accessibleUserIds= null;
	    if (accessibleUsersCache != null) {
	        ValueWrapper cacheGet = accessibleUsersCache.get(userName);
	        if (cacheGet != null) {
	        	accessibleUserIds = (List<String>) cacheGet.get();
	        }
	    }
	    return accessibleUserIds;
    }
    
	private synchronized void setCachedAccessibleUserIds(List<String> accessibleUserIds, String userName) {
   	    Cache accessibleUsersCache = cacheManager.getCache(ACCESSIBLE_USERS_CACHE);
   	    if (accessibleUsersCache != null) {
   	    	accessibleUsersCache.put(userName, accessibleUserIds);
   	    }
    }

	@Override
	public void clearAccessibleUsersCache() {
		Cache accessibleUsersCache = cacheManager.getCache(ACCESSIBLE_USERS_CACHE);
   	    if (accessibleUsersCache != null) {
   	    	accessibleUsersCache.clear();
   	    }
	}
	
	@Override
	public <S extends User> List<S> save(Iterable<S> entites) {
		return null;
	}

	@Override
	public List<User> findAll() {
		return null;
	}

	@Override
	public List<User> findAll(Sort sort) {
		return null;
	}

	@Override
	public Page<User> findAll(Pageable pageable) {
		return null;
	}

	@Override
	public <S extends User> S save(S entity) {
		return null;
	}

	@Override
	public User findOne(String id) {
		return null;
	}

	@Override
	public boolean exists(String id) {
		return false;
	}

	@Override
	public Iterable<User> findAll(Iterable<String> ids) {
		return null;
	}

	@Override
	public long count() {
		return 0;
	}

	@Override
	public void delete(String id) {
	}

	@Override
	public void delete(User entity) {
	}

	@Override
	public void delete(Iterable<? extends User> entities) {
	}

	@Override
	public void deleteAll() {
	}

}
