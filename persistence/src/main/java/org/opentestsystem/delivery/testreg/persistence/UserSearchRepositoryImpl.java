/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2015 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/

package org.opentestsystem.delivery.testreg.persistence;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Set;

import javax.annotation.Resource;

import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.Sb11Entity;
import org.opentestsystem.delivery.testreg.domain.User;
import org.opentestsystem.delivery.testreg.domain.User.RoleAssociation;
import org.opentestsystem.delivery.testreg.domain.search.UserSearchRequest;
import org.opentestsystem.delivery.testreg.service.Sb11EntityRepositoryService;
import org.opentestsystem.delivery.testreg.service.TestRegPersister;
import org.opentestsystem.shared.progman.client.domain.TenantType;
import org.opentestsystem.shared.search.domain.AbstractSearchRequest;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.opentestsystem.shared.security.domain.SbacUser;
import org.opentestsystem.shared.security.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.Cache;
import org.springframework.cache.Cache.ValueWrapper;
import org.springframework.cache.CacheManager;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Direction;
import org.springframework.data.domain.Sort.Order;
import org.springframework.data.mongodb.core.MongoOperations;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;

import com.google.common.base.Function;
import com.google.common.base.Predicate;
import com.google.common.collect.FluentIterable;

public class UserSearchRepositoryImpl implements UserSearchRepository  {

    private static final String ACCESSIBLE_USERS_CACHE = "accessibleUsersCache";
    
    @Autowired
    private MongoOperations mongoOperations;
        
    @Resource
    private CacheManager cacheManager;
    
    @Autowired
    private UserService userService;
	
	@Autowired
    private TestRegPersister sb11Entity;
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private Sb11EntityRepositoryService sb11EntityService;

    @Override
   	public SearchResponse<User> search(	AbstractSearchRequest abstractSearchRequest) {
		UserSearchRequest userSearchRequest = (UserSearchRequest) abstractSearchRequest;

		String username = userService.getCurrentUser().getUsername();
		List<String> cachedUserIds = getCachedAccessibleUserIds(username);
    	Set<String> accessibleEntityIds = userSearchRequest.getAccessibleEntityIds();
    	if (cachedUserIds == null) { 
      	    if (accessibleEntityIds != null && accessibleEntityIds.size() > 0) {
         	   List<User> results = mongoOperations.find(new Query(userSearchRequest.getAccessibleUserEntitiesCriteria(accessibleEntityIds)), User.class);
        	   cachedUserIds = getFilteredAccessibleUserIds(results, accessibleEntityIds);
    		   setCachedAccessibleUserIds(cachedUserIds, username);
      	    }
	    }
    	userSearchRequest.setCachedUserIds(cachedUserIds);
		Query query = abstractSearchRequest.buildQuery();
    	SearchResponse<User> emptyList =  new SearchResponse<User>(Collections.<User>emptyList(), abstractSearchRequest, 0);
    	if (abstractSearchRequest.isSearchCriteriaRequired()) {
	   	    if ((query.getQueryObject() == null || query.getQueryObject().keySet().size() == 0)) {
	   	        return emptyList;
	   		}
    	}
        if (accessibleEntityIds == null || accessibleEntityIds.size() == 0 || query.getQueryObject().keySet().size() > 1) {
		     List<User> results = mongoOperations.find(query, User.class);
		     if (results == null || results.size() == 0) {
		         return emptyList;
		     }
		     return new SearchResponse<User>(results, abstractSearchRequest, mongoOperations.count(query, User.class));
        }
        int limit = query.getLimit();
        int skip = query.getSkip();

    	long total = cachedUserIds.size();
        int fromIndex = skip;
        if (fromIndex > total) {
           return emptyList;
        }
        int toIndex = fromIndex + limit;
        if (toIndex > total) {
        	toIndex = (int) total;
        }
        List<User> users = mongoOperations.find(new Query(Criteria.where("id").in(cachedUserIds.subList(fromIndex, toIndex))), User.class);
        return new SearchResponse<User>(users, abstractSearchRequest, total);
	}

    private List<String> getFilteredAccessibleUserIds(List<User> users, final Set<String> accessibleEntityIds) {
    	Predicate<User> filteredUsers = new Predicate<User>() {
            @Override
			public boolean apply(User user) {
				for (User.RoleAssociation role : user.getRoleAssociations()) {
					if (accessibleEntityIds.contains(role.getAssociatedEntityMongoId())) {
						return true;
					}
				}
				return false;
			}
        };
        Function<User, String> accessibleIds = new Function<User, String>() {
            @Override
            public String apply(User user) {
                return user.getId();
            }
        };
        return FluentIterable.from(users).filter(filteredUsers).transform(accessibleIds).toList();
    }
    
    @SuppressWarnings("unchecked")
	private List<String> getCachedAccessibleUserIds(String userName) {
   	    Cache accessibleUsersCache = cacheManager.getCache(ACCESSIBLE_USERS_CACHE);
	    List<String> accessibleUserIds= null;
	    if (accessibleUsersCache != null) {
	        ValueWrapper cacheGet = accessibleUsersCache.get(userName);
	        if (cacheGet != null) {
	        	accessibleUserIds = (List<String>) cacheGet.get();
	        }
	    }
	    return accessibleUserIds;
    }
    
	private synchronized void setCachedAccessibleUserIds(List<String> accessibleUserIds, String userName) {
   	    Cache accessibleUsersCache = cacheManager.getCache(ACCESSIBLE_USERS_CACHE);
   	    if (accessibleUsersCache != null) {
   	    	accessibleUsersCache.put(userName, accessibleUserIds);
   	    }
    }

	@Override
	public void clearAccessibleUsersCache() {
		Cache accessibleUsersCache = cacheManager.getCache(ACCESSIBLE_USERS_CACHE);
   	    if (accessibleUsersCache != null) {
   	    	accessibleUsersCache.clear();
   	    }
	}
	
	@Override
	public <S extends User> List<S> save(Iterable<S> entites) {
		return null;
	}

	@Override
	public List<User> findAll() {
		return null;
	}

	@Override
	public List<User> findAll(Sort sort) {
		return null;
	}

	@Override
	public Page<User> findAll(Pageable pageable) {
		return null;
	}

	@Override
	public <S extends User> S save(S entity) {
		return null;
	}

	@Override
	public User findOne(String id) {
		return null;
	}

	@Override
	public boolean exists(String id) {
		return false;
	}

	@Override
	public Iterable<User> findAll(Iterable<String> ids) {
		return null;
	}

	@Override
	public long count() {
		return 0;
	}

	@Override
	public void delete(String id) {
	}

	@Override
	public void delete(User entity) {
	}

	@Override
	public void delete(Iterable<? extends User> entities) {
	}

	@Override
	public void deleteAll() {
	}
}
