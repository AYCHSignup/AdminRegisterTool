/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.delivery.testreg.service.impl;

import java.util.HashMap;
import java.util.Map;

import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.MnaAlertType;
import org.opentestsystem.delivery.testreg.domain.User;
import org.opentestsystem.delivery.testreg.service.TestRegPersister;
import org.opentestsystem.delivery.testreg.service.UserChangeEventCallbackService;
import org.opentestsystem.shared.mna.client.domain.MnaSeverity;
import org.opentestsystem.shared.mna.client.service.AlertBeacon;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.converters.Converter;
import com.thoughtworks.xstream.converters.MarshallingContext;
import com.thoughtworks.xstream.converters.UnmarshallingContext;
import com.thoughtworks.xstream.io.HierarchicalStreamReader;
import com.thoughtworks.xstream.io.HierarchicalStreamWriter;
import com.thoughtworks.xstream.io.xml.DomDriver;

@Service
public class UserChangeEventCallbackServiceImpl implements UserChangeEventCallbackService {

    private static final Logger LOGGER = LoggerFactory.getLogger(UserChangeEventCallbackServiceImpl.class);

    @Autowired
    private TestRegPersister userService;

    @Autowired
    private AlertBeacon alertBeacon;

    @Override
    public void processCallback(String xml) {
        String verboseMessage = "received an xml response (via the sso extract callback restful end-point) in response to our user change event xml that was uploaded:\n\n"
                + xml + "\n";
        LOGGER.debug(verboseMessage);
        XStream xStream = new XStream(new DomDriver());
        xStream.alias("OpenamACKStatus", CallbackInfo.class);
        xStream.registerConverter(new CallbackXmlConverter());
        CallbackInfo callbackInfo = (CallbackInfo) xStream.fromXML(xml);
        boolean noErrorsDuringCallbackProcessing = true;

        // specific logic for alerting purposes
        if (callbackInfo.errors.size() > 0) {
            alertBeacon.sendAlert(MnaSeverity.ERROR, MnaAlertType.SSO_USER_EXPORT.name(),
                    "callback notified us that the sso user export file " + callbackInfo.getFileName()
                            + " wasn't fully processed");
            noErrorsDuringCallbackProcessing = false;
        }

        // loop over all errors and update users as needed
        for (Map.Entry<String, String> entry : callbackInfo.errors.entrySet()) {
            String uuid = entry.getKey();
            String error = entry.getValue() + " (" + callbackInfo.dateProcessed + ")";
            User user = userService.findById(uuid, FormatType.USER);
            if (user != null) {
                user.setChangeEventExportError(error);
                userService.saveDomainObject(user);
            } else {
                String errorMessage = "invalid UUID found for a user in the user change event callback xml: " + uuid;
                LOGGER.warn(errorMessage);
                alertBeacon.sendAlert(MnaSeverity.ERROR, MnaAlertType.SSO_USER_EXPORT.name(), errorMessage);
                noErrorsDuringCallbackProcessing = false;
            }
        }

        if (noErrorsDuringCallbackProcessing) {
            alertBeacon.sendAlert(MnaSeverity.INFO, MnaAlertType.SSO_USER_EXPORT.name(), "successful processing: "
                    + verboseMessage);
        }

    }

    // convert the XML returned from a callback to an object
    private class CallbackXmlConverter extends OneWayConverter {

        @SuppressWarnings("rawtypes")
        @Override
        public boolean canConvert(final Class clazz) {
            return clazz.equals(CallbackInfo.class);
        }

        @Override
        public Object unmarshal(final HierarchicalStreamReader reader, final UnmarshallingContext context) {
            CallbackInfo callbackInfo = new CallbackInfo();
            if ("OpenamACKStatus".equals(reader.getNodeName())) {
                while (reader.hasMoreChildren()) {
                    reader.moveDown();
                    if ("DateProcessed".equals(reader.getNodeName())) {
                        callbackInfo.setDateProcessed(reader.getValue());
                    } else if ("FileName".equals(reader.getNodeName())) {
                        callbackInfo.setFileName(reader.getValue());
                    } else if ("DateStarted".equals(reader.getNodeName())) {
                        callbackInfo.setDateStarted(reader.getValue());
                    } else if ("ErrorsWithUID".equals(reader.getNodeName())) {
                        while (reader.hasMoreChildren()) {
                            reader.moveDown();
                            if ("UUIDError".equals(reader.getNodeName())) {
                                String errorKey = null;
                                String errorVal = null;
                                while (reader.hasMoreChildren()) {
                                    reader.moveDown();
                                    if ("UUID".equals(reader.getNodeName())) {
                                        errorKey = reader.getValue();
                                    } else if ("Error".equals(reader.getNodeName())) {
                                        errorVal = reader.getValue();
                                    } else {
                                        throw new RuntimeException(
                                                "invalid callback XML tag found within <UUIDError>: "
                                                        + reader.getNodeName());
                                    }
                                    reader.moveUp();
                                }
                                if (errorKey != null && errorVal != null) {
                                    callbackInfo.errors.put(errorKey, errorVal);
                                } else {
                                    throw new RuntimeException(
                                            "invalid callback XML <UUIDError> didn't contain a <UUID> and <Error> flag!");
                                }
                            } else {
                                throw new RuntimeException("invalid callback XML tag found within <ErrorsWithUID>: "
                                        + reader.getNodeName());
                            }
                            reader.moveUp();
                        }
                    } else if ("TotalRecordsProcessed".equals(reader.getNodeName())) {
                        callbackInfo.setTotalRecordsProcessed(Integer.parseInt(reader.getValue()));
                    } else {
                        throw new RuntimeException("invalid callback XML tag found within <OpenamACKStatus>: "
                                + reader.getNodeName());
                    }
                    reader.moveUp();
                }
            }
            return callbackInfo;
        }
    }

    // convenience class to hide the unused method that must be implemented
    private static abstract class OneWayConverter implements Converter {
        @Override
        public void marshal(final Object source, final HierarchicalStreamWriter writer, final MarshallingContext context) {
            // we shouldn't ever use this method!
            throw new RuntimeException("Not Implemented!");
        }
    }

    private static class CallbackInfo {

        private String dateProcessed;
        private String fileName;
        private String dateStarted;
        private int totalRecordsProcessed;
        private Map<String, String> errors = new HashMap<>();

        @SuppressWarnings("unused")
        public String getDateProcessed() {
            return dateProcessed;
        }

        public void setDateProcessed(String dateProcessed) {
            this.dateProcessed = dateProcessed;
        }

        public String getFileName() {
            return fileName;
        }

        public void setFileName(String fileName) {
            this.fileName = fileName;
        }

        @SuppressWarnings("unused")
        public String getDateStarted() {
            return dateStarted;
        }

        public void setDateStarted(String dateStarted) {
            this.dateStarted = dateStarted;
        }

        @SuppressWarnings("unused")
        public int getTotalRecordsProcessed() {
            return totalRecordsProcessed;
        }

        public void setTotalRecordsProcessed(int totalRecordsProcessed) {
            this.totalRecordsProcessed = totalRecordsProcessed;
        }

        @SuppressWarnings("unused")
        public Map<String, String> getErrors() {
            return errors;
        }

        @SuppressWarnings("unused")
        public void setErrors(Map<String, String> errors) {
            this.errors = errors;
        }
    }
}