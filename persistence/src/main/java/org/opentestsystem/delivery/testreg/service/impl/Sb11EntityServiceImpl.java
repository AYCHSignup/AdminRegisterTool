/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.delivery.testreg.service.impl;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.annotation.Resource;

import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang.StringUtils;
import org.opentestsystem.delivery.testreg.domain.ClientEntity;
import org.opentestsystem.delivery.testreg.domain.DistrictEntity;
import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.GroupOfDistrictsEntity;
import org.opentestsystem.delivery.testreg.domain.GroupOfInstitutionsEntity;
import org.opentestsystem.delivery.testreg.domain.GroupOfStatesEntity;
import org.opentestsystem.delivery.testreg.domain.HierarchyLevel;
import org.opentestsystem.delivery.testreg.domain.InstitutionEntity;
import org.opentestsystem.delivery.testreg.domain.Sb11Entity;
import org.opentestsystem.delivery.testreg.domain.Sb11SuperEntity;
import org.opentestsystem.delivery.testreg.domain.StateEntity;
import org.opentestsystem.delivery.testreg.domain.Student;
import org.opentestsystem.delivery.testreg.domain.StudentGroup;
import org.opentestsystem.delivery.testreg.domain.User;
import org.opentestsystem.delivery.testreg.domain.User.RoleAssociation;
import org.opentestsystem.delivery.testreg.domain.search.StudentGroupSearchRequest;
import org.opentestsystem.delivery.testreg.domain.search.StudentSearchRequest;
import org.opentestsystem.delivery.testreg.persistence.HierarchyLevelToFormatTypeConverter;
import org.opentestsystem.delivery.testreg.persistence.Sb11EntityRepository;
import org.opentestsystem.delivery.testreg.persistence.Verifier;
import org.opentestsystem.delivery.testreg.service.Sb11EntityRepositoryService;
import org.opentestsystem.delivery.testreg.service.TestRegPersister;
import org.opentestsystem.delivery.testreg.service.TestRegistrationService;
import org.opentestsystem.delivery.testreg.service.UserService;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.progman.client.domain.TenantType;
import org.opentestsystem.shared.search.domain.AbstractSearchRequest;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.stereotype.Service;

@SuppressWarnings({ "unchecked" })
@Service("sb11EntityService")
public class Sb11EntityServiceImpl<T extends Sb11Entity> implements TestRegistrationService<T>,
        Sb11EntityRepositoryService {

    @Resource
    private Map<FormatType, Sb11EntityRepository<Sb11Entity>> entityRepositoryMap;

    @Autowired
    private Sb11EntityRepository<Sb11Entity> sb11EntityRepository;

    @Autowired
    private TestRegPersister persister;

    @Resource(name = "studentAssociationVerifier")
    private Verifier<Sb11Entity> studentAssociationVerifier;

    @Resource(name = "userAssociationVerifier")
    private Verifier<Sb11Entity> userAssociationVerifier;

    @Autowired
    UserService userService;

    /**
     * {@inheritDoc}
     */
    @Override
    public T findById(final String pkId, final FormatType formatType) {
        return (T) entityRepositoryMap.get(formatType).findOne(pkId);
    }

    @Override
    public <S extends Sb11SuperEntity> S findByEntityId(String entityId, Class<S> clazz) {
        return sb11EntityRepository.findByEntityId(entityId, clazz);
    }

    @Override
    public <S extends Sb11Entity> S findByEntityIdAndStateAbbreviation(final String entityId,
            final String stateAbbreviation, final Class<S> clazz) {
        return sb11EntityRepository.findByEntityIdAndStateAbbreviation(entityId, stateAbbreviation, clazz);
    }

    @Override
    public List<T> findAllByParentEntityTypeAndParentEntityId(final String parentEntityType,
            final String parentEntityId, final FormatType formatType) {
        return (List<T>) (entityRepositoryMap.get(formatType).findByParentEntityTypeAndParentEntityId(parentEntityType,
                parentEntityId));
    }

    @Override
    public <S extends Sb11Entity> List<S> findAllByParentEntityTypeAndParentId(String parentEntityType,
            String parentMongoId, Class<S> clazz) {
        return sb11EntityRepository.findAllByParentEntityTypeAndParentId(parentEntityType, parentMongoId, clazz);
    }

    @Override
    public <S extends Sb11SuperEntity> S findByEntityId(String entityId, TenantType tenantType) {
        return sb11EntityRepository.findByEntityId(entityId, (Class<S>) convertTenantTypeToClass(tenantType));
    }

    @Override
    public <S extends Sb11Entity> S findByEntityIdAndStateAbbreviation(final String entityId,
            final String stateAbbreviation, final TenantType tenantType) {
        return sb11EntityRepository.findByEntityIdAndStateAbbreviation(entityId, stateAbbreviation,
                (Class<S>) convertTenantTypeToClass(tenantType));
    }

    @Override
    public <S extends Sb11Entity> List<S> findAllByEntityId(String entityId, Class<S> clazz) {
        return sb11EntityRepository.findAllByEntityId(entityId, clazz);
    }

    @Override
    public <S extends Sb11Entity> List<S> findAllByEntityIdAndEntityName(String entityId, String entityName,
            Class<S> clazz) {
        return sb11EntityRepository.findAllByEntityIdAndEntityName(entityId, entityName, clazz);
    }

    @Override
    public List<T> findAllByParentEntityType(final String parentEntityType, final HierarchyLevel hierarchyLevel) {
        return (List<T>) (entityRepositoryMap.get(FormatType.valueOf(hierarchyLevel.toString()))
                .findByParentEntityType(parentEntityType));
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<T> findAll(final FormatType formatType) {
        return (List<T>) entityRepositoryMap.get(formatType).findAll();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public T saveDomainObject(final T domainObj) {
        try {
            // before saving the entity lookup parent id and store parent id within the entity
            if (domainObj.getFormatType() != FormatType.CLIENT) {
                Sb11Entity parent = getParentEntity(domainObj);
                if (parent != null) {
                    domainObj.setParentId(parent.getId());
                } else {
                    throw createParentEntityNotFoundException(domainObj.getParentEntityId());
                }
            }
            return entityRepositoryMap.get(domainObj.getFormatType()).save(domainObj);

        } catch (DuplicateKeyException dke) {
            throw new LocalizedException("entity.already.exists", new String[] { domainObj.getFormatType().name(),
                    getDuplicateKeyMessage(domainObj) }, dke);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public T updateDomainObject(final T domainObj) {
        Sb11Entity dbEntity = null;
        // if entity is updated from UI then it will have id
        if (domainObj.getId() != null) {
            dbEntity = findById(domainObj.getId(), domainObj.getFormatType());
        } else {
            dbEntity = sb11EntityRepository.findByAlternateKey(domainObj.createAlternateKeySearchRequest(),
                    domainObj.getClass());
        }

        if (dbEntity != null) {
            if (checkIfStateChanged(domainObj, dbEntity)) {
                throw new LocalizedException("entity.state.changed", new String[] { });
            }
            domainObj.setId(dbEntity.getId());
        }
        T updatedEntity = saveDomainObject(domainObj);
        if (dbEntity != null && domainObj.getEntityId() != dbEntity.getEntityId()) {
            // get all associated entities and update them with new entity id as their parent
            updateAssociatedEntities(dbEntity, domainObj.getEntityId());
        }

        return updatedEntity;
    }

    private void updateAssociatedEntities(final Sb11Entity entity, final String updatableEntityId) {
        // find entities whose parent is this entity
        for (HierarchyLevel level : HierarchyLevel.values()) {
            if (level != HierarchyLevel.CLIENT) {
                List<T> entities = findAllByParentEntityTypeAndParentEntityId(entity.getFormatType().toString()
                        .toUpperCase(), entity.getEntityId(), FormatType.valueOf(level.toString()));
                for (T updentity : entities) {
                    updentity.setParentEntityId(updatableEntityId);
                    saveDomainObject(updentity);
                }
            }
        }
        // find and update students and student groups with associated entity
        if (entity.getFormatType() == FormatType.DISTRICT || entity.getFormatType() == FormatType.INSTITUTION) {
            updateStudents(entity, updatableEntityId);
            udpateStudentGroups(entity, updatableEntityId);
        }

        // find and update users with associated entity
        updateUsers(entity, updatableEntityId);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<T> saveDomainObjects(final List<T> domainObjList) {
        List<T> savedEntities = new ArrayList<T>();
        if (!CollectionUtils.isEmpty(domainObjList)) {
            for (T domainObj : domainObjList) {
                savedEntities.add(saveDomainObject(domainObj));
            }
        }
        return savedEntities;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<T> updateDomainObjects(final List<T> domainObjList) {
        List<T> updatedEntities = new ArrayList<T>();
        if (!CollectionUtils.isEmpty(domainObjList)) {
            for (Sb11Entity entity : domainObjList) {
                updatedEntities.add(updateDomainObject((T) entity));
            }
        }
        return updatedEntities;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void deleteDomainObject(final T entity) {
        entityRepositoryMap.get(entity.getFormatType()).delete(entity);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void deleteDomainObject(final String pkId, final FormatType formatType) {
        entityRepositoryMap.get(formatType).delete(pkId);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void deleteDomainObjects(final List<T> entityList) {
        if (!CollectionUtils.isEmpty(entityList)) {
            for (T entity : entityList) {
                Sb11Entity dbEntity = null;
                if (entity instanceof Sb11SuperEntity) {
                    dbEntity = sb11EntityRepository.findByEntityId(entity.getEntityId(),
                            (Class<Sb11SuperEntity>) entity.getClass());
                } else {
                    dbEntity = sb11EntityRepository.findByEntityIdAndStateAbbreviation(entity.getEntityId(),
                            entity.getStateAbbreviation(), entity.getClass());
                }
                if (dbEntity == null) {
                    throw createSb11EntityNotFoundException(entity.getEntityId());
                } else {
                    entity.setId(dbEntity.getId());
                    deleteDomainObject(entity);
                }
            }
        }
    }

    @Override
    public boolean hasAssociatedEntity(final T entity) {
        Sb11Entity dbEntity = null;
        if (entity instanceof Sb11SuperEntity) {
            dbEntity = sb11EntityRepository.findByEntityId(entity.getEntityId(),
                    (Class<Sb11SuperEntity>) entity.getClass());
        } else {
            dbEntity = sb11EntityRepository.findByEntityIdAndStateAbbreviation(entity.getEntityId(),
                    entity.getStateAbbreviation(), entity.getClass());
        }
        for (HierarchyLevel level : HierarchyLevel.values()) {
            if (level != HierarchyLevel.CLIENT && level != dbEntity.getEntityType()) {
                Long count = sb11EntityRepository.getEntityCountByParentId(dbEntity.getId(), level.getEntityClass());
                if (count != null && count > 0) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public SearchResponse<T> searchDomainObjects(final AbstractSearchRequest searchRequest, final FormatType formatType) {
        return (SearchResponse<T>) entityRepositoryMap.get(formatType).search(searchRequest);
    }

    private LocalizedException createSb11EntityNotFoundException(final String sb11EntityId) {
        return new LocalizedException("entity.not.found", new String[] { sb11EntityId });
    }

    private LocalizedException createParentEntityNotFoundException(final String parentEntityId) {
        return new LocalizedException("entity.parent.not.found", new String[] { parentEntityId });
    }

    private LocalizedException createFormatTypeException(final FormatType type) {
        return new LocalizedException("entity.invalid.formattype", new String[] { type.toString() });
    }

    /**
     * Get duplicate key error message based on entity format type.
     * 
     * @param entity
     *            entity
     * @return error message
     */
    private String getDuplicateKeyMessage(final T entity) {

        switch (entity.getFormatType()) {
            case STATE:
            case GROUPOFSTATES:
                return entity.getEntityId();
            case DISTRICT:
                DistrictEntity distEntity = (DistrictEntity) entity;
                return distEntity.getEntityId().concat(" and ").concat(distEntity.getStateAbbreviation());
            case INSTITUTION:
                InstitutionEntity institutionEntity = (InstitutionEntity) entity;
                return institutionEntity.getEntityId().concat(" and ").concat(institutionEntity.getStateAbbreviation());
            case GROUPOFDISTRICTS:
                GroupOfDistrictsEntity groupOfDistricts = (GroupOfDistrictsEntity) entity;
                return groupOfDistricts.getEntityId().concat(" and ").concat(groupOfDistricts.getStateAbbreviation());
            case GROUPOFINSTITUTIONS:
                GroupOfInstitutionsEntity groupOfInstitutions = (GroupOfInstitutionsEntity) entity;
                return groupOfInstitutions.getEntityId().concat(" and ")
                        .concat(groupOfInstitutions.getStateAbbreviation());
            default:
                throw createFormatTypeException(entity.getFormatType());
        }
    }

    private void udpateStudentGroups(final Sb11Entity entity, final String updatableEntityId) {
        StudentGroupSearchRequest searchReq = new StudentGroupSearchRequest(getParamsForAssocEntitySearch(
                entity.getId(), entity.getFormatType()));
        searchReq.setFilter(false);

        SearchResponse<StudentGroup> response = persister.searchDomainObjects(searchReq, FormatType.STUDENTGROUP);
        for (StudentGroup studentGroup : response.getSearchResults()) {
            if (entity.getFormatType() == FormatType.DISTRICT) {
                studentGroup.setDistrictIdentifier(updatableEntityId);
            } else if (entity.getFormatType() == FormatType.INSTITUTION) {
                studentGroup.setInstitutionIdentifier(updatableEntityId);
            }
            persister.updateDomainObject(studentGroup);
        }

    }

    private void updateStudents(final Sb11Entity entity, final String updatableEntityId) {
        StudentSearchRequest searchReq = new StudentSearchRequest(getParamsForAssocEntitySearch(entity.getId(),
                entity.getFormatType()));
        searchReq.setFilter(false);

        SearchResponse<Student> response = persister.searchDomainObjects(searchReq, FormatType.STUDENT);
        for (Student student : response.getSearchResults()) {
            if (entity.getFormatType() == FormatType.DISTRICT) {
                student.setDistrictIdentifier(updatableEntityId);
            } else if (entity.getFormatType() == FormatType.INSTITUTION) {
                student.setInstitutionIdentifier(updatableEntityId);
            }
            persister.updateDomainObject(student);
        }
    }

    private Map<String, String[]> getParamsForAssocEntitySearch(final String associatedId,
            final FormatType entityFormatType) {
        Map<String, String[]> searchParams = new HashMap<String, String[]>();
        if (entityFormatType == FormatType.DISTRICT) {
            searchParams.put(StudentSearchRequest.SEARCH_KEY_DISTRICT_DB_ID, new String[] { associatedId });
        } else if (entityFormatType == FormatType.INSTITUTION) {
            searchParams.put(StudentSearchRequest.SEARCH_KEY_INSTITUTION_DB_ID, new String[] { associatedId });
        }
        return searchParams;
    }

    private void updateUsers(final Sb11Entity entity, final String updatableEntityId) {
        List<User> users = userService.findAllByRoleAssociationLevel(entity.getEntityId(),
                HierarchyLevel.valueOf(entity.getFormatType().toString().toUpperCase()));
        for (User user : users) {
            for (RoleAssociation roleAssociation : user.getRoleAssociations()) {
                if (roleAssociation.getAssociatedEntityId().equals(entity.getEntityId())) {
                    roleAssociation.setAssociatedEntityId(updatableEntityId);
                }
                persister.updateDomainObject(user);
            }
        }
    }

    @Override
    public Sb11Entity getParentEntity(final Sb11Entity entity) {
        if (!StringUtils.isEmpty(entity.getParentId())) {
            return findById(entity.getParentId(),
                    HierarchyLevelToFormatTypeConverter.convertFrom(entity.getParentEntityType()));
        } else if (entity.getParentEntityType() == HierarchyLevel.CLIENT
                || entity.getParentEntityType() == HierarchyLevel.GROUPOFSTATES
                || entity.getParentEntityType() == HierarchyLevel.STATE) {
            return findByEntityId(entity.getParentEntityId(), (Class<Sb11SuperEntity>) entity.getParentEntityType()
                    .getEntityClass());
        } else {
            return findByEntityIdAndStateAbbreviation(entity.getParentEntityId(), entity.getStateAbbreviation(), entity
                    .getParentEntityType().getEntityClass());
        }
    }

    private Class<? extends Sb11Entity> convertTenantTypeToClass(final TenantType tenantType) {

        Class<? extends Sb11Entity> theClass = null;

        switch (tenantType) {
            case CLIENT:
                theClass = ClientEntity.class;
                break;
            case DISTRICT:
                theClass = DistrictEntity.class;
                break;
            case DISTRICT_GROUP:
                theClass = GroupOfDistrictsEntity.class;
                break;
            case INSTITUTION:
                theClass = InstitutionEntity.class;
                break;
            case INSTITUTION_GROUP:
                theClass = GroupOfInstitutionsEntity.class;
                break;
            case STATE:
                theClass = StateEntity.class;
                break;
            case STATE_GROUP:
                theClass = GroupOfStatesEntity.class;
                break;
            default:
                theClass = null;
                break;
        }

        return theClass;
    }

    private boolean checkIfStateChanged(final T domainObj, Sb11Entity dbEntity) {
        if (!(domainObj instanceof Sb11SuperEntity)) {
            if (!dbEntity.getStateAbbreviation().equalsIgnoreCase(domainObj.getStateAbbreviation())) {
                if (hasAssociatedEntity((T) dbEntity) || studentAssociationVerifier.verify(dbEntity).size() > 0
                        || userAssociationVerifier.verify(dbEntity).size() > 0) {
                    return true;
                }
            }
        }
        return false;
    }
}
