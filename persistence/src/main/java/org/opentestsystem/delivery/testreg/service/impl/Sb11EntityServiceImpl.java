/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.delivery.testreg.service.impl;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.annotation.Resource;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.delivery.testreg.domain.ClientEntity;
import org.opentestsystem.delivery.testreg.domain.DistrictEntity;
import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.GroupOfDistrictsEntity;
import org.opentestsystem.delivery.testreg.domain.GroupOfInstitutionsEntity;
import org.opentestsystem.delivery.testreg.domain.GroupOfStatesEntity;
import org.opentestsystem.delivery.testreg.domain.HierarchyLevel;
import org.opentestsystem.delivery.testreg.domain.InstitutionEntity;
import org.opentestsystem.delivery.testreg.domain.Sb11Entity;
import org.opentestsystem.delivery.testreg.domain.Sb11SuperEntity;
import org.opentestsystem.delivery.testreg.domain.StateEntity;
import org.opentestsystem.delivery.testreg.domain.User;
import org.opentestsystem.delivery.testreg.domain.User.RoleAssociation;
import org.opentestsystem.delivery.testreg.persistence.HierarchyLevelToFormatTypeConverter;
import org.opentestsystem.delivery.testreg.persistence.Sb11EntityRepository;
import org.opentestsystem.delivery.testreg.persistence.StudentGroupRepository;
import org.opentestsystem.delivery.testreg.persistence.StudentRepository;
import org.opentestsystem.delivery.testreg.persistence.Verifier;
import org.opentestsystem.delivery.testreg.service.Sb11EntityRepositoryService;
import org.opentestsystem.delivery.testreg.service.TestRegPersister;
import org.opentestsystem.delivery.testreg.service.TestRegistrationService;
import org.opentestsystem.delivery.testreg.service.UserService;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.progman.client.domain.TenantType;
import org.opentestsystem.shared.search.domain.AbstractSearchRequest;
import org.opentestsystem.shared.search.domain.SearchResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;

@SuppressWarnings({ "unchecked" })
@Service("sb11EntityService")
public class Sb11EntityServiceImpl<T extends Sb11Entity> implements TestRegistrationService<T>, Sb11EntityRepositoryService {

    @Resource
    private Map<FormatType, Sb11EntityRepository<Sb11Entity>> entityRepositoryMap;

    @Autowired
    private Sb11EntityRepository<Sb11Entity> sb11EntityRepository;

    @Autowired
    private TestRegPersister persister;

    @Autowired
    private StudentRepository studentRepository;
    @Autowired
    private StudentGroupRepository studentGroupRepository;

    @Resource(name = "studentAssociationVerifier")
    private Verifier<Sb11Entity> studentAssociationVerifier;

    @Resource(name = "userAssociationVerifier")
    private Verifier<Sb11Entity> userAssociationVerifier;

    @Autowired
    private UserService userService;

    /**
     * {@inheritDoc}
     */
    @Override
    public T findById(final String pkId, final FormatType formatType) {
        return (T) this.entityRepositoryMap.get(formatType).findOne(pkId);
    }
    
    @Override
    public <S extends Sb11Entity> List<S> findById(final Set<String> entityIds, final Class<S> clazz) {
        return this.sb11EntityRepository.findById(entityIds, clazz);
    }

    @Override
    public <S extends Sb11SuperEntity> S findByEntityId(final String entityId, final Class<S> clazz) {
        return this.sb11EntityRepository.findByEntityId(entityId, clazz);
    }

    @Override
    public <S extends Sb11Entity> S findByEntityIdAndStateAbbreviation(final String entityId, final String stateAbbreviation, final Class<S> clazz) {
        return this.sb11EntityRepository.findByEntityIdAndStateAbbreviation(entityId, stateAbbreviation, clazz);
    }

    @Override
    public List<T> findAllByParentEntityTypeAndParentEntityId(final String parentEntityType, final String parentEntityId, final FormatType formatType) {
        return (List<T>) this.entityRepositoryMap.get(formatType).findByParentEntityTypeAndParentEntityId(parentEntityType, parentEntityId);
    }

    @Override
    public <S extends Sb11Entity> List<S> findAllByParentEntityTypeAndParentId(final String parentEntityType, final String parentMongoId, final Class<S> clazz) {
        return this.sb11EntityRepository.findAllByParentEntityTypeAndParentId(parentEntityType, parentMongoId, clazz);
    }

    @Override
    public <S extends Sb11SuperEntity> S findByEntityId(final String entityId, final TenantType tenantType) {
        return this.sb11EntityRepository.findByEntityId(entityId, (Class<S>) convertTenantTypeToClass(tenantType));
    }

    @Override
    public <S extends Sb11Entity> S findByEntityIdAndStateAbbreviation(final String entityId, final String stateAbbreviation, final TenantType tenantType) {
        return this.sb11EntityRepository.findByEntityIdAndStateAbbreviation(entityId, stateAbbreviation, (Class<S>) convertTenantTypeToClass(tenantType));
    }

    @Override
    public <S extends Sb11Entity> List<S> findAllByEntityId(final String entityId, final Class<S> clazz) {
        return this.sb11EntityRepository.findAllByEntityId(entityId, clazz);
    }

    @Override
    public <S extends Sb11Entity> List<S> findAllByEntityIdAndEntityName(final String entityId, final String entityName, final Class<S> clazz) {
        return this.sb11EntityRepository.findAllByEntityIdAndEntityName(entityId, entityName, clazz);
    }

    @Override
    public List<T> findAllByParentEntityType(final String parentEntityType, final HierarchyLevel hierarchyLevel) {
        return (List<T>) this.entityRepositoryMap.get(FormatType.valueOf(hierarchyLevel.toString())).findByParentEntityType(parentEntityType);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<T> findAll(final FormatType formatType) {
        return (List<T>) this.entityRepositoryMap.get(formatType).findAll();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public T saveDomainObject(final T domainObj) {
        try {
            // before saving the entity lookup parent id and store parent id within the entity
            if (domainObj.getFormatType() != FormatType.CLIENT) {
                final Sb11Entity parent = getParentEntity(domainObj);
                if (parent != null) {
                    domainObj.setParentId(parent.getId());
                } else {
                    throw createParentEntityNotFoundException(domainObj.getParentEntityId());
                }
            }
            return this.entityRepositoryMap.get(domainObj.getFormatType()).save(domainObj);

        } catch (final DuplicateKeyException dke) {
            throw new LocalizedException("entity.already.exists", new String[] { domainObj.getFormatType().name(), getDuplicateKeyMessage(domainObj) }, dke);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public T updateDomainObject(final T domainObj) {
        Sb11Entity dbEntity = null;
        // if entity is updated from UI then it will have id
        if (domainObj.getId() != null) {
            dbEntity = findById(domainObj.getId(), domainObj.getFormatType());
        } else {
            dbEntity = this.sb11EntityRepository.findByAlternateKey(domainObj.createAlternateKeySearchRequest(), domainObj.getClass());
        }

        if (dbEntity != null) {
            if (checkIfStateChanged(domainObj, dbEntity)) {
                throw new LocalizedException("entity.state.changed", new String[] { });
            }
            domainObj.setId(dbEntity.getId());
        }
        final T updatedEntity = saveDomainObject(domainObj);
        if (dbEntity != null && !StringUtils.equals(domainObj.getEntityId(), dbEntity.getEntityId())) {
            // get all associated entities and update them with new entity id as their parent
            updateAssociatedEntities(dbEntity, domainObj.getEntityId());
        }

        return updatedEntity;
    }

    private void updateAssociatedEntities(final Sb11Entity entity, final String updatableEntityId) {
        // find entities whose parent is this entity
        for (final HierarchyLevel level : HierarchyLevel.values()) {
            if (level != HierarchyLevel.CLIENT) {
                final List<T> entities = findAllByParentEntityTypeAndParentEntityId(entity.getFormatType().toString().toUpperCase(), entity.getEntityId(), FormatType.valueOf(level.toString()));
                for (final T updentity : entities) {
                    updentity.setParentEntityId(updatableEntityId);
                    saveDomainObject(updentity);
                }
            }
        }
        // find and update students and student groups with associated entity
        if (entity.getFormatType() == FormatType.DISTRICT || entity.getFormatType() == FormatType.INSTITUTION) {
            this.studentRepository.updateEntityForStudentsByEntityFilter(entity.getEntityId(), updatableEntityId, entity.getEntityType());
            this.studentGroupRepository.updateEntityForStudentGroupsByEntityFilter(entity.getEntityId(), updatableEntityId, entity.getEntityType());
        }

        // find and update users with associated entity
        updateUsers(entity, updatableEntityId);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<T> saveDomainObjects(final List<T> domainObjList) {
        final List<T> savedEntities = new ArrayList<T>();
        if (!CollectionUtils.isEmpty(domainObjList)) {
            for (final T domainObj : domainObjList) {
                savedEntities.add(saveDomainObject(domainObj));
            }
        }
        return savedEntities;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public List<T> updateDomainObjects(final List<T> domainObjList) {
        List<T> updatedEntities = Lists.newArrayList();
        if (!CollectionUtils.isEmpty(domainObjList)) {
            final Map<String, T> associatedEntityUpdateMap = Maps.newHashMap();
            for (final T entity : domainObjList) {
                final Sb11Entity dbEntity = this.sb11EntityRepository.findByAlternateKey(entity.createAlternateKeySearchRequest(), entity.getClass());

                if (dbEntity != null) {
                    if (checkIfStateChanged(entity, dbEntity)) {
                        throw new LocalizedException("entity.state.changed", new String[] { });
                    }
                    entity.setId(dbEntity.getId());
                }
                if (entity.getFormatType() != FormatType.CLIENT) {
                    final Sb11Entity parent = getParentEntity(entity);
                    if (parent != null) {
                        entity.setParentId(parent.getId());
                    } else {
                        throw createParentEntityNotFoundException(entity.getParentEntityId());
                    }
                }
                if (dbEntity != null && !StringUtils.equals(entity.getEntityId(), dbEntity.getEntityId())) {
                    associatedEntityUpdateMap.put(entity.getEntityId(), (T) dbEntity);
                }
            }
            updatedEntities = this.entityRepositoryMap.get(domainObjList.get(0).getFormatType()).save(domainObjList);
            for (final Map.Entry<String, T> entityEntry : associatedEntityUpdateMap.entrySet()) {
                // get all associated entities and update them with new entity id as their parent
                updateAssociatedEntities(entityEntry.getValue(), entityEntry.getKey());
            }
        }
        return updatedEntities;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void deleteDomainObject(final T entity) {
        this.entityRepositoryMap.get(entity.getFormatType()).delete(entity);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void deleteDomainObject(final String pkId, final FormatType formatType) {
        this.entityRepositoryMap.get(formatType).delete(pkId);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void deleteDomainObjects(final List<T> entityList) {
        if (!CollectionUtils.isEmpty(entityList)) {
            for (final T entity : entityList) {
                Sb11Entity dbEntity = null;
                if (entity instanceof Sb11SuperEntity) {
                    dbEntity = this.sb11EntityRepository.findByEntityId(entity.getEntityId(), (Class<Sb11SuperEntity>) entity.getClass());
                } else {
                    dbEntity = this.sb11EntityRepository.findByEntityIdAndStateAbbreviation(entity.getEntityId(), entity.getStateAbbreviation(), entity.getClass());
                }
                if (dbEntity == null) {
                    throw createSb11EntityNotFoundException(entity.getEntityId());
                } else {
                    entity.setId(dbEntity.getId());
                    deleteDomainObject(entity);
                }
            }
        }
    }

    @Override
    public boolean hasAssociatedEntity(final T entity) {
        Sb11Entity dbEntity = null;
        if (entity instanceof Sb11SuperEntity) {
            dbEntity = this.sb11EntityRepository.findByEntityId(entity.getEntityId(), (Class<Sb11SuperEntity>) entity.getClass());
        } else {
            dbEntity = this.sb11EntityRepository.findByEntityIdAndStateAbbreviation(entity.getEntityId(), entity.getStateAbbreviation(), entity.getClass());
        }
        for (final HierarchyLevel level : HierarchyLevel.values()) {
            if (level != HierarchyLevel.CLIENT && level != dbEntity.getEntityType()) {
                final Long count = this.sb11EntityRepository.getEntityCountByParentId(dbEntity.getId(), level.getEntityClass());
                if (count != null && count > 0) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public SearchResponse<T> searchDomainObjects(final AbstractSearchRequest searchRequest, final FormatType formatType) {
        return (SearchResponse<T>) this.entityRepositoryMap.get(formatType).search(searchRequest);
    }

    private LocalizedException createSb11EntityNotFoundException(final String sb11EntityId) {
        return new LocalizedException("entity.not.found", new String[] { sb11EntityId });
    }

    private LocalizedException createParentEntityNotFoundException(final String parentEntityId) {
        return new LocalizedException("entity.parent.not.found", new String[] { parentEntityId });
    }

    private LocalizedException createFormatTypeException(final FormatType type) {
        return new LocalizedException("entity.invalid.formattype", new String[] { type.toString() });
    }

    /**
     * Get duplicate key error message based on entity format type.
     * 
     * @param entity
     *        entity
     * @return error message
     */
    private String getDuplicateKeyMessage(final T entity) {

        switch (entity.getFormatType()) {
        case STATE:
        case GROUPOFSTATES:
            return entity.getEntityId();
        case DISTRICT:
            final DistrictEntity distEntity = (DistrictEntity) entity;
            return distEntity.getEntityId().concat(" and ").concat(distEntity.getStateAbbreviation());
        case INSTITUTION:
            final InstitutionEntity institutionEntity = (InstitutionEntity) entity;
            return institutionEntity.getEntityId().concat(" and ").concat(institutionEntity.getStateAbbreviation());
        case GROUPOFDISTRICTS:
            final GroupOfDistrictsEntity groupOfDistricts = (GroupOfDistrictsEntity) entity;
            return groupOfDistricts.getEntityId().concat(" and ").concat(groupOfDistricts.getStateAbbreviation());
        case GROUPOFINSTITUTIONS:
            final GroupOfInstitutionsEntity groupOfInstitutions = (GroupOfInstitutionsEntity) entity;
            return groupOfInstitutions.getEntityId().concat(" and ").concat(groupOfInstitutions.getStateAbbreviation());
        default:
            throw createFormatTypeException(entity.getFormatType());
        }
    }

    private void updateUsers(final Sb11Entity entity, final String updatableEntityId) {
        final List<User> users = this.userService.findAllByRoleAssociationLevel(entity.getEntityId(),
                HierarchyLevel.valueOf(entity.getFormatType().toString().toUpperCase()));
        for (final User user : users) {
            for (final RoleAssociation roleAssociation : user.getRoleAssociations()) {
                if (roleAssociation.getAssociatedEntityId().equals(entity.getEntityId())) {
                    roleAssociation.setAssociatedEntityId(updatableEntityId);
                }
                this.persister.updateDomainObject(user);
            }
        }
    }

    @Override
    public Sb11Entity getParentEntity(final Sb11Entity entity) {
        if (!StringUtils.isEmpty(entity.getParentId())) {
            return findById(entity.getParentId(), HierarchyLevelToFormatTypeConverter.convertFrom(entity.getParentEntityType()));
        } else if (entity.getParentEntityType() == HierarchyLevel.CLIENT || entity.getParentEntityType() == HierarchyLevel.GROUPOFSTATES || entity.getParentEntityType() == HierarchyLevel.STATE) {
            return findByEntityId(entity.getParentEntityId(), (Class<Sb11SuperEntity>) entity.getParentEntityType().getEntityClass());
        } else {
            return findByEntityIdAndStateAbbreviation(entity.getParentEntityId(), entity.getStateAbbreviation(), entity.getParentEntityType().getEntityClass());
        }
    }

    private Class<? extends Sb11Entity> convertTenantTypeToClass(final TenantType tenantType) {

        Class<? extends Sb11Entity> theClass = null;

        switch (tenantType) {
        case CLIENT:
            theClass = ClientEntity.class;
            break;
        case DISTRICT:
            theClass = DistrictEntity.class;
            break;
        case DISTRICT_GROUP:
            theClass = GroupOfDistrictsEntity.class;
            break;
        case INSTITUTION:
            theClass = InstitutionEntity.class;
            break;
        case INSTITUTION_GROUP:
            theClass = GroupOfInstitutionsEntity.class;
            break;
        case STATE:
            theClass = StateEntity.class;
            break;
        case STATE_GROUP:
            theClass = GroupOfStatesEntity.class;
            break;
        default:
            theClass = null;
            break;
        }

        return theClass;
    }

    private boolean checkIfStateChanged(final T domainObj, final Sb11Entity dbEntity) {
        if (!(domainObj instanceof Sb11SuperEntity)) {
            if (!dbEntity.getStateAbbreviation().equalsIgnoreCase(domainObj.getStateAbbreviation())) {
                if (hasAssociatedEntity((T) dbEntity) || this.studentAssociationVerifier.verify(dbEntity).size() > 0
                        || this.userAssociationVerifier.verify(dbEntity).size() > 0) {
                    return true;
                }
            }
        }
        return false;
    }
}
