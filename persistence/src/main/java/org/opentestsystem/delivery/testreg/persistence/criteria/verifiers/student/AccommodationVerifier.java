/*******************************************************************************
 * Educational Online Test Delivery System Copyright (c) 2013 American
 * Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0 See accompanying
 * file AIR-License-1_0.txt or at http://www.smarterapp.org/documents/
 * American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/

package org.opentestsystem.delivery.testreg.persistence.criteria.verifiers.student;

import static org.opentestsystem.delivery.testreg.persistence.criteria.verifiers.VerifierUtils.addFieldError;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.validation.ConstraintValidatorContext;

import org.opentestsystem.delivery.testreg.domain.AccommodationResourceType;
import org.opentestsystem.delivery.testreg.domain.Student;
import org.opentestsystem.delivery.testreg.domain.constraintvalidators.AlphanumericValidator;
import org.opentestsystem.delivery.testreg.persistence.Verifier;
import org.opentestsystem.delivery.testreg.service.MasterResourceAccommodationService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;
import org.springframework.validation.FieldError;

@Component
public class AccommodationVerifier implements Verifier<Student>
{

  ConstraintValidatorContext                 context;
  @Autowired
  private MasterResourceAccommodationService masterResourceService;

  @Override
  public List<FieldError> verify (final Student student) {

   
    final Set<List<String>> duplicates = findDuplicateAccommodations (student);
    final List<FieldError> errors = new ArrayList<> ();
    if (duplicates != null && !CollectionUtils.isEmpty (duplicates)) {

      for (final List<String> accommodation : duplicates) {
        final String message = "Duplicate subject " + accommodation.get (0) + " in accommodation";
        addFieldError ( errors, student, "Accommodations", accommodation.get (0),  message);
      }

    }
    HashMap<String, String> accResourceTypes = masterResourceService.getAllResourceTypes ();
    accResourceTypes.put ("StudentId" ,AccommodationResourceType.SingleSelectResource.name () );
    accResourceTypes.put ("StateAbbreviation" , AccommodationResourceType.SingleSelectResource.name ());
    accResourceTypes.put ("Subject" ,AccommodationResourceType.SingleSelectResource.name () );
    List<Map<String, List<String>>> accommodationsList = getAccommodation (student);
    if(accommodationsList!=null) {
      for(final Map<String, List<String>> accommodation : accommodationsList){
        validateAccommodation (student, accommodation, accResourceTypes, errors);
      }
    }

    return errors;
  }

  private Set<List<String>> findDuplicateAccommodations (final Student student) {
    final Set<List<String>> accommodations = new HashSet<List<String>> ();
    Set<List<String>> duplicates = new HashSet<List<String>> ();
    List<Map<String, List<String>>> accommodationsList = getAccommodation (student);

    if(accommodationsList != null && accommodationsList.size () > 0) {
      for (final Map<String, List<String>> accommodation : accommodationsList) {
        if(!accommodation.get ("Subject").get (0).equals ("")){
          if (accommodations.contains (accommodation.get ("Subject"))) {
            duplicates.add (accommodation.get ("Subject"));
          } else {
            accommodations.add (accommodation.get ("Subject"));
          }
        }
      }
    }
    return duplicates;
  }

 
  /**
   * validateAccommodation is used to validate accommodation data from ui
   * 
   * @param student, accommodation, resourceType and error
   * 
   * @return true or false
   */
  private boolean validateAccommodation (Student student, Map<String, List<String>> accommodation, HashMap<String, String> accResourceTypes, List<FieldError> errors) {
    boolean isValid = true;
    AlphanumericValidator validator = new AlphanumericValidator ();
    for (Map.Entry<String, List<String>> entry : accommodation.entrySet ()) {
      String key = convertCodeToUpperCase(entry.getKey ());
      String orgKey = entry.getKey ();
      if (accResourceTypes.containsKey (key) && accResourceTypes.get (key).equalsIgnoreCase (AccommodationResourceType.SingleSelectResource.name ())) {

        switch (key) {

        case "StudentId": {
          List<String> value = accommodation.get (orgKey);
          if (value != null && value.size () == 0) {
            final String message = "Student Identifier is required";
            addFieldError (
                errors,
                student,
                "Accommodation",
                orgKey,
                message);
            isValid = false;
          }else if (value != null && value.size () == 1) {
            if (validator.processValidateWithVetoing (value.get (0), context)) {
              final String message = "Student Id be Alphanumeric";
              addFieldError (
                  errors,
                  student,
                  "Accommodation",
                  orgKey,
                  message);
              isValid = false;
            }

            if (value.get (0).length () > 40) {
              final String message = "Student Identifier size must be between 1 and 40";
              addFieldError (
                  errors,
                  student,
                  "Accommodation",
                  orgKey,
                  message);
              isValid = false;
            }
          }
        }
        break;
        case "StateAbbreviation": {
          List<String> value = accommodation.get (orgKey);
          if (value != null && value.size () == 0) {
            final String message = "State Abbreviation is required";
            addFieldError (
                errors,
                student,
                "Accommodation",
                orgKey,
                message);
            isValid = false;
          }
        }
        break;
        case "Subject": {
          List<String> value = accommodation.get (orgKey);
          if("".equals(value.get(0)) && value.size () == 1){
              final String message = "Subject is required";
              addFieldError (
                  errors,
                  student,
                  "Accommodation",
                  orgKey,
                  message);
              isValid = false;
            }
            
          else if (validator.processValidateWithVetoing (value.get (0), context)) {
              final String message = "Subject should be alphanumeric";
              addFieldError (
                  errors,
                  student,
                  "Accommodation",
                  orgKey,
                  message);
              isValid = false;
            }

          else if (value.get (0).length () > 20) {
              final String message = "Subject size must be between 1 and 20";
              addFieldError (
                  errors,
                  student,
                  "Accommodation",
                  orgKey,
                  message);
              isValid = false;
            }
        }
        break;
        }
      } else if (accResourceTypes.containsKey (key) && accResourceTypes.get (key).equalsIgnoreCase (AccommodationResourceType.EditResource.name ())){

        List<String> value = accommodation.get (orgKey);
        if (value != null && value.size () == 1) {
         StringBuffer regex = new StringBuffer();
         regex.append ("^[a-zA-Z\\d\\s\\-\\.]*$");
          if (!validator.processValidateWithVetoing (regex, value.get (0), context)) {
            final String message = "Valid values for " + orgKey +" accommodation are alphanumeric characters, spaces, dashes, and periods";
            addFieldError (
                errors,
                student,
                "Accommodation",
                orgKey,
                message);
            isValid = false;
          }

          if (value.get(0).length () > 90) {
            final String message = "Maximum length for "+ orgKey +" accommodation is 90 characters";
            addFieldError (
                errors,
                student,
                "Accommodation",
                orgKey,
                message);
            isValid = false;
          }

        }
      }
    }
    return isValid;
  }

  /**
   * @param student
   * @return
   */
  private List<Map<String, List<String>>> getAccommodation (Student student) {

    Object[] accommodations = student.getAccommodations ();
    List<Map<String, List<String>>> accFinal = null;
    LinkedHashMap<String, Object> accommTemp = null;
    LinkedHashMap<String, List<String>> accomm = null;
    List<String> values = null;
    
    HashMap<String, String> accResourceTypes = masterResourceService.getAllResourceTypes ();
    accResourceTypes.put ("StudentId" ,AccommodationResourceType.SingleSelectResource.name () );
    accResourceTypes.put ("StateAbbreviation" , AccommodationResourceType.SingleSelectResource.name ());
    accResourceTypes.put ("Subject" ,AccommodationResourceType.SingleSelectResource.name () );
    
    if(accommodations != null){
      accFinal = new ArrayList<Map<String, List<String>>> ();
      for(Object accommodationObj : accommodations )
      {
        accomm = new LinkedHashMap<String, List<String>>();
        accommTemp = (LinkedHashMap<String, Object>)accommodationObj;
        for(String key : accommTemp.keySet ()){
          Object val = accommTemp.get (key);
          key = convertCodeToUpperCase(key);
          if(val != null) {
            if (accResourceTypes.containsKey (key) && accResourceTypes.get (key).equalsIgnoreCase (AccommodationResourceType.SingleSelectResource.name ())){
              values = new ArrayList<String>();
              values.add(val.toString ());
            } else if (accResourceTypes.containsKey (key) && accResourceTypes.get (key).equalsIgnoreCase (AccommodationResourceType.MultiSelectResource.name ())){
              values = Arrays.asList (val.toString().replaceAll ("\\[", "").replaceAll ("\\]", "").split ("\\s*,\\s*"));
            } else if (accResourceTypes.containsKey (key) && accResourceTypes.get (key).equalsIgnoreCase (AccommodationResourceType.EditResource.name ())){
              values = new ArrayList<String>();
              values.add(val.toString ());
            }
            accomm.put (key, values);
          }else{
            values = new ArrayList<String>();
            values.add("");
            accomm.put (key, values);
          }
          
        }
        accFinal.add (accomm);
      }
    }
    return accFinal;
  }
  
  private String convertCodeToUpperCase (String code) {
    return code != null ? code.substring (0, 1).toUpperCase ().concat (code.substring (1)) : code;
  }

}
