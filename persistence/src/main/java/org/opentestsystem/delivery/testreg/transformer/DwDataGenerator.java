/*
Educational Online Test Delivery System Copyright (c) 2013 American Institutes for Research

Distributed under the AIR Open Source License, Version 1.0 See accompanying file AIR-License-1_0.txt or at
http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 */

package org.opentestsystem.delivery.testreg.transformer;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.annotation.Resource;

import org.joda.time.DateTime;
import org.joda.time.format.DateTimeFormat;
import org.joda.time.format.DateTimeFormatter;
import org.opentestsystem.delivery.testreg.domain.Assessment;
import org.opentestsystem.delivery.testreg.domain.ClientEntity;
import org.opentestsystem.delivery.testreg.domain.DistrictEntity;
import org.opentestsystem.delivery.testreg.domain.EligibleStudent;
import org.opentestsystem.delivery.testreg.domain.InstitutionEntity;
import org.opentestsystem.delivery.testreg.domain.MnaAlertType;
import org.opentestsystem.delivery.testreg.domain.Sb11Entity;
import org.opentestsystem.delivery.testreg.domain.StateEntity;
import org.opentestsystem.delivery.testreg.persistence.DistrictEntityRepository;
import org.opentestsystem.delivery.testreg.persistence.EligibleStudentRepository;
import org.opentestsystem.delivery.testreg.persistence.InstitutionEntityRepository;
import org.opentestsystem.delivery.testreg.persistence.Sb11EntityRepository;
import org.opentestsystem.delivery.testreg.service.TestRegPersister;
import org.opentestsystem.delivery.testreg.transformer.domain.DwConfigs;
import org.opentestsystem.delivery.testreg.transformer.domain.DwConfigs.DwConfig;
import org.opentestsystem.delivery.testreg.transformer.domain.DwConfigs.DwConfigType;
import org.opentestsystem.shared.mna.client.domain.MnaSeverity;
import org.opentestsystem.shared.mna.client.service.AlertBeacon;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.integration.Message;
import org.springframework.integration.annotation.Header;
import org.springframework.integration.annotation.ServiceActivator;
import org.springframework.integration.support.MessageBuilder;
import org.springframework.stereotype.Component;
import org.supercsv.io.CsvListWriter;
import org.supercsv.io.ICsvListWriter;
import org.supercsv.prefs.CsvPreference;
import org.supercsv.quote.NormalQuoteMode;

import com.fasterxml.jackson.databind.ObjectMapper;

/**
 * Used to generate data that is exported to the data warehouse. A JSON metadata file is generated along with a CSV file
 * that is a dump of all eligible students.
 * 
 */
@Component
public class DwDataGenerator {

    private static final Logger LOGGER = LoggerFactory.getLogger(DwDataGenerator.class);

    private static final String BASE_CSV_NAME = "registration_extract-";
    private static final String CSV_EXTENSION = ".csv";
    private static final String BASE_JSON_NAME = "json_metadata-";
    private static final String JSON_EXTENSION = ".json";

    private static final String DATE_TIME_FORMAT = "YYYY-MM-dd";

    private static final String CONTENT_STRING = "StudentRegistration";

    private static final DateTimeFormatter DT_FORMAT = DateTimeFormat.forPattern(DATE_TIME_FORMAT);

    private static final String UUID_PATTERN = "\\w{8}-\\w{4}-\\w{4}-\\w{4}-(\\w{12})";

    private static final String FAILURE_MESSAGE = "Failure to generate DW data";

    private static final long PAGE_SIZE = 5000;

    @Autowired
    private EligibleStudentRepository eligStudentRepo;

    @Autowired
    private Sb11EntityRepository<Sb11Entity> sb11EntityRepository;

    @Autowired
    private DistrictEntityRepository districtRepository;

    @Autowired
    private InstitutionEntityRepository institutionRepository;

    /**
     * jackson object mapper for JSON export
     */
    @Autowired
    private ObjectMapper objectMapper;

    @Autowired
    private TestRegPersister persister;

    @Autowired
    private AlertBeacon alertBeacon;

    @Autowired
    private DwConfigs dwConfigs;

    /**
     * data warehouse csv file header is configured as a spring bean
     */
    @Resource
    private String[] dwHeader;

    @Value("${dw.export.callback.url}")
    private String callbackUrl;

    /**
     * Searches the assessments that students are eligible for and returns the unique academic years.
     * 
     * @return List<String>
     */
    public List<String> findUniqueAcademicYears() {

        return eligStudentRepo.findUniqueAcademicYears();

    }

    /**
     * Find all records in the EligibleStudent collection and generate flat file CSV data.
     * 
     * Flat file format is: StateName, StateAbbreviation, ResponsibleDistrictIdentifier, OrganizationName,
     * ResponsibleSchoolIdentifier, NameOfInstitution, StudentIdentifier,ExternalSSID, FirstName, MiddleName,
     * LastOrSurname, Sex, Birthdate, GradeLevelWhenAssessed, HispanicOrLatinoEthnicity, AmericanIndianOrAlaskaNative,
     * Asian, BlackOrAfricanAmerican, NativeHawaiianOrOtherPacificIslander, White, IDEAIndicator, LEPStatus, 504Status,
     * EconomicDisadvantageStatus, MigrantStatus, DemographicRaceTwoOrMoreRaces, LanguageCode,
     * EnglishLanguageProficiencLevel, FirstEntryDateIntoUSSchool, LimitedEnglishProficiencyEntryDate, LEPExitDate,
     * TitleIIILanguageInstructionProgramType, PrimaryDisabilityType
     * 
     * Also generate JSON metadata.
     * 
     * { "Content" : "StudentRegistration", "Identification" : { "Guid" : "009a34ee-4609-4b13-8ca2-ed1bc0386afb",
     * "AcademicYear" : "2015", "ExtractDate" : "2014-02-04" }, "Source" : { "TestRegSysID" :
     * "800b3654-4406-4a90-9591-be84b67054df", "TestRegCallbackURL" : "StateTestReg.gov/StuReg/CallBack" } }
     * 
     * @return
     */
    @ServiceActivator(inputChannel = "dataWarehouseGeneration", outputChannel = "tarInput")
    public Message<String[]> generateDwData(final String academicYear, final @Header("dwBatchUuid") String dwBatchUuid,
            final @Header("fileSuffix") String fileSuffix, final @Header("dwConfigType") DwConfigType dwConfigType)
            throws DwDataGenerationException {

        String debugPrefix = dwConfigType + " DW Config: ";

        DwConfig dwConfig = null;

        if (DwConfigType.SBAC == dwConfigType) {
            dwConfig = dwConfigs.getSbacConfig();
        } else {
            dwConfig = dwConfigs.getLocalConfig();
        }

        String[] assessmentTypes = findAssessmentTypes(dwConfig);

        List<Path> tempPaths = new ArrayList<Path>();

        long curTime = System.currentTimeMillis();
        String[] dwData = new String[6];
        String todayString = getTodaysDate();

        long recordsSent = eligStudentRepo.countByAcademicYearAndType(academicYear, assessmentTypes);

        LOGGER.debug(debugPrefix + "Generating DW CSV data for " + recordsSent + " students");

        long numPages = recordsSent / PAGE_SIZE;
        long remain = recordsSent % PAGE_SIZE;

        if (remain > 0) {
            numPages++;
        }

        LOGGER.debug(debugPrefix + "Chunking students into " + numPages + " pages of size " + PAGE_SIZE);

        File tmpCsvFile;
        FileWriter csvFileWriter;

        try {
            Path tempCsvPath = Files.createTempFile(DwBatchHandler.DW_CSV_TMP_PREFIX,
                    (dwConfigType == DwConfigType.SBAC ? DwBatchHandler.SBAC_DW_NAME : DwBatchHandler.LOCAL_DW_NAME)
                            + fileSuffix);
            tempPaths.add(tempCsvPath);
            tmpCsvFile = tempCsvPath.toFile();
            csvFileWriter = new FileWriter(tmpCsvFile);
            LOGGER.debug(debugPrefix + "Created temp CSV file: " + tmpCsvFile.getAbsolutePath());
        } catch (IOException e1) {
            throw new DwDataGenerationException(debugPrefix
                    + "Failure to generate data warehouse data, unable to create temp csv file", e1);
        }

        CsvPreference csvPrefs = new CsvPreference.Builder('\"', ',', "\n").useQuoteMode(new NormalQuoteMode()).build();

        ICsvListWriter listWriter = null;
        try {
            listWriter = new CsvListWriter(csvFileWriter, csvPrefs);

            // write the header
            listWriter.writeHeader(dwHeader);
            LOGGER.debug(debugPrefix + "Wrote CSV file header");

            List<EligibleStudent> eligibleStudents = null;
            String eligStudentMongoId = "000000000000000000000000";

            for (long curPage = 0; curPage < numPages; curPage++) {
                long pageCurTime = System.currentTimeMillis();
                eligibleStudents = eligStudentRepo.findByAcademicYearAndType(academicYear, assessmentTypes,
                        eligStudentMongoId, "_id", (int) PAGE_SIZE);

                for (EligibleStudent eligStudent : eligibleStudents) {
                    listWriter.write(convertToArray(eligStudent, dwConfig.isShareStudentIdentityData()));
                }

                eligStudentMongoId = eligibleStudents.get(eligibleStudents.size() - 1).getId();

                listWriter.flush();

                LOGGER.debug(debugPrefix + "Wrote page " + curPage + " to CSV file in "
                        + (System.currentTimeMillis() - pageCurTime));
            }

        } catch (IOException e) {
            throw new DwDataGenerationException(debugPrefix + "Failure to generate data warehouse data", e);
        } finally {
            if (listWriter != null) {
                try {
                    listWriter.close();
                } catch (IOException e) {
                    // ignore the exception on close
                }
            }
        }

        dwData[0] = BASE_CSV_NAME
                + (dwConfigType == DwConfigType.SBAC ? DwBatchHandler.SBAC_DW_NAME : DwBatchHandler.LOCAL_DW_NAME)
                + fileSuffix + CSV_EXTENSION;
        dwData[1] = tmpCsvFile.getAbsolutePath();
        dwData[2] = String.valueOf(tmpCsvFile.length());

        File tmpJsonFile;
        FileWriter jsonFileWriter;

        try {
            Path tempJsonPath = Files.createTempFile(DwBatchHandler.DW_JSON_TMP_PREFIX,
                    (dwConfigType == DwConfigType.SBAC ? DwBatchHandler.SBAC_DW_NAME : DwBatchHandler.LOCAL_DW_NAME)
                            + fileSuffix);
            tempPaths.add(tempJsonPath);
            tmpJsonFile = tempJsonPath.toFile();
            jsonFileWriter = new FileWriter(tmpJsonFile);
            LOGGER.debug(debugPrefix + "Created temp JSON file " + tmpJsonFile.getAbsolutePath());
        } catch (IOException e1) {
            throw new DwDataGenerationException(debugPrefix
                    + "Failure to generate data warehouse data, unable to create temp json file", e1);
        }

        DwJsonMetadata jsonMetadata = new DwJsonMetadata();
        jsonMetadata.setContent(CONTENT_STRING);

        DwJsonMetadata.Ident ident = new DwJsonMetadata.Ident();
        ident.setAcademicYear(academicYear);
        ident.setExtractDate(todayString);
        ident.setGuid(dwBatchUuid);
        jsonMetadata.setIdentification(ident);

        DwJsonMetadata.Src src = new DwJsonMetadata.Src();
        src.setTestRegSysID(findSystemId());
        src.setTestRegCallbackURL(callbackUrl);
        jsonMetadata.setSource(src);

        try {
            objectMapper.writeValue(jsonFileWriter, jsonMetadata);
        } catch (IOException e) {
            throw new DwDataGenerationException(debugPrefix + FAILURE_MESSAGE, e);
        }

        dwData[3] = BASE_JSON_NAME
                + (dwConfigType == DwConfigType.SBAC ? DwBatchHandler.SBAC_DW_NAME : DwBatchHandler.LOCAL_DW_NAME)
                + fileSuffix + JSON_EXTENSION;
        dwData[4] = tmpJsonFile.getAbsolutePath();
        dwData[5] = String.valueOf(tmpJsonFile.length());

        try {
            jsonFileWriter.close();
        } catch (IOException e) {
            throw new DwDataGenerationException(debugPrefix + FAILURE_MESSAGE, e);
        }

        LOGGER.debug(debugPrefix + "Generated all CSV and JSON data in " + (System.currentTimeMillis() - curTime));

        return MessageBuilder.withPayload(dwData).setHeader("dwBatchUuid", dwBatchUuid)
                .setHeader("fileSuffix", fileSuffix).setHeader("recordsSent", recordsSent)
                .setHeader("tempPaths", tempPaths).setHeader("dwConfigType", dwConfigType).build();
    }

    private String findSystemId() {

        String systemId = null;

        List<ClientEntity> clientEntities = persister.findAll(ClientEntity.FORMAT_TYPE);
        if (clientEntities != null && !clientEntities.isEmpty()) {
            ClientEntity clientEntity = clientEntities.get(0);

            systemId = clientEntity.getSystemId();

            if (systemId == null || systemId.trim().isEmpty()) {
                // send alert and default
                systemId = "00000000-0000-0000-0000-000000000000";
                alertBeacon.sendAlert(MnaSeverity.ERROR, MnaAlertType.DATAWAREHOUSE_CALLBACK.name(),
                        "Test Reg System GUID is not specified in Client Configuration, defaulting to all zeroes");
            } else {
                Pattern uuidPattern = Pattern.compile(UUID_PATTERN);
                Matcher matcher = uuidPattern.matcher(systemId);

                boolean uuidpatternmatches = matcher.matches();
                if (!uuidpatternmatches) {
                    alertBeacon.sendAlert(MnaSeverity.ERROR, MnaAlertType.DATAWAREHOUSE_CALLBACK.name(),
                            "Test Reg System GUID is not in the valid format.");
                }
            }

        } else {
            // send alert and default
            systemId = "00000000-0000-0000-0000-000000000000";
            alertBeacon.sendAlert(MnaSeverity.ERROR, MnaAlertType.DATAWAREHOUSE_CALLBACK.name(),
                    "Test Reg System GUID is not specified in Client Configuration, defaulting to all zeroes");
        }

        return systemId;
    }

    private String[] findAssessmentTypes(DwConfig config) {

        String[] types = config.getAssessmentTypesForExport();
        
        if (types == null || types.length == 0) {
            // send alert and default
            types = Assessment.AssessmentType.getTypes().toArray(new String[0]);
            alertBeacon.sendAlert(
                    MnaSeverity.ERROR,
                    MnaAlertType.DATAWAREHOUSE_CALLBACK.name(),
                    "Data Warehouse Export Types are not specified in Data Warehouse Configuration for "
                            + config.getConfigType() + ", defaulting");
        }else{
          for (int i = 0; i < types.length; i++)
            types[i] = types[i].trim();
        }

        return types;
    }

    /**
     * Generate in the order: StateName, StateAbbreviation, ResponsibleDistrictIdentifier, OrganizationName,
     * ResponsibleSchoolIdentifier, NameOfInstitution, StudentIdentifier,ExternalSSID, FirstName, MiddleName,
     * LastOrSurname, Sex, Birthdate, GradeLevelWhenAssessed, HispanicOrLatinoEthnicity, AmericanIndianOrAlaskaNative,
     * Asian, BlackOrAfricanAmerican, NativeHawaiianOrOtherPacificIslander, White, IDEAIndicator, LEPStatus, 504Status,
     * EconomicDisadvantageStatus, MigrantStatus, DemographicRaceTwoOrMoreRaces, LanguageCode,
     * EnglishLanguageProficiencLevel, FirstEntryDateIntoUSSchool, LimitedEnglishProficiencyEntryDate, LEPExitDate,
     * TitleIIILanguageInstructionProgramType, PrimaryDisabilityType
     * 
     * @param eligibleStudent
     * @return
     */
    private String[] convertToArray(final EligibleStudent eligibleStudent, final boolean shareIdentityData) {

        // LOGGER.debug("Converting eligibleStudent id: " + eligibleStudent.getStudent().getEntityId()
        // + ", assessment academic year: " + eligibleStudent.getAssessmentsAsList().get(0).getAcademicYear());

        String[] strings = new String[dwHeader.length];

        StateEntity state = sb11EntityRepository.findByEntityId(eligibleStudent.getStudent().getStateAbbreviation(),
                StateEntity.class);

        strings[0] = state.getEntityName(); // req
        strings[1] = eligibleStudent.getStudent().getStateAbbreviation(); // req
        strings[2] = eligibleStudent.getStudent().getDistrictIdentifier(); // req

        DistrictEntity district = districtRepository.findOne(eligibleStudent.getStudent().getDistrictEntityMongoId());

        strings[3] = district.getEntityName(); // req
        strings[4] = eligibleStudent.getStudent().getInstitutionIdentifier(); // req

        InstitutionEntity institution = institutionRepository.findOne(eligibleStudent.getStudent()
                .getInstitutionEntityMongoId());

        strings[5] = institution.getEntityName(); // req
        // SB-1419: When sending de-identified data, send ExternalSSID string in place of the SSID field,since the SSID is considered PII.
        // The SSID column should really be BLANK in this situation,
        // but Reporting application erroneously requires this field to be present at all times.
        // In the future, this will be corrected in the spec as well as the Reporting app and this can be fixed here as well.
        strings[6] = shareIdentityData ? eligibleStudent.getStudent().getEntityId() : eligibleStudent.getStudent().getExternalSsid(); // req
        strings[7] = eligibleStudent.getStudent().getExternalSsid() ; // req
        strings[8] = shareIdentityData ? eligibleStudent.getStudent().getFirstName() : null; // opt
        strings[9] = shareIdentityData ? eligibleStudent.getStudent().getMiddleName() : null; // opt
        strings[10] = shareIdentityData ? eligibleStudent.getStudent().getLastName() : null; // opt
        strings[11] = eligibleStudent.getStudent().getGender().toString(); // req
        strings[12] = shareIdentityData ? (eligibleStudent.getStudent().getBirthDate() != null ? eligibleStudent
                .getStudent().getBirthDate().toString(DT_FORMAT) : null) : null; // opt
        strings[13] = eligibleStudent.getStudent().getGradeLevelWhenAssessed().getGrade(); // req
        strings[14] = eligibleStudent.getStudent().getHispanicOrLatino() == null
                || eligibleStudent.getStudent().getHispanicOrLatino().equals("") ? "NO" : eligibleStudent.getStudent()
                .getHispanicOrLatino(); // opt
        strings[15] = eligibleStudent.getStudent().getAmericanIndianOrAlaskaNative() == null
                || eligibleStudent.getStudent().getAmericanIndianOrAlaskaNative().equals("") ? "NO" : eligibleStudent
                .getStudent().getAmericanIndianOrAlaskaNative(); // opt
        strings[16] = eligibleStudent.getStudent().getAsian() == null
                || eligibleStudent.getStudent().getAsian().equals("") ? "NO" : eligibleStudent.getStudent().getAsian(); // opt
        strings[17] = eligibleStudent.getStudent().getBlackOrAfricanAmerican() == null
                || eligibleStudent.getStudent().getBlackOrAfricanAmerican().equals("") ? "NO" : eligibleStudent
                .getStudent().getBlackOrAfricanAmerican(); // opt
        strings[18] = eligibleStudent.getStudent().getNativeHawaiianOrPacificIsland() == null
                || eligibleStudent.getStudent().getNativeHawaiianOrPacificIsland().equals("") ? "NO" : eligibleStudent
                .getStudent().getNativeHawaiianOrPacificIsland(); // opt
        strings[19] = eligibleStudent.getStudent().getWhite() == null
                || eligibleStudent.getStudent().getWhite().equals("") ? "NO" : eligibleStudent.getStudent().getWhite(); // opt
        strings[20] = eligibleStudent.getStudent().getiDEAIndicator(); // opt
        strings[21] = eligibleStudent.getStudent().getLepStatus(); // opt
        if(eligibleStudent.getStudent().getSection504Status().equalsIgnoreCase ("Unknown/Cannot Provide")){
          eligibleStudent.getStudent().setSection504Status ("");
        }
        strings[22] = eligibleStudent.getStudent().getSection504Status().toString(); // opt
        strings[23] = eligibleStudent.getStudent().getDisadvantageStatus(); // opt
        strings[24] = eligibleStudent.getStudent().getMigrantStatus(); // opt
        strings[25] = eligibleStudent.getStudent().getTwoOrMoreRaces() == null
                || eligibleStudent.getStudent().getTwoOrMoreRaces().equals("") ? "NO" : eligibleStudent.getStudent()
                .getTwoOrMoreRaces(); // opt
        strings[26] = eligibleStudent.getStudent().getLanguageCode(); // opt
        strings[27] = eligibleStudent.getStudent().getTitle3ProgressStatus() != null ? eligibleStudent.getStudent()
                .getTitle3ProgressStatus().toString() : null; // opt
        strings[28] = eligibleStudent.getStudent().getFirstEntryDateIntoUsSchool() != null ? eligibleStudent
                .getStudent().getFirstEntryDateIntoUsSchool().toString(DT_FORMAT) : null; // opt
        strings[29] = eligibleStudent.getStudent().getLepEntryDate() != null ? eligibleStudent.getStudent()
                .getLepEntryDate().toString(DT_FORMAT) : null; // opt
        strings[30] = eligibleStudent.getStudent().getLepExitDate() != null ? eligibleStudent.getStudent()
                .getLepExitDate().toString(DT_FORMAT) : null; // opt
        strings[31] = eligibleStudent.getStudent().getTitle3ProgramType() != null ? eligibleStudent.getStudent()
                .getTitle3ProgramType().getDescription() : null; // opt
        strings[32] = eligibleStudent.getStudent().getPrimaryDisabilityType() != null ? eligibleStudent.getStudent()
                .getPrimaryDisabilityType().getDescription() : null; // opt

        return strings;
    }

    private String getTodaysDate() {
        DateTime today = new DateTime();

        return today.toString(DT_FORMAT);
    }

    /**
     * Small class that models the json metadata to be sent to the data warehouse to be used solely for easily
     * marshalling the data into JSON by jackson.
     * 
     * { "Content" : "StudentRegistration", "Identification" : { "Guid" : "009a34ee-4609-4b13-8ca2-ed1bc0386afb",
     * "AcademicYear" : "2015", "ExtractDate" : "2014-02-04" }, "Source" : { "TestRegSysID" :
     * "800b3654-4406-4a90-9591-be84b67054df", "TestRegCallbackURL" : "StateTestReg.gov/StuReg/CallBack" } }
     */
    public static class DwJsonMetadata {
        private String Content;
        private Ident Identification;
        private Src Source;

        public static class Ident {
            private String Guid;
            private String AcademicYear;
            private String ExtractDate;

            public String getGuid() {
                return Guid;
            }

            public void setGuid(final String guid) {
                Guid = guid;
            }

            public String getAcademicYear() {
                return AcademicYear;
            }

            public void setAcademicYear(final String academicYear) {
                AcademicYear = academicYear;
            }

            public String getExtractDate() {
                return ExtractDate;
            }

            public void setExtractDate(final String extractDate) {
                ExtractDate = extractDate;
            }
        }

        public static class Src {
            private String TestRegSysID;
            private String TestRegCallbackURL;

            public String getTestRegSysID() {
                return TestRegSysID;
            }

            public void setTestRegSysID(final String testRegSysID) {
                TestRegSysID = testRegSysID;
            }

            public String getTestRegCallbackURL() {
                return TestRegCallbackURL;
            }

            public void setTestRegCallbackURL(final String testRegCallbackURL) {
                TestRegCallbackURL = testRegCallbackURL;
            }
        }

        public String getContent() {
            return Content;
        }

        public void setContent(final String content) {
            Content = content;
        }

        public Ident getIdentification() {
            return Identification;
        }

        public void setIdentification(final Ident identification) {
            Identification = identification;
        }

        public Src getSource() {
            return Source;
        }

        public void setSource(final Src source) {
            Source = source;
        }
    }

}
