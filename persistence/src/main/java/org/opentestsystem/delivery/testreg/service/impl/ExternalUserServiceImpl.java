/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2016 Regents of the University of California
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 *
 * SmarterApp Open Source Assessment Software Project: http://smarterapp.org
 * Developed by Fairway Technologies, Inc. (http://fairwaytech.com)
 * for the Smarter Balanced Assessment Consortium (http://smarterbalanced.org)
 ******************************************************************************/

package org.opentestsystem.delivery.testreg.service.impl;

import org.codehaus.jackson.map.ObjectMapper;
import org.codehaus.jackson.map.ObjectWriter;
import org.opentestsystem.delivery.testreg.domain.HierarchyLevel;
import org.opentestsystem.delivery.testreg.domain.SSOAction;
import org.opentestsystem.delivery.testreg.domain.Sb11Entity;
import org.opentestsystem.delivery.testreg.domain.StateEntity;
import org.opentestsystem.delivery.testreg.domain.User;
import org.opentestsystem.delivery.testreg.domain.UserChangeEvent;
import org.opentestsystem.delivery.testreg.domain.UserUpsert;
import org.opentestsystem.delivery.testreg.persistence.HierarchyLevelToFormatTypeConverter;
import org.opentestsystem.delivery.testreg.service.ExternalUserService;
import org.opentestsystem.delivery.testreg.service.Sb11EntityLocatorService;
import org.opentestsystem.delivery.testreg.service.StateService;
import org.opentestsystem.delivery.testreg.service.TestRegPersister;
import org.opentestsystem.delivery.testreg.service.TestRegUserDetailsService;
import org.opentestsystem.delivery.testreg.service.UserChangeEventService;
import org.opentestsystem.delivery.testreg.service.UserService;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.security.domain.SbacUser;
import org.opentestsystem.shared.security.domain.permission.SbacPermissionEntity;
import org.opentestsystem.shared.security.domain.permission.UserRole;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

@Service
public class ExternalUserServiceImpl implements ExternalUserService {

    private static final Logger LOGGER = LoggerFactory.getLogger(ExternalUserServiceImpl.class);

    private ObjectWriter objectWriter = new ObjectMapper().writer().withDefaultPrettyPrinter();

    @Autowired
    public ExternalUserServiceImpl(UserService userService, @Qualifier("userDetailService") TestRegUserDetailsService testRegUserDetailsService
            , TestRegPersister testRegPersister, UserChangeEventService userChangeEventService, StateService stateSevice
            , Sb11EntityLocatorService entityLocatorService) {
        this.userService = userService;
        this.userDetailsService = testRegUserDetailsService;
        this.persistenceService = testRegPersister;
        this.userChangeEventService = userChangeEventService;
        this.stateService = stateSevice;
        this.entityLocatorService = entityLocatorService;
    }

    private UserService userService;

    private TestRegUserDetailsService userDetailsService;

    private TestRegPersister persistenceService;

    private UserChangeEventService userChangeEventService;

    private StateService stateService;

    private Sb11EntityLocatorService entityLocatorService;

    private String produceJsonValueForObject(Object object) {
        try {
            return objectWriter.writeValueAsString(object);
        } catch(IOException e) {
            return "An IOException occurred";
        }
    }

    @Override
    public UserUpsert upsertUser(User user) {
        LOGGER.info("Entering upsertUser method with user: " + produceJsonValueForObject(user));
        UserUpsert upsert = new UserUpsert();
        User existingUser = userService.findByEmail(user.getEmail());
        if(existingUser != null) {
            LOGGER.info("upsertUser found an existing user: " + produceJsonValueForObject(existingUser));
            upsert.setInsert(false);
            user = decorateUser(user, existingUser);
        }
        user = validateUserRoles(user);
        LOGGER.info("userUpsert attempting to save user: " + produceJsonValueForObject(user));
        upsert.setUser(persistenceService.saveDomainObject(user));
        LOGGER.info("upsertUser saved user - returning upsert object: " + produceJsonValueForObject(upsert));
        return upsert;
    }

    private User decorateUser(User newUser, User existingUser) {
        LOGGER.info("Entering decorateUser method with user: " + produceJsonValueForObject(newUser)
                + "  and existingUser: " + produceJsonValueForObject(existingUser));
        newUser.setId(existingUser.getId());
        newUser.setHasRolesOutside(existingUser.getHasRolesOutside());
        LOGGER.info("Exiting decorateUser method with user: " + produceJsonValueForObject(newUser));
        return newUser;
    }

    private User validateUserRoles(User user) {
        LOGGER.info("Entering validateUserRoles method with user: " + produceJsonValueForObject(user));
        List<UserRole> accessibleUserRoles = userDetailsService.getAllUserRolesForCurrentUser();
        LOGGER.info("All roles available to user in validateUserRoles: " + produceJsonValueForObject(accessibleUserRoles));
        for (User.RoleAssociation roleAssociation : user.getRoleAssociations()) {
            LOGGER.info("Validating role of user (validateUserRoles): " + produceJsonValueForObject(roleAssociation));
            validateUserRole(accessibleUserRoles, roleAssociation);
        }
        LOGGER.info("Exiting validateUserRoles method with user: " + produceJsonValueForObject(user));
        return user;
    }

    private void validateUserRole(List<UserRole> accessibleUserRoles, User.RoleAssociation roleAssociation) {
        LOGGER.info("Entering validateUserRole method with roleAssociation: " + produceJsonValueForObject(roleAssociation));
        boolean acceptableRole = false;
        for(UserRole userRole : accessibleUserRoles) {
            LOGGER.info("validateUserRole checking provided User.RoleAssociation object against UserRole in accessibleUserRoles: "
                    + produceJsonValueForObject(userRole));
            if(userRole.getRole().equals(roleAssociation.getRole())) {
                LOGGER.info("validateUserRole found match between role associations: " + roleAssociation.getRole());
                acceptableRole = isAcceptableRole(roleAssociation, userRole);
                if(acceptableRole) break;
            }
        }
        if(!acceptableRole) {
            LOGGER.error("validateUserRole was unable to match role: " + produceJsonValueForObject(roleAssociation));
            throw new LocalizedException("Unacceptable role " + roleAssociation.getRole() + " entered for user");
        }
    }

    private boolean isAcceptableRole(User.RoleAssociation roleAssociation, UserRole userRole) {
        LOGGER.info("Entering isAcceptableRole method with roleAssociation: "
                + produceJsonValueForObject(roleAssociation) + " and userRole: "
                + produceJsonValueForObject(userRole));
        for (SbacPermissionEntity entity : userRole.getAllowableEntities()) {
            LOGGER.info("isAcceptableRole checking provided User.RoleAssociation's level property against UserRole's allowable entities. Current entity: "
                    + produceJsonValueForObject(entity));
            if(entity.getEntity().equals(roleAssociation.getLevel().toString())) {
                LOGGER.info("isAcceptableRole found a matching permissions entity: " + entity.getEntity());
                return validateRole(roleAssociation);
            }
        }
        return false;
    }

    private boolean validateRole(User.RoleAssociation roleAssociation) {
        LOGGER.info("Entering validateRole method with roleAssociation: "
                + produceJsonValueForObject(roleAssociation));
        // This map was added to overcome an issue we were seeing with paging. Paging default size is set to 10. We want all results.
        Map<String,String[]> map = new HashMap<>();
        map.put("pageSize", new String[] { "10000" });
        List<Sb11Entity> entities = entityLocatorService.findEntities(map,
                HierarchyLevelToFormatTypeConverter.convertFrom(roleAssociation.getLevel()));
        if(roleAssociation.getLevel() == HierarchyLevel.STATE) {
            entities = (List<Sb11Entity>) (List<?>) stateService.mergeWithNonAccessStatesInTenancy(((List<StateEntity>) (List<?>) entities));
        }
        LOGGER.info("validateRole has entities: " + produceJsonValueForObject(entities));
        roleAssociation = decorateWithStateAbbreviationAndMongoId(entities, roleAssociation);

        LOGGER.info("validateRole has decorated role association: " + produceJsonValueForObject(roleAssociation));
        return (roleAssociation.getStateAbbreviation() != null && roleAssociation.getAssociatedEntityMongoId() != null);
    }

    private User.RoleAssociation decorateWithStateAbbreviationAndMongoId(List<Sb11Entity> entities, User.RoleAssociation roleAssociation) {
        LOGGER.info("Entering decorateWithStateAbbreviationAndMongoId method with roleAssociation: "
                + produceJsonValueForObject(roleAssociation));
        for (Sb11Entity entity: entities) {
            LOGGER.info("decorateWithStateAbbreviationAndMongoId method checking entity: "
                    + produceJsonValueForObject(entity));
            if(entity.getEntityId().equals(roleAssociation.getAssociatedEntityId())) {
                LOGGER.info("decorateWithStateAbbreviationAndMongoId method found an entity match: "
                        + entity.getEntityId());
                roleAssociation.setStateAbbreviation(entity.getStateAbbreviation());
                roleAssociation.setAssociatedEntityMongoId(entity.getId());
                break;
            }
        }
        LOGGER.info("Exiting decorateWithStateAbbreviationAndMongoId method with roleAssociation: "
                + produceJsonValueForObject(roleAssociation));
        return roleAssociation;
    }

    @Override
    public boolean deleteUser(String email) {
        User user = userService.findByEmail(email);
        if(user == null) {
            return false;
        }
        Set<String> accessibleIds = userDetailsService.getMongoIdsOfEntitiesCurrentUserHasAccessTo();
        userService.deleteDomainObject(user.getId(), User.FORMAT_TYPE, accessibleIds);
        return true;
    }

    @Override
    public boolean resetPassword(User user) {
        SbacUser sbacUser = userDetailsService.getCurrentUser();
        if(sbacUser == null) return false;
        userChangeEventService.saveUserChangeEvent(new UserChangeEvent(user.getId(), SSOAction.RESET, sbacUser.getFullName(), sbacUser.getEmail()));
        return true;
    }
}
