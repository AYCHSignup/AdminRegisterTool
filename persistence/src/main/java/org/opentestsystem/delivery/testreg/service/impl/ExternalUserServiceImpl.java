/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2016 Regents of the University of California
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 *
 * SmarterApp Open Source Assessment Software Project: http://smarterapp.org
 * Developed by Fairway Technologies, Inc. (http://fairwaytech.com)
 * for the Smarter Balanced Assessment Consortium (http://smarterbalanced.org)
 ******************************************************************************/

package org.opentestsystem.delivery.testreg.service.impl;

import org.opentestsystem.delivery.testreg.domain.*;
import org.opentestsystem.delivery.testreg.service.*;
import org.opentestsystem.shared.security.domain.SbacUser;
import org.opentestsystem.shared.security.domain.permission.SbacPermissionEntity;
import org.opentestsystem.shared.security.domain.permission.UserRole;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;

import javax.validation.ValidationException;
import java.util.HashMap;
import java.util.List;
import java.util.Set;

@Service
public class ExternalUserServiceImpl implements ExternalUserService {

    @Autowired
    public ExternalUserServiceImpl(UserService userService, @Qualifier("userDetailService") TestRegUserDetailsService testRegUserDetailsService
            , TestRegPersister testRegPersister, UserChangeEventService userChangeEventService, StateService stateSevice
            , Sb11EntityLocatorService entityLocatorService) {
        this.userService = userService;
        this.userDetailsService = testRegUserDetailsService;
        this.persistenceService = testRegPersister;
        this.userChangeEventService = userChangeEventService;
        this.stateService = stateSevice;
        this.entityLocatorService = entityLocatorService;
    }

    private UserService userService;

    private TestRegUserDetailsService userDetailsService;

    private TestRegPersister persistenceService;

    private UserChangeEventService userChangeEventService;

    private StateService stateService;

    private Sb11EntityLocatorService entityLocatorService;

    @Override
    public UserUpsert upsertUser(User user) {
        UserUpsert upsert = new UserUpsert();
        User existingUser = userService.findByEmail(user.getEmail());
        if(existingUser != null) {
            upsert.setInsert(false);
            user = decorateUser(user, existingUser);
        }
        user = validateUserRoles(user);
        upsert.setUser(persistenceService.saveDomainObject(user));
        return upsert;
    }

    private User decorateUser(User newUser, User existingUser) {
        newUser.setId(existingUser.getId());
        newUser.setHasRolesOutside(existingUser.getHasRolesOutside());
        return newUser;
    }

    private User validateUserRoles(User user) {
        List<UserRole> accessibleUserRoles = userDetailsService.getAllUserRolesForCurrentUser();
        for (User.RoleAssociation roleAssociation : user.getRoleAssociations()) {
            validateUserRole(accessibleUserRoles, roleAssociation);
        }
        return user;
    }

    private void validateUserRole(List<UserRole> accessibleUserRoles, User.RoleAssociation roleAssociation) {
        boolean acceptableRole = false;
        for(UserRole userRole : accessibleUserRoles) {
            if(userRole.getRole().equals(roleAssociation.getRole())) {
                acceptableRole = isAcceptableRole(roleAssociation, acceptableRole, userRole);
                if(acceptableRole) break;
            }
        }
        if(!acceptableRole) {
            throw new ValidationException("Unacceptable role entered for user");
        }
    }

    private boolean isAcceptableRole(User.RoleAssociation roleAssociation, boolean acceptableRole, UserRole userRole) {
        for (SbacPermissionEntity entity : userRole.getAllowableEntities()) {
            if(entity.getEntity().toString().equals(roleAssociation.getLevel().toString())) {
                acceptableRole = false;
                switch(roleAssociation.getLevel()) {
                    case STATE:
                        List<Sb11Entity> stateEntities = entityLocatorService.findEntities(new HashMap<String, String[]>(), FormatType.STATE);
                        List<Sb11Entity> mergedStateEntites =  (List<Sb11Entity>)(List<?>) stateService.mergeWithNonAccessStatesInTenancy(((List<StateEntity>)(List<?>)stateEntities));
                        String stateAbbreviation = getStateAbbreviationFromMatchingId(mergedStateEntites, roleAssociation.getAssociatedEntityId());
                        if(stateAbbreviation != null) {
                            acceptableRole = true;
                            roleAssociation.setStateAbbreviation(stateAbbreviation);
                            break;
                        }
                        break;
                    case DISTRICT:
                        List<Sb11Entity> districtEntities = entityLocatorService.findEntities(new HashMap<String, String[]>(), FormatType.DISTRICT);
                        String districtStateAbbreviation = getStateAbbreviationFromMatchingId(districtEntities, roleAssociation.getAssociatedEntityId());
                        if(districtStateAbbreviation != null) {
                            acceptableRole = true;
                            roleAssociation.setStateAbbreviation(districtStateAbbreviation);
                            break;
                        }
                        break;
                    case INSTITUTION:
                        List<Sb11Entity> institutionEntities = entityLocatorService.findEntities(new HashMap<String, String[]>(), FormatType.INSTITUTION);
                        String institutionStateAbbreviation = getStateAbbreviationFromMatchingId(institutionEntities, roleAssociation.getAssociatedEntityId());
                        if(institutionStateAbbreviation != null) {
                            acceptableRole = true;
                            roleAssociation.setStateAbbreviation(institutionStateAbbreviation);
                            break;
                        }
                        break;
                    default:
                        break;
                }
                break;
            }
        }
        return acceptableRole;
    }

    private String getStateAbbreviationFromMatchingId(List<Sb11Entity> entities, String entityId) {
        for (Sb11Entity entity: entities) {
            if(entity.getEntityId().equals(entityId)) {
                return entity.getStateAbbreviation();
            }
        }
        return null;
    }

    @Override
    public boolean deleteUser(String email) {
        User user = userService.findByEmail(email);
        if(user == null) {
            return false;
        }
        Set<String> accessibleIds = userDetailsService.getMongoIdsOfEntitiesCurrentUserHasAccessTo();
        userService.deleteDomainObject(user.getId(), User.FORMAT_TYPE, accessibleIds);
        return true;
    }

    @Override
    public boolean resetPassword(User user) {
        SbacUser sbacUser = userDetailsService.getCurrentUser();
        if(sbacUser == null) return false;
        userChangeEventService.saveUserChangeEvent(new UserChangeEvent(user.getId(), SSOAction.RESET, sbacUser.getFullName(), sbacUser.getEmail()));
        return true;
    }
}
