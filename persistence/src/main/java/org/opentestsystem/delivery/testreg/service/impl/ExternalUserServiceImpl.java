/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2016 Regents of the University of California
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 *
 * SmarterApp Open Source Assessment Software Project: http://smarterapp.org
 * Developed by Fairway Technologies, Inc. (http://fairwaytech.com)
 * for the Smarter Balanced Assessment Consortium (http://smarterbalanced.org)
 ******************************************************************************/

package org.opentestsystem.delivery.testreg.service.impl;

import org.codehaus.jackson.map.ObjectMapper;
import org.codehaus.jackson.map.ObjectWriter;
import org.opentestsystem.delivery.testreg.domain.ClientEntity;
import org.opentestsystem.delivery.testreg.domain.HierarchyLevel;
import org.opentestsystem.delivery.testreg.domain.SSOAction;
import org.opentestsystem.delivery.testreg.domain.Sb11Entity;
import org.opentestsystem.delivery.testreg.domain.StateEntity;
import org.opentestsystem.delivery.testreg.domain.User;
import org.opentestsystem.delivery.testreg.domain.UserChangeEvent;
import org.opentestsystem.delivery.testreg.domain.UserUpsert;
import org.opentestsystem.delivery.testreg.persistence.HierarchyLevelToFormatTypeConverter;
import org.opentestsystem.delivery.testreg.service.ExternalUserService;
import org.opentestsystem.delivery.testreg.service.Sb11EntityLocatorService;
import org.opentestsystem.delivery.testreg.service.StateService;
import org.opentestsystem.delivery.testreg.service.TestRegPersister;
import org.opentestsystem.delivery.testreg.service.TestRegUserDetailsService;
import org.opentestsystem.delivery.testreg.service.UserChangeEventService;
import org.opentestsystem.delivery.testreg.service.UserService;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.security.domain.SbacUser;
import org.opentestsystem.shared.security.domain.permission.SbacPermissionEntity;
import org.opentestsystem.shared.security.domain.permission.UserRole;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

@Service
public class ExternalUserServiceImpl implements ExternalUserService {

    private static final Logger LOGGER = LoggerFactory.getLogger(ExternalUserServiceImpl.class);

    private ObjectWriter objectWriter = new ObjectMapper().writer().withDefaultPrettyPrinter();

    @Autowired
    public ExternalUserServiceImpl(UserService userService, @Qualifier("userDetailService") TestRegUserDetailsService testRegUserDetailsService
            , TestRegPersister testRegPersister, UserChangeEventService userChangeEventService, StateService stateSevice
            , Sb11EntityLocatorService entityLocatorService) {
        this.userService = userService;
        this.userDetailsService = testRegUserDetailsService;
        this.persistenceService = testRegPersister;
        this.userChangeEventService = userChangeEventService;
        this.stateService = stateSevice;
        this.entityLocatorService = entityLocatorService;
    }

    private UserService userService;

    private TestRegUserDetailsService userDetailsService;

    private TestRegPersister persistenceService;

    private UserChangeEventService userChangeEventService;

    private StateService stateService;

    private Sb11EntityLocatorService entityLocatorService;

    private String produceJsonValueForObject(Object object) {
        try {
            return objectWriter.writeValueAsString(object);
        } catch(IOException e) {
            return "An IOException occurred";
        }
    }

    @Override
    public UserUpsert upsertUser(User user) {
        UserUpsert upsert = new UserUpsert();
        User existingUser = userService.findByEmail(user.getEmail());
        if(existingUser != null) {
            upsert.setInsert(false);
            user = decorateUser(user, existingUser);
        }
        user = validateUserRoles(user);
        upsert.setUser(persistenceService.saveDomainObject(user));
        return upsert;
    }

    private User decorateUser(User newUser, User existingUser) {
        newUser.setId(existingUser.getId());
        newUser.setHasRolesOutside(existingUser.getHasRolesOutside());
        return newUser;
    }

    private User validateUserRoles(User user) {
        List<UserRole> accessibleUserRoles = userDetailsService.getAllUserRolesForCurrentUser();
        for (User.RoleAssociation roleAssociation : user.getRoleAssociations()) {
            validateUserRole(accessibleUserRoles, roleAssociation);
        }
        return user;
    }

    private void validateUserRole(List<UserRole> accessibleUserRoles, User.RoleAssociation roleAssociation) {
        boolean acceptableRole = false;
        for(UserRole userRole : accessibleUserRoles) {
            if(userRole.getRole().equals(roleAssociation.getRole())) {
                acceptableRole = isAcceptableRole(roleAssociation, userRole);
                if(acceptableRole) break;
            }
        }
        if(!acceptableRole) {
            LOGGER.error("validateUserRole was unable to match role: " + produceJsonValueForObject(roleAssociation));
            throw new LocalizedException("Unacceptable role " + roleAssociation.getRole() + " entered for user");
        }
    }

    private boolean isAcceptableRole(User.RoleAssociation roleAssociation, UserRole userRole) {
        for (SbacPermissionEntity entity : userRole.getAllowableEntities()) {
            if(entity.getEntity().equals(roleAssociation.getLevel().toString())) {
                return validateRole(roleAssociation);
            }
        }
        return false;
    }

    private boolean validateRole(User.RoleAssociation roleAssociation) {
        // This map was added to overcome an issue with paging. Paging default size is set to 10. We want all results.
        Map<String,String[]> map = new HashMap<>();
        map.put("pageSize", new String[] { "10000" });

        List<Sb11Entity> entities =
        (roleAssociation.getLevel().equals(HierarchyLevel.CLIENT)) ?
                getClientEntities() :
                entityLocatorService.findEntities(map,
                HierarchyLevelToFormatTypeConverter.convertFrom(roleAssociation.getLevel()));
        if(roleAssociation.getLevel() == HierarchyLevel.STATE) {
            entities = (List<Sb11Entity>) (List<?>) stateService.mergeWithNonAccessStatesInTenancy(((List<StateEntity>) (List<?>) entities));
        }
        roleAssociation = decorateWithStateAbbreviationAndMongoId(entities, roleAssociation);

        return roleAssociation.getAssociatedEntityMongoId() != null;
    }

    private List<Sb11Entity> getClientEntities() {
        List<ClientEntity> clientEntities =  persistenceService.findAll(ClientEntity.FORMAT_TYPE);
        List<Sb11Entity> entities = new ArrayList<>();
        for(int i = 0; i < clientEntities.size(); i++) {
            entities.add(clientEntities.get(i));
        }
        return entities;
    }

    private User.RoleAssociation decorateWithStateAbbreviationAndMongoId(List<Sb11Entity> entities, User.RoleAssociation roleAssociation) {
        for (Sb11Entity entity: entities) {
            if(entity.getEntityId().equals(roleAssociation.getAssociatedEntityId()) &&
                    (entity.getStateAbbreviation() == null ||
                            roleAssociation.getStateAbbreviation() == null ||
                            entity.getStateAbbreviation().equals(roleAssociation.getStateAbbreviation()))) {
                roleAssociation.setAssociatedEntityMongoId(entity.getId());
                break;
            }
        }
        return roleAssociation;
    }

    @Override
    public boolean deleteUser(String email) {
        User user = userService.findByEmail(email);
        if(user == null) {
            return false;
        }
        Set<String> accessibleIds = userDetailsService.getMongoIdsOfEntitiesCurrentUserHasAccessTo();
        userService.deleteDomainObject(user.getId(), User.FORMAT_TYPE, accessibleIds);
        return true;
    }

    @Override
    public boolean resetPassword(User user) {
        SbacUser sbacUser = userDetailsService.getCurrentUser();
        if(sbacUser == null) return false;
        userChangeEventService.saveUserChangeEvent(new UserChangeEvent(user.getId(), SSOAction.RESET, sbacUser.getFullName(), sbacUser.getEmail()));
        return true;
    }
}
