/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.delivery.testreg.service.impl;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.delivery.testreg.domain.FormatType;
import org.opentestsystem.delivery.testreg.domain.HierarchyLevel;
import org.opentestsystem.delivery.testreg.domain.Sb11Entity;
import org.opentestsystem.delivery.testreg.domain.Sb11SuperEntity;
import org.opentestsystem.delivery.testreg.service.Sb11EntityRepositoryService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@Component
@Scope("prototype")
public class TestRegUberEntityBottomUpPathwayBuilder implements Runnable {

    private static final Logger LOGGER = LoggerFactory.getLogger(TestRegUberEntityBottomUpPathwayBuilder.class);

    private Sb11Entity entity;
    private boolean includeEntityTypeWithId;
    private TestRegPersisterImpl testRegPersister;
    private Sb11EntityRepositoryService sb11EntityService;

    private List<String> pathway;
    private Map<String, String> errorMessageMap = new HashMap<>();
    private Map<String, Sb11Entity> deleteTheseEntities = new HashMap<>();
    private Map<String, Sb11Entity> resetParentOnTheseEntities = new HashMap<>();

    public TestRegUberEntityBottomUpPathwayBuilder(Sb11Entity entity, boolean includeEntityTypeWithId, TestRegPersisterImpl testRegPersister, Sb11EntityRepositoryService sb11EntityService) {
        this.entity = entity;
        this.includeEntityTypeWithId = includeEntityTypeWithId;
        this.testRegPersister = testRegPersister;
        this.sb11EntityService = sb11EntityService;
        this.pathway = new ArrayList<>();
    }

    // after this thread is run the result is held in this variable
    public List<String> getPathway() {
        return pathway;
    }

    // after this thread is run the errors are held in this variable
    public Map<String, String> getErrorMessageMap() {
        return errorMessageMap;
    }

    // access after this thread is run
    public Map<String, Sb11Entity> getResetParentOnTheseEntities() {
        return resetParentOnTheseEntities;
    }

    // access after this thread is run
    public Map<String, Sb11Entity> getDeleteTheseEntities() {
        return deleteTheseEntities;
    }

    @Override
    public void run() {
        long start = System.currentTimeMillis();
        LOGGER.trace("starting testRegUberEntityBottomUpPathwayBuilder (thread)");
        buildPathwayFromBottomUp(entity, pathway, includeEntityTypeWithId);
        long stop = System.currentTimeMillis();
        LOGGER.trace("stopping testRegUberEntityBottomUpPathwayBuilder (thread): took " + (stop - start) + "ms");
    }

    // recursive implementation to follow one Sb11Entity up the hierarchy tree building on the "pathway" List param in each recursion
    @SuppressWarnings("unchecked")
    private List<String> buildPathwayFromBottomUp(Sb11Entity entity, List<String> pathway, final boolean includeEntityTypeWithId) {
        pathway.add(includeEntityTypeWithId ? "(" + entity.getFormatType().name() + ") " + entity.getId() : entity.getId());

        // we've reached the end of our traversal
        if (entity.getFormatType().equals(FormatType.CLIENT)) {
            return pathway;
        }

        List<String> errorMessages = new ArrayList<>();
        Sb11Entity parentEntityViaParentId = null;
        Sb11Entity parentEntityViaParentEntityId = null;

        if (StringUtils.isBlank(entity.getEntityId())) {
            deleteTheseEntities.put(entity.getId(), entity);
            errorMessages.add("this entity returned null for getEntityId()");
        }

        if (entity.getEntityType() == null) {
            deleteTheseEntities.put(entity.getId(), entity);
            errorMessages.add("this entity returned null for getEntityType()");
        }

        if (StringUtils.isBlank(entity.getEntityName())) {
            deleteTheseEntities.put(entity.getId(), entity);
            errorMessages.add("this entity returned null for getEntityName()");
        }

        if (StringUtils.isBlank(entity.getParentId())) {
            resetParentOnTheseEntities.put(entity.getId(), entity);
            errorMessages.add("this entity (that isn't a CLIENT) that returned null for getParentId()");
        }

        if (entity.getParentEntityType() == null) {
            resetParentOnTheseEntities.put(entity.getId(), entity);
            errorMessages.add("this entity (that isn't a CLIENT) that returned null for getParentEntityType()");
        }

        if (StringUtils.isBlank(entity.getParentEntityId())) {
            resetParentOnTheseEntities.put(entity.getId(), entity);
            errorMessages.add("this entity (that isn't a CLIENT) that returned null for getParentEntityId()");
        }

        // get a handle to the parent entity using the parent entity id (and possibly state abbreviation)
        if (StringUtils.isNotBlank(entity.getParentId()) && entity.getParentEntityType() != null && StringUtils.isNotBlank(entity.getParentEntityId())) {
            if (Sb11SuperEntity.class.isAssignableFrom(entity.getParentEntityType().getEntityClass())) {
                parentEntityViaParentEntityId = sb11EntityService.findByEntityId(entity.getParentEntityId(), (Class<Sb11SuperEntity>) entity.getParentEntityType().getEntityClass());
                if (parentEntityViaParentEntityId == null) {
                    resetParentOnTheseEntities.put(entity.getId(), entity);
                    errorMessages.add("this entity (that isn't a CLIENT) has an invalid parent ref (" + entity.getParentEntityType() + ", EntityId: " + entity.getParentEntityId() + ")");
                }
            } else {
                if (StringUtils.isBlank(entity.getStateAbbreviation())) {
                    resetParentOnTheseEntities.put(entity.getId(), entity);
                    errorMessages.add("this entity (that isn't a Sb11SuperEntity) has an invalid (null) state abbreviation");
                } else {
                    parentEntityViaParentEntityId = sb11EntityService.findByEntityIdAndStateAbbreviation(entity.getParentEntityId(), entity.getStateAbbreviation(), entity.getParentEntityType().getEntityClass());
                    if (parentEntityViaParentEntityId == null) {
                        resetParentOnTheseEntities.put(entity.getId(), entity);
                        errorMessages.add("this entity (that isn't a CLIENT) has an invalid parent ref (" + entity.getParentEntityType() + ", EntityId: " + entity.getParentEntityId() + ", State: " + entity.getStateAbbreviation() + ")");
                    }
                }
            }
        }

        // get a handle to the parent entity using just the parent id (i.e. mongo id of parent)
        if (StringUtils.isNotBlank(entity.getParentId()) && entity.getParentEntityType() != null) {
            parentEntityViaParentId = testRegPersister.findById(entity.getParentId(), convertHierarchyLevelToFormatType(entity.getParentEntityType()));
            if (parentEntityViaParentId == null) {
                resetParentOnTheseEntities.put(entity.getId(), entity);
                errorMessages.add("this entity (that isn't a CLIENT) has an invalid parent ref (" + entity.getParentEntityType() + ", MongoId: " + entity.getParentId() + ")");
            }
        }

        if (parentEntityViaParentEntityId != null && parentEntityViaParentId != null) {
            if (!parentEntityViaParentEntityId.getId().equals(parentEntityViaParentId.getId())) {
                resetParentOnTheseEntities.put(entity.getId(), entity);
                errorMessages.add("this entity has contradictory parent info when looked up (via parentEntityId: " + parentEntityViaParentEntityId.getId() + ", via parentId: " + parentEntityViaParentId.getId() + ")");
            }
        }

        if (errorMessages.size() > 0) {
            String entityInfo = entity.getFormatType() + ", MongoId: " + entity.getId() + ", EntityId: " + entity.getEntityId();
            if (!(entity instanceof Sb11SuperEntity)) {
                entityInfo += ", State: " + entity.getStateAbbreviation();
            }
            String combinedErrorMessage = "entity error (invalid/corrupt): " + entityInfo;
            for (String errorMessage : errorMessages) {
                combinedErrorMessage += "\n   entity error --> " + errorMessage;
            }
            errorMessageMap.put(entity.getId(), combinedErrorMessage);
        }

        // continue our traversal (assuming we have a handle on the parent entity)
        if (errorMessageMap.size() == 0 && parentEntityViaParentId != null && parentEntityViaParentEntityId != null) {
            return buildPathwayFromBottomUp(parentEntityViaParentId, pathway, includeEntityTypeWithId);
        } else {
            // remove this (erroneous) entity from the pathway
            if (errorMessageMap.size() > 0) {
                pathway.remove(pathway.size() - 1);
            }
            return pathway;
        }
    }

    // quick lookup from HierarchyLevel to FormatType since getParentEntityType() returns a HierarchyLevel,
    // and TestRegPersister requires a FormatType as param.
    private static final FormatType convertHierarchyLevelToFormatType(final HierarchyLevel hierarchyLevel) {
        switch (hierarchyLevel) {
        case CLIENT:
            return FormatType.CLIENT;
        case DISTRICT:
            return FormatType.DISTRICT;
        case GROUPOFDISTRICTS:
            return FormatType.GROUPOFDISTRICTS;
        case INSTITUTION:
            return FormatType.INSTITUTION;
        case GROUPOFINSTITUTIONS:
            return FormatType.GROUPOFINSTITUTIONS;
        case STATE:
            return FormatType.STATE;
        case GROUPOFSTATES:
            return FormatType.GROUPOFSTATES;
        }
        throw new IllegalArgumentException("Unknown HierarchyLevel: " + hierarchyLevel.toString());
    }
}