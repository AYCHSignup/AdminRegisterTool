/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.delivery.testadmin.scheduling;

import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.notNullValue;
import static org.hamcrest.Matchers.hasSize;
import static org.junit.Assert.assertThat;
import static org.springframework.data.mongodb.core.query.Criteria.where;
import static org.springframework.data.mongodb.core.query.Query.query;

import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import org.joda.time.DateTime;
import org.joda.time.DateTimeUtils;
import org.junit.Before;
import org.junit.Test;
import org.opentestsystem.delivery.testadmin.domain.Affinity;
import org.opentestsystem.delivery.testadmin.domain.Affinity.AffinityRule;
import org.opentestsystem.delivery.testadmin.domain.Affinity.AffinityType;
import org.opentestsystem.delivery.testadmin.domain.schedule.Schedule;
import org.opentestsystem.delivery.testadmin.domain.schedule.ScheduledSeat;
import org.opentestsystem.delivery.testadmin.domain.schedule.ScheduledTimeSlot;
import org.opentestsystem.delivery.testreg.domain.Accommodation;
import org.opentestsystem.delivery.testreg.domain.AccommodationEnums.Translation;
import org.opentestsystem.delivery.testreg.domain.EligibleStudent;
import org.opentestsystem.delivery.testreg.domain.Student;
import org.opentestsystem.delivery.testreg.domain.Student.GradeLevel;
import org.opentestsystem.delivery.testreg.integration.AbstractPersistenceEmbeddedTest;
import org.springframework.beans.factory.annotation.Autowired;

import com.google.common.collect.Lists;

public class ScheduleWithAccommodationsAndSinglePriorityTest extends AbstractPersistenceEmbeddedTest {

    @Autowired
    private Scheduler scheduler;

    private String studentEntityId;

    @Before
    public void setup() {
        DateTimeUtils.setCurrentMillisFixed(new DateTime(2014, 8, 25, 0, 0).getMillis());
        DbDumpImporter.loadDefaultBsonDumps(mongoTemplate);

        List<Student> studentsGradeOne = mongoTemplate.find(query(where("gradeLevelWhenAssessed").is("01")),
                Student.class);

        Student oneStudent = studentsGradeOne.get(0);

        // add an accommodation that will match one of the accessibility equipments in the db
        Accommodation accom = new Accommodation();
        accom.setTranslation(Translation.TDS_WL_Glossary);
        accom.setSubject("A10");
        accom.setStudentId(oneStudent.getId());
        accom.setStateAbbreviation(oneStudent.getStateAbbreviation());

        oneStudent.setAccommodations(Lists.newArrayList(accom));

        mongoTemplate.save(oneStudent);

        EligibleStudent eligStudent = mongoTemplate.findOne(query(where("student.entityId")
                .is(oneStudent.getEntityId())), EligibleStudent.class);

        eligStudent.getStudent().setAccommodations(Lists.newArrayList(accom));

        mongoTemplate.save(eligStudent);

        studentEntityId = oneStudent.getEntityId();

    }

    @Test
    public void testAccommodationWithGradePriority() {
        Schedule schedule = new Schedule();
        schedule.setScheduleName("test-schedule");
        schedule.setStartDate(new DateTime(2014, 9, 1, 0, 0));
        schedule.setEndDate(new DateTime(2014, 9, 5, 0, 0));
        schedule.setInstitutionIdentifier("550852000932");
        schedule.setInstitutionId("53f027ec8f44c7080a67e070");

        schedule.setAffinities(Lists.newArrayList(new Affinity(AffinityRule.STRICT, "01", AffinityType.GRADE)));

        Schedule createdSchedule = scheduler.createSchedule(schedule);

        assertThat(createdSchedule.getScheduledDays(), hasSize(5));

        // with a strict priority on first grade and there is only 1 assessment that 1st grade is eligible for,
        // all first graders should be scheduled into the first 2 time slots and there should be 2 empty
        // seats in the 2nd slot
        // there is one seat in each slot that has the Write:Outloud accessibility equipment. One of the seats in one of
        // the
        // slots should be allocated to the student identified by studentEntityId

        TreeSet<ScheduledTimeSlot> slots = createdSchedule.getScheduledDays().get(0).getFacilities().get(0)
                .getTimeSlots();
        Iterator<ScheduledTimeSlot> slotItr = slots.iterator();

        Set<String> students = new HashSet<String>();
        int numGradeOneStudents = 0;
        int emptySeats = 0;
        boolean targetStudentFound = false;

        if (slotItr.hasNext()) { // first time slot
            ScheduledTimeSlot slot = slotItr.next();

            assertThat(slot.isStrictAffinityScheduled(), is(true));
            assertThat(slot.getAffinitiesScheduled(), hasSize(1));

            Iterator<ScheduledSeat> seatItr = slot.getSeats().iterator();

            while (seatItr.hasNext()) {
                ScheduledSeat seat = seatItr.next();

                if (seat.isSeatScheduled()) {
                    if (seat.getStudent().getGradeLevelWhenAssessed() == GradeLevel.FIRSTGRADE) {
                        numGradeOneStudents++;
                        students.add(seat.getStudent().getEntityId());

                        if (studentEntityId.equals(seat.getStudent().getEntityId())) {
                            assertThat(seat.getAccessibilityEquipmentObjs(), notNullValue());
                            assertThat(seat.getAccessibilityEquipmentObjs().get(0).getName(), is("Write:Outloud"));
                            targetStudentFound = true;
                        }
                    }
                } else {
                    emptySeats++;
                }

            }

        }

        if (slotItr.hasNext()) { // second time slot
            ScheduledTimeSlot slot = slotItr.next();

            assertThat(slot.isStrictAffinityScheduled(), is(true));
            assertThat(slot.getAffinitiesScheduled(), hasSize(1));

            Iterator<ScheduledSeat> seatItr = slot.getSeats().iterator();

            while (seatItr.hasNext()) {
                ScheduledSeat seat = seatItr.next();

                if (seat.isSeatScheduled()) {
                    if (seat.getStudent().getGradeLevelWhenAssessed() == GradeLevel.FIRSTGRADE) {
                        numGradeOneStudents++;
                        students.add(seat.getStudent().getEntityId());

                        if (studentEntityId.equals(seat.getStudent().getEntityId())) {
                            assertThat(seat.getAccessibilityEquipmentObjs(), notNullValue());
                            if (seat.getAccessibilityEquipmentObjs().size() > 0) {
                                assertThat(seat.getAccessibilityEquipmentObjs().get(0).getName(), is("Write:Outloud"));
                                targetStudentFound = true;
                            }
                        }
                    }
                } else {
                    emptySeats++;
                }

            }

        }

        assertThat(numGradeOneStudents, is(48));
        assertThat(students, hasSize(48));
        assertThat(emptySeats, is(2));
        assertThat(targetStudentFound, is(true));

    }

}
