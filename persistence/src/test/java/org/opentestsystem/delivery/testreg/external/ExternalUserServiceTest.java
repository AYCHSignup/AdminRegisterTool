/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2016 Regents of the University of California
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 *
 * SmarterApp Open Source Assessment Software Project: http://smarterapp.org
 * Developed by Fairway Technologies, Inc. (http://fairwaytech.com)
 * for the Smarter Balanced Assessment Consortium (http://smarterbalanced.org)
 ******************************************************************************/

package org.opentestsystem.delivery.testreg.external;

import org.junit.After;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.mockito.AdditionalAnswers;
import org.mockito.Mockito;
import org.opentestsystem.delivery.testreg.domain.*;
import org.opentestsystem.delivery.testreg.service.*;
import org.opentestsystem.delivery.testreg.service.impl.ExternalUserServiceImpl;
import org.opentestsystem.shared.exception.LocalizedException;
import org.opentestsystem.shared.security.domain.permission.SbacPermissionEntity;
import org.opentestsystem.shared.security.domain.permission.UserRole;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.UUID;

import static org.mockito.AdditionalAnswers.returnsFirstArg;
import static org.mockito.Matchers.*;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

public class ExternalUserServiceTest {

    private UserService userService;
    private TestRegUserDetailsService testRegUserDetailsService;
    private TestRegPersister testRegPersister;
    private ExternalUserService externalUserService;
    private UserChangeEventService userChangeEventService;
    private StateService stateService;
    private Sb11EntityLocatorService entityLocatorService;

    @Before
    public void setup() {
        userService = mock(UserService.class);
        testRegUserDetailsService = mock(TestRegUserDetailsService.class);
        testRegPersister = mock(TestRegPersister.class);
        userChangeEventService = mock(UserChangeEventService.class);
        stateService = mock(StateService.class);
        entityLocatorService = mock(Sb11EntityLocatorService.class);
        externalUserService = new ExternalUserServiceImpl(userService, testRegUserDetailsService, testRegPersister
                , userChangeEventService, stateService, entityLocatorService);
    }

    @After
    public void tearDown() {

    }

    private User buildUser() {
        User user = new User();
        user.setEmail("foo.bar@example.com");
        user.setFirstName("foo");
        user.setLastName("bar");
        user.setPhone("111-222-3333");
        ArrayList<User.RoleAssociation> userRoles = new ArrayList<>();
        User.RoleAssociation roleAssociation = new User.RoleAssociation();
        roleAssociation.setAssociatedEntityId("CA");
        roleAssociation.setRole("Administrator");
        roleAssociation.setLevel("STATE");
        userRoles.add(roleAssociation);
        user.setRoleAssociations(userRoles);
        return user;
    }

    @Test
    public void insertTestSuccessful() {
        //Arrange
        User user = buildUser();

        List<UserRole> userRoles = new ArrayList<>();
        UserRole userRole = new UserRole();
        userRole.setRole("Administrator");

        List<Sb11Entity> locatedEntities = new ArrayList<>();
        Sb11Entity entity = new StateEntity("CA", "STATE");
        entity.setId(UUID.randomUUID().toString());
        locatedEntities.add(entity);

        List<SbacPermissionEntity> allowableEntities = new ArrayList<>();
        SbacPermissionEntity sbacPermission = new SbacPermissionEntity();
        sbacPermission.setEntity("STATE");
        allowableEntities.add(sbacPermission);

        userRole.setAllowableEntities(allowableEntities);
        userRoles.add(userRole);

        when(userService.findByEmail(anyString())).thenReturn(null);
        when(testRegPersister.saveDomainObject(any(User.class))).thenReturn(user);
        when(testRegUserDetailsService.getAllUserRolesForCurrentUser()).thenReturn(userRoles);
        when(entityLocatorService.findEntities(anyMap(), any(FormatType.class))).thenReturn(locatedEntities);
        when(stateService.mergeWithNonAccessStatesInTenancy(anyList())).then(AdditionalAnswers.returnsFirstArg());

        //Act
        UserUpsert userUpsert = externalUserService.upsertUser(user);

        //Assert
        Assert.assertNotNull(userUpsert);
        Assert.assertTrue(userUpsert.isInsert());
        Assert.assertNotNull(userUpsert.getUser());
        Assert.assertEquals(userUpsert.getUser().getEmail(), "foo.bar@example.com");
    }

    @Test(expected = LocalizedException.class)
    public void insertWithInvalidRoleAssignmentCausesValidationError() {
        //Arrange
        User user = buildUser();

        List<UserRole> userRoles = new ArrayList<>();
        UserRole userRole = new UserRole();
        userRole.setRole("Test Administrator");

        List<Sb11Entity> locatedEntities = new ArrayList<>();
        Sb11Entity entity = new StateEntity("UT", "STATE");
        entity.setId(UUID.randomUUID().toString());
        locatedEntities.add(entity);

        List<SbacPermissionEntity> allowableEntities = new ArrayList<>();
        SbacPermissionEntity sbacPermission = new SbacPermissionEntity();
        sbacPermission.setEntity("STATE");
        allowableEntities.add(sbacPermission);

        userRole.setAllowableEntities(allowableEntities);
        userRoles.add(userRole);

        when(userService.findByEmail(anyString())).thenReturn(null);
        when(testRegPersister.saveDomainObject(any(User.class))).thenReturn(user);
        when(testRegUserDetailsService.getAllUserRolesForCurrentUser()).thenReturn(userRoles);
        when(entityLocatorService.findEntities(anyMap(), any(FormatType.class))).thenReturn(locatedEntities);
        when(stateService.mergeWithNonAccessStatesInTenancy(anyList())).then(AdditionalAnswers.returnsFirstArg());

        //Act
        UserUpsert userUpsert = externalUserService.upsertUser(user);

        //Assert
        Assert.assertNotNull(userUpsert);
        Assert.assertTrue(userUpsert.isInsert());
        Assert.assertNotNull(userUpsert.getUser());
        Assert.assertEquals(userUpsert.getUser().getEmail(), "foo.bar@example.com");
    }

    @Test
    public void updateTestSuccessful() {
        //Arrange
        User user = buildUser();
        User existingUser = buildUser();
        existingUser.setId("12345");
        ArrayList<User.RoleAssociation> roleAssociations = (ArrayList<User.RoleAssociation>) user.getRoleAssociations();

        User.RoleAssociation roleAssociation = new User.RoleAssociation();
        roleAssociation.setAssociatedEntityId("DISTRICT9");
        roleAssociation.setRole("Administrator");
        roleAssociation.setLevel("DISTRICT");
        roleAssociations.add(roleAssociation);
        existingUser.setRoleAssociations(roleAssociations);

        List<UserRole> userRoles = new ArrayList<>();
        UserRole userRole = new UserRole();
        userRole.setRole("Administrator");

        List<Sb11Entity> locatedEntities = new ArrayList<>();
        Sb11Entity entity = new StateEntity("CA", "STATE");
        entity.setId(UUID.randomUUID().toString());
        locatedEntities.add(entity);
        Sb11Entity entity1 = new StateEntity("DISTRICT9", "DISTRICT");
        entity1.setId(UUID.randomUUID().toString());
        locatedEntities.add(entity1);

        List<SbacPermissionEntity> allowableEntities = new ArrayList<>();
        SbacPermissionEntity sbacPermission = new SbacPermissionEntity();
        sbacPermission.setEntity("STATE");
        allowableEntities.add(sbacPermission);
        SbacPermissionEntity sbacPermission1 = new SbacPermissionEntity();
        sbacPermission1.setEntity("DISTRICT");
        allowableEntities.add(sbacPermission1);


        userRole.setAllowableEntities(allowableEntities);
        userRoles.add(userRole);

        when(userService.findByEmail(anyString())).thenReturn(existingUser);
        when(testRegPersister.saveDomainObject(any(User.class))).then(returnsFirstArg());
        when(testRegUserDetailsService.getAllUserRolesForCurrentUser()).thenReturn(userRoles);
        when(entityLocatorService.findEntities(anyMap(), any(FormatType.class))).thenReturn(locatedEntities);
        when(stateService.mergeWithNonAccessStatesInTenancy(anyList())).then(AdditionalAnswers.returnsFirstArg());

        //Act
        UserUpsert userUpsert = externalUserService.upsertUser(user);

        //Assert
        User assertUser = userUpsert.getUser();
        List<User.RoleAssociation> assertRoleAssociations = assertUser.getRoleAssociations();

        Assert.assertNotNull(userUpsert);
        Assert.assertFalse(userUpsert.isInsert());
        Assert.assertNotNull(assertUser);
        Assert.assertEquals(assertUser.getEmail(), "foo.bar@example.com");
        Assert.assertEquals(assertUser.getId(), "12345");
        Assert.assertEquals(assertRoleAssociations.size(), 2);
        Assert.assertEquals(assertRoleAssociations.get(0).getAssociatedEntityId(), "CA");
        Assert.assertEquals(assertRoleAssociations.get(1).getAssociatedEntityId(), "DISTRICT9");
    }

    @Test
    public void deleteTestSuccessful() {
        //Arrange
        String email = "foo.bar@example.com";

        when(userService.findByEmail(anyString())).thenReturn(buildUser());
        Mockito.doNothing().when(userService).deleteDomainObject(anyString(), any(FormatType.class), anySetOf(String.class));
        when(testRegUserDetailsService.getMongoIdsOfEntitiesCurrentUserHasAccessTo()).thenReturn(new HashSet<String>());

        //Act
        boolean result = externalUserService.deleteUser(email);

        //Assert
        Assert.assertTrue(result);
    }

    @Test
    public void deleteTestUnsuccessful() {
        //Arrange
        String email = "foo.bar@example.com";

        when(userService.findByEmail(anyString())).thenReturn(null);

        //Act
        boolean result = externalUserService.deleteUser(email);

        //Assert
        Assert.assertFalse(result);
    }
}

