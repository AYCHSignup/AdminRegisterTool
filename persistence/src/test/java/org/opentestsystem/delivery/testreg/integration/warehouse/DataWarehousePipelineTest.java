/*
Educational Online Test Delivery System Copyright (c) 2013 American Institutes for Research

Distributed under the AIR Open Source License, Version 1.0 See accompanying file AIR-License-1_0.txt or at
http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 */

package org.opentestsystem.delivery.testreg.integration.warehouse;

import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertThat;
import static org.junit.Assert.fail;

import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.SignatureException;
import java.util.ArrayList;
import java.util.List;

import javax.annotation.Resource;

import org.bouncycastle.openpgp.PGPException;
import org.junit.Test;
import org.opentestsystem.delivery.testreg.integration.AbstractPersistenceEmbeddedTestDw;
import org.opentestsystem.delivery.testreg.transformer.GpgVerifier;
import org.opentestsystem.delivery.testreg.transformer.GzipUncompressor;
import org.opentestsystem.delivery.testreg.transformer.TarUnbundler;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.integration.Message;
import org.springframework.integration.MessageChannel;
import org.springframework.integration.channel.QueueChannel;
import org.springframework.integration.support.MessageBuilder;

public class DataWarehousePipelineTest extends AbstractPersistenceEmbeddedTestDw {

    @Resource
    private QueueChannel testChannelSbac;

    @Resource
    private QueueChannel testChannelLocal;

    @Autowired
    private MessageChannel tarInput;

    @Autowired
    private GpgVerifier gpgVerifier;

    @Autowired
    private GzipUncompressor gzipUncompressor;

    @Autowired
    private TarUnbundler tarUnbundler;

    private static final String PLAINTEXT = "this is some test text";
    private static final String PLAINTEXT_FILENAME = "test_text1.txt";

    private static final String PLAINTEXT_2 = "some more test text";
    private static final String PLAINTEXT_2_FILENAME = "test_text2.txt";

    private static Logger LOGGER = LoggerFactory.getLogger(DataWarehousePipelineTest.class);

    private static final String UUID = "00000000-0000-0000-0000-000000000000";
    private static final String FILE_SUFFIX = "2014-01-01-000000000000";

    // uncomment the static block and change the path in order to run this test outside of maven
    // static {
    // System.setProperty("testreg.secret.passphrase.file",
    // "<path to code>/sb11-test-registration/persistence/src/test/resources/secret_passphrase.properties");
    // }

    @Test
    public void testPipelineSbac() {

        // construct a message and put it into dataWarehouseInput
        // should go through pipeline and end up in testChannel where it can be pulled off

        // only compression and encryption is currently functional

        // verify signature and decrypt message
        // decrypted data should equal the compressed data
        // uncompress the data to verify plaintext

        List<Path> tempPaths = new ArrayList<Path>();

        File testFile = null;
        File testFile2 = null;
        try {
            // testFile = File.createTempFile("tmp_plaintext_file_", "tmp");
            Path testFilePath = Files.createTempFile("tmp_plaintext_file_", "tmp");
            tempPaths.add(testFilePath);
            testFile = testFilePath.toFile();
            FileWriter fw = new FileWriter(testFile);
            fw.write(PLAINTEXT);
            fw.flush();
            fw.close();

            // testFile2 = File.createTempFile("tmp_plaintext_file2_", "tmp");
            Path testFile2Path = Files.createTempFile("tmp_plaintext_file2_", "tmp");
            tempPaths.add(testFile2Path);
            testFile2 = testFile2Path.toFile();
            fw = new FileWriter(testFile2);
            fw.write(PLAINTEXT_2);
            fw.flush();
            fw.close();
        } catch (IOException e1) {
            fail("failed to create a temp file");
        }

        String[] inputToTar = new String[6];
        inputToTar[0] = PLAINTEXT_FILENAME;
        inputToTar[1] = testFile.getAbsolutePath();
        inputToTar[2] = String.valueOf(testFile.length());

        inputToTar[3] = PLAINTEXT_2_FILENAME;
        inputToTar[4] = testFile2.getAbsolutePath();
        inputToTar[5] = String.valueOf(testFile2.length());

        Message<String[]> message = MessageBuilder.withPayload(inputToTar).setHeader("dwBatchUuid", UUID)
                .setHeader("fileSuffix", FILE_SUFFIX).setHeader("recordsSent", 2).setHeader("tempPaths", tempPaths)
                .setHeader("dwConfigType", "SBAC").build();

        tarInput.send(message);

        Message<?> encryptedMessage = testChannelSbac.receive();

        Object payload = encryptedMessage.getPayload();

        try {
            byte[] compressedBytes = gpgVerifier.decryptAndVerify((File) payload);

            File testFileCompressed = null;
            try {
                testFileCompressed = File.createTempFile("tmp_compressed_file_", "tmp");
                FileOutputStream fos = new FileOutputStream(testFileCompressed);
                fos.write(compressedBytes);
                fos.flush();
                fos.close();
            } catch (IOException e1) {
                fail("failed to create a temp file");
            }

            byte[] bundledBytes = gzipUncompressor.uncompress(testFileCompressed);

            File testFileBundled = null;
            try {
                testFileBundled = File.createTempFile("tmp_bundled_file_", "tmp");
                FileOutputStream fos = new FileOutputStream(testFileBundled);
                fos.write(bundledBytes);
                fos.flush();
                fos.close();
            } catch (IOException e1) {
                fail("failed to create a temp file");
            }

            byte[][] unbundledBytes = tarUnbundler.unbundle(testFileBundled);

            assertThat(new String(unbundledBytes[0]), is(PLAINTEXT_FILENAME));
            assertThat(new String(unbundledBytes[1]), is(PLAINTEXT));
            assertThat(new String(unbundledBytes[2]), is(PLAINTEXT_2_FILENAME));
            assertThat(new String(unbundledBytes[3]), is(PLAINTEXT_2));

        } catch (SignatureException | IOException | PGPException e) {

            LOGGER.error("failure to parse final encrypted message", e);
        }

    }

    @Test
    public void testPipelineLocal() {

        // construct a message and put it into dataWarehouseInput
        // should go through pipeline and end up in testChannel where it can be pulled off

        // only compression and encryption is currently functional

        // verify signature and decrypt message
        // decrypted data should equal the compressed data
        // uncompress the data to verify plaintext

        List<Path> tempPaths = new ArrayList<Path>();

        File testFile = null;
        File testFile2 = null;
        try {
            // testFile = File.createTempFile("tmp_plaintext_file_", "tmp");
            Path testFilePath = Files.createTempFile("tmp_plaintext_file_", "tmp");
            tempPaths.add(testFilePath);
            testFile = testFilePath.toFile();
            FileWriter fw = new FileWriter(testFile);
            fw.write(PLAINTEXT);
            fw.flush();
            fw.close();

            // testFile2 = File.createTempFile("tmp_plaintext_file2_", "tmp");
            Path testFile2Path = Files.createTempFile("tmp_plaintext_file2_", "tmp");
            tempPaths.add(testFile2Path);
            testFile2 = testFile2Path.toFile();
            fw = new FileWriter(testFile2);
            fw.write(PLAINTEXT_2);
            fw.flush();
            fw.close();
        } catch (IOException e1) {
            fail("failed to create a temp file");
        }

        String[] inputToTar = new String[6];
        inputToTar[0] = PLAINTEXT_FILENAME;
        inputToTar[1] = testFile.getAbsolutePath();
        inputToTar[2] = String.valueOf(testFile.length());

        inputToTar[3] = PLAINTEXT_2_FILENAME;
        inputToTar[4] = testFile2.getAbsolutePath();
        inputToTar[5] = String.valueOf(testFile2.length());

        Message<String[]> message = MessageBuilder.withPayload(inputToTar).setHeader("dwBatchUuid", UUID)
                .setHeader("fileSuffix", FILE_SUFFIX).setHeader("recordsSent", 2).setHeader("tempPaths", tempPaths)
                .setHeader("dwConfigType", "LOCAL").build();

        tarInput.send(message);

        Message<?> encryptedMessage = testChannelLocal.receive();

        Object payload = encryptedMessage.getPayload();

        try {
            byte[] compressedBytes = gpgVerifier.decryptAndVerify((File) payload);

            File testFileCompressed = null;
            try {
                testFileCompressed = File.createTempFile("tmp_compressed_file_", "tmp");
                FileOutputStream fos = new FileOutputStream(testFileCompressed);
                fos.write(compressedBytes);
                fos.flush();
                fos.close();
            } catch (IOException e1) {
                fail("failed to create a temp file");
            }

            byte[] bundledBytes = gzipUncompressor.uncompress(testFileCompressed);

            File testFileBundled = null;
            try {
                testFileBundled = File.createTempFile("tmp_bundled_file_", "tmp");
                FileOutputStream fos = new FileOutputStream(testFileBundled);
                fos.write(bundledBytes);
                fos.flush();
                fos.close();
            } catch (IOException e1) {
                fail("failed to create a temp file");
            }

            byte[][] unbundledBytes = tarUnbundler.unbundle(testFileBundled);

            assertThat(new String(unbundledBytes[0]), is(PLAINTEXT_FILENAME));
            assertThat(new String(unbundledBytes[1]), is(PLAINTEXT));
            assertThat(new String(unbundledBytes[2]), is(PLAINTEXT_2_FILENAME));
            assertThat(new String(unbundledBytes[3]), is(PLAINTEXT_2));

        } catch (SignatureException | IOException | PGPException e) {

            LOGGER.error("failure to parse final encrypted message", e);
        }

    }

}