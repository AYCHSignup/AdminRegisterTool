/*
Educational Online Test Delivery System Copyright (c) 2013 American Institutes for Research

Distributed under the AIR Open Source License, Version 1.0 See accompanying file AIR-License-1_0.txt or at
http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 */

package org.opentestsystem.delivery.testreg.aop;

import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.Matchers.lessThanOrEqualTo;
import static org.junit.Assert.assertThat;

import java.lang.reflect.Method;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.opentestsystem.delivery.testreg.aop.trigger.ResettableTrigger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = { "classpath:test-trigger-context.xml" })
public class ResettableTriggerTest {

    @Autowired
    private ResettableTrigger trigger;

    @Test
    public void testNormalTrigger() throws InterruptedException {

        TestObject obj = new TestObject();
        Method invokeMethod = null;
        try {
            invokeMethod = obj.getClass().getDeclaredMethod("invoke", String.class);
        } catch (NoSuchMethodException | SecurityException e1) {
            e1.printStackTrace();
        }

        trigger.setup(400L, obj, invokeMethod, new Object[] { "test object being invoked!" });

        long start = System.currentTimeMillis();
        System.out.println("started at: " + start);
        // the runnable should have been invoked within start + 500ms (we'll give it some time for overhead)
        long startPlus500 = start + 500L;

        Thread.sleep(500L);

        assertThat(obj.isInvoked(), is(true));
        assertThat(obj.getInvokeTime(), lessThanOrEqualTo(startPlus500));

    }

    @Test
    public void testDelayTriggerOneTime() throws InterruptedException {

        TestObject obj = new TestObject();
        Method invokeMethod = null;
        try {
            invokeMethod = obj.getClass().getDeclaredMethod("invoke", String.class);
        } catch (NoSuchMethodException | SecurityException e1) {
            e1.printStackTrace();
        }

        long start = System.currentTimeMillis();
        System.out.println("started at: " + start);

        trigger.setup(400L, obj, invokeMethod, new Object[] { "test object being invoked!" });

        long startPlus500 = start + 500L;
        long startPlus1000 = start + 1000L;

        Thread.sleep(300L);

        System.out.println("resetting trigger at: " + System.currentTimeMillis());
        trigger.resetTrigger();

        Thread.sleep(500L);

        assertThat(obj.isInvoked(), is(true));
        assertThat(obj.getInvokeTime(), org.hamcrest.Matchers.greaterThanOrEqualTo(startPlus500));
        assertThat(obj.getInvokeTime(), org.hamcrest.Matchers.lessThanOrEqualTo(startPlus1000));

    }

    public class TestObject {
        private boolean invoked;
        private long invokeTime;

        public boolean isInvoked() {
            return invoked;
        }

        public void setInvoked(final boolean invoked) {
            this.invoked = invoked;
        }

        public long getInvokeTime() {
            return invokeTime;
        }

        public void setInvokeTime(final long invokeTime) {
            this.invokeTime = invokeTime;
        }

        public void invoke(final String text) {
            System.out.println("invoking: " + text);
            System.out.println("invoked at: " + System.currentTimeMillis());
            invoked = true;
            invokeTime = System.currentTimeMillis();

        }
    }

}
