/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/

package org.opentestsystem.delivery.testreg.domain;

import static org.hamcrest.core.Is.is;
import static org.junit.Assert.assertThat;

import java.util.ArrayList;
import java.util.List;
import java.util.Set;

import javax.validation.ConstraintViolation;
import javax.validation.Validator;

import org.joda.time.DateTime;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.opentestsystem.delivery.testreg.domain.Assessment.EligibilityType;
import org.opentestsystem.delivery.testreg.domain.Assessment.TestWindow;
import org.opentestsystem.delivery.testreg.domain.ImplicitEligibilityRule.OperatorType;
import org.opentestsystem.delivery.testreg.domain.ImplicitEligibilityRule.RuleType;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = { "classpath:spring/domain-context.xml", "classpath:test-domain-context.xml" })
public class AssessmentTest {

    @Autowired
    protected Validator validator;

    private Assessment assessment;
    private TestWindow testWindow;

    @Before
    public void setup() {
        assessment = new Assessment();
        testWindow = new TestWindow();
    }

    @After
    public void tearDown() {
        assessment = null;
        testWindow = null;
    }

    private void assertBlankOrNullCheck(final Assessment assessment, final String property, final String message) {
        Set<ConstraintViolation<Assessment>> constraintViolations = validator.validateProperty(assessment, property,
                AssessmentValidationGroup.class);
        assertThat(constraintViolations.size(), is(1));
        assertThat(constraintViolations.iterator().next().getMessage(), is(message));
    }

    @Test
    public void testBlankOrNullNumGlobalOpportunities() {
        String message = "Assessment Global Opportunities is required";
        assessment.setTestName("test1");
        assessment.setVersion("1");
        assessment.setNumGlobalOpportunities(null);
        assertBlankOrNullCheck(assessment, "numGlobalOpportunities", message);

    }

    @Test
    public void testBlankOrNullBeginWindow() {

        Set<ConstraintViolation<TestWindow>> constraintViolations = validator.validateProperty(testWindow,
                "beginWindow");
        assertThat(constraintViolations.size(), is(1));
        assertThat(constraintViolations.iterator().next().getMessage(), is("Begin Window Date Time required"));

    }

    @Test
    public void testBlankOrNullEndWindow() {

        Set<ConstraintViolation<TestWindow>> constraintViolations = validator.validateProperty(testWindow, "endWindow");
        assertThat(constraintViolations.size(), is(1));
        assertThat(constraintViolations.iterator().next().getMessage(), is("End Window Date Time required"));

    }

    @Test
    public void testBlankOrNullEligibilityType() {

        Set<ConstraintViolation<Assessment>> constraintViolations = validator.validateProperty(assessment,
                "eligibilityType", AssessmentValidationGroup.class);
        assertThat(constraintViolations.size(), is(1));
        assertThat(constraintViolations.iterator().next().getMessage(), is("Eligibility type is required"));

    }

    @Test
    public void testValidDelayRule() {
        assessment.setDelayRule(-1);
        Set<ConstraintViolation<Assessment>> constraintViolations = validator.validateProperty(assessment, "delayRule");
        assertThat(constraintViolations.size(), is(1));
        assertThat(constraintViolations.iterator().next().getMessage(), is("Assessment Delay Rule min valid value 1"));

    }

    @Test
    public void testValidTotalOpportunities() {
        TestWindow window = new TestWindow();
        window.setNumOpportunities(-1);
        Set<ConstraintViolation<TestWindow>> constraintViolations = validator.validateProperty(window,
                "numOpportunities");
        assertThat(constraintViolations.size(), is(1));
        assertThat(constraintViolations.iterator().next().getMessage(), is("Total Opportunities min valid value 1"));
    }

    @Test
    public void testBlankOrNullWindowBeginEndDate() {
        Assessment assessment = new Assessment();
        assessment.setNumGlobalOpportunities(2);
        assessment.setEligibilityType(EligibilityType.EXPLICIT);
        TestWindow testWindow = new TestWindow();
        TestWindow[] arr = { testWindow };
        testWindow.setNumOpportunities(1);
        assessment.setTestWindow(arr);
        Set<ConstraintViolation<TestWindow>> violations = validator.validate(testWindow);
        assertThat(violations.size(), is(2));

    }

    @Test
    public void testInvalidDelayRule() {
        Assessment assessment = new Assessment();
        assessment.setNumGlobalOpportunities(2);
        assessment.setEligibilityType(EligibilityType.EXPLICIT);
        TestWindow testWindow = new TestWindow();
        TestWindow[] arr = { testWindow };

        testWindow.setBeginWindow(new DateTime(2014, 1, 1, 10, 30));
        testWindow.setEndWindow(new DateTime(2014, 1, 1, 10, 50));
        assessment.setTestName("test7");
        assessment.setVersion("1");
        assessment.setTestWindow(arr);
        Set<ConstraintViolation<Assessment>> violations = validator.validate(assessment);
        assertThat(violations.size(), is(1));
        assertThat(violations.iterator().next().getMessage(), is("Assessment Delay Rule is required if total opportunities is > 1 and test windows is empty"));
    }

    @Test
    public void testInvalidGlobalNumOpportunities() {
        Assessment assessment = new Assessment();
        assessment.setNumGlobalOpportunities(2);
        assessment.setEligibilityType(EligibilityType.EXPLICIT);
        TestWindow testWindow = new TestWindow();
        testWindow.setBeginWindow(new DateTime(2014, 1, 1, 10, 30));
        testWindow.setEndWindow(new DateTime(2014, 1, 1, 10, 50));
        testWindow.setNumOpportunities(1);
        TestWindow testWindow1 = new TestWindow();
        testWindow1.setBeginWindow(new DateTime(2015, 1, 1, 10, 30));
        testWindow1.setEndWindow(new DateTime(2015, 1, 1, 10, 50));
        testWindow1.setNumOpportunities(4);
        TestWindow[] arr = { testWindow, testWindow1 };
        assessment.setTestName("test6");
        assessment.setVersion("1");
        assessment.setTestWindow(arr);
        Set<ConstraintViolation<Assessment>> violations = validator.validate(assessment);
        assertThat(violations.size(), is(1));
        assertThat(
                violations.iterator().next().getMessage(),
                is("A window specific total of opportunities should not be greater than the global number of opportunities"));
    }

    @Test
    public void testBlankOrNullTestWindowNumOpportunities() {
        Assessment assessment = new Assessment();
        assessment.setNumGlobalOpportunities(2);
        assessment.setEligibilityType(EligibilityType.EXPLICIT);
        assessment.setDelayRule(2);
        TestWindow testWindow = new TestWindow();
        testWindow.setBeginWindow(new DateTime(2014, 1, 1, 10, 30));
        testWindow.setEndWindow(new DateTime(2014, 1, 1, 10, 50));
        testWindow.setNumOpportunities(1);
        TestWindow testWindow1 = new TestWindow();
        testWindow1.setBeginWindow(new DateTime(2015, 1, 1, 10, 30));
        testWindow1.setEndWindow(new DateTime(2015, 1, 1, 10, 50));
        TestWindow[] arr = { testWindow, testWindow1 };
        assessment.setTestName("test3");
        assessment.setVersion("1");
        assessment.setTestWindow(arr);
        Set<ConstraintViolation<Assessment>> violations = validator.validate(assessment);
        assertThat(violations.size(), is(1));
        assertThat(violations.iterator().next().getMessage(), is("TestWindow Total Opportunities required"));

    }

    @Test
    public void testTestWindowBeginAndEnd() {
        Assessment assessment = new Assessment();
        assessment.setNumGlobalOpportunities(2);
        assessment.setDelayRule(2);
        TestWindow testWindow = new TestWindow();
        assessment.setEligibilityType(EligibilityType.EXPLICIT);
        testWindow.setBeginWindow(new DateTime(2014, 1, 1, 10, 30));
        testWindow.setEndWindow(new DateTime(2014, 1, 1, 10, 20));

        TestWindow[] arr = { testWindow };
        assessment.setTestName("test2");
        assessment.setVersion("1");
        assessment.setTestWindow(arr);

        Set<ConstraintViolation<Assessment>> violations = validator.validate(assessment);
        assertThat(violations.size(), is(1));
        assertThat(violations.iterator().next().getMessage(),
                is("The begin date must be before the end date of a test window"));
    }

    @Test
    public void testTestWindowDelayRule() {
        Assessment assessment = new Assessment();
        assessment.setNumGlobalOpportunities(1);
        TestWindow testWindow = new TestWindow();
        assessment.setEligibilityType(EligibilityType.EXPLICIT);
        assessment.setDelayRule(1);
        testWindow.setBeginWindow(new DateTime(2014, 1, 1, 10, 30));
        testWindow.setEndWindow(new DateTime(2014, 1, 1, 10, 40));

        TestWindow[] arr = { testWindow };
        assessment.setTestName("test5");
        assessment.setVersion("1");
        assessment.setTestWindow(arr);
        Set<ConstraintViolation<Assessment>> violations = validator.validate(assessment);
        assertThat(violations.size(), is(1));
    }

    @Test
    public void testNoTestName() {
        Assessment assess = new Assessment();
        assess.setDelayRule(2);
        assess.setEligibilityType(EligibilityType.EXPLICIT);
        assess.setNumGlobalOpportunities(4);
        assess.setTestWindow(new Assessment.TestWindow[] { new Assessment.TestWindow(new DateTime(2013, 12, 1, 0, 0),
                new DateTime(2013, 12, 31, 0, 0), null) });
        assess.setVersion("1");

        Set<ConstraintViolation<Assessment>> violations = validator.validate(assess);
        assertThat(violations.size(), is(1));
        assertThat(violations.iterator().next().getMessage(), is("Assessment Test Name is required"));
    }

    @Test
    public void testNoVersion() {
        Assessment assess = new Assessment();
        assess.setDelayRule(2);
        assess.setEligibilityType(EligibilityType.EXPLICIT);
        assess.setNumGlobalOpportunities(4);
        assess.setTestWindow(new Assessment.TestWindow[] { new Assessment.TestWindow(new DateTime(2013, 12, 1, 0, 0),
                new DateTime(2013, 12, 31, 0, 0), null) });
        assess.setTestName("test12");

        Set<ConstraintViolation<Assessment>> violations = validator.validate(assess);
        assertThat(violations.size(), is(1));
        assertThat(violations.iterator().next().getMessage(), is("Assessment Version is required"));
    }

    @Test
    public void testBlankOrNullAcademicYear() {

        Set<ConstraintViolation<Assessment>> constraintViolations = validator.validateProperty(assessment,
                "academicYear", AssessmentValidationGroup.class);
        assertThat(constraintViolations.size(), is(1));
        assertThat(constraintViolations.iterator().next().getMessage(), is("Academic Year is required (4 digit year)"));

    }

    @Test
    public void testAcademicYearLessThan2000() {

        Assessment assess = new Assessment();
        assess.setAcademicYear("1999");

        Set<ConstraintViolation<Assessment>> constraintViolations = validator.validateProperty(assess, "academicYear",
                AssessmentValidationGroup.class);
        assertThat(constraintViolations.size(), is(1));
        assertThat(constraintViolations.iterator().next().getMessage(),
                is("Academic Year must be greater than or equal to 2000"));

    }

    @Test
    public void testAcademicYearGreaterThan9999() {

        Assessment assess = new Assessment();
        assess.setAcademicYear("10976");

        Set<ConstraintViolation<Assessment>> constraintViolations = validator.validateProperty(assess, "academicYear",
                AssessmentValidationGroup.class);
        assertThat(constraintViolations.size(), is(2));

        List<String> messages = new ArrayList<String>();
        for (ConstraintViolation<Assessment> violation : constraintViolations) {
            messages.add(violation.getMessage());
        }

        assertThat(messages, org.hamcrest.Matchers.containsInAnyOrder(
                "Academic Year must be less than or equal to 9999", "Academic Year must be a valid 4 digit year"));

    }

    @Test
    public void testAcademicYearNoDecimalAllowed() {

        Assessment assess = new Assessment();
        assess.setAcademicYear("2010.1");

        Set<ConstraintViolation<Assessment>> constraintViolations = validator.validateProperty(assess, "academicYear",
                AssessmentValidationGroup.class);
        assertThat(constraintViolations.size(), is(1));
        assertThat(constraintViolations.iterator().next().getMessage(),
                is("Academic Year must be a valid 4 digit year"));

    }

    @Test
    public void testAcademicYearGood() {

        Assessment assess = new Assessment();
        assess.setAcademicYear("2000");

        Set<ConstraintViolation<Assessment>> constraintViolations = validator.validateProperty(assess, "academicYear",
                AssessmentValidationGroup.class);
        assertThat(constraintViolations.size(), is(0));

    }

    @Test
    public void testAtLeastOneImplicitRule() {
        Assessment assess = new Assessment();
        assess.setDelayRule(2);
        assess.setEligibilityType(EligibilityType.IMPLICIT);
        assess.setNumGlobalOpportunities(4);
        assess.setTestWindow(new Assessment.TestWindow[] { new Assessment.TestWindow(new DateTime(2013, 12, 1, 0, 0),
                new DateTime(2013, 12, 31, 0, 0), null) });
        assess.setTestName("test12");
        assess.setVersion("1.0");

        Set<ConstraintViolation<Assessment>> violations = validator.validate(assess);
        assertThat(violations.size(), is(1));
        assertThat(violations.iterator().next().getMessage(),
                is("At least one Implicit Rule is required when setting Assessment to use Implicit Eligiblity"));
    }

    @Test
    public void testGoodImplicitAssessment() {
        Set<ConstraintViolation<Assessment>> violations = validator.validate(getValidAssessment());
        assertThat(violations.size(), is(0));

    }

    @Test
    public void testDuplicateImplicitAssessment() {
        Assessment assess = new Assessment();
        assess.setDelayRule(2);
        assess.setEligibilityType(EligibilityType.IMPLICIT);
        assess.setNumGlobalOpportunities(4);
        assess.setTestWindow(new Assessment.TestWindow[] { new Assessment.TestWindow(new DateTime(2013, 12, 1, 0, 0),
                new DateTime(2013, 12, 31, 0, 0), null) });
        assess.setTestName("test12");
        assess.setVersion("1.0");

        ImplicitEligibilityRule rule = new ImplicitEligibilityRule();
        rule.setField("test");
        rule.setOperatorType(OperatorType.EQUALS);
        rule.setRuleType(RuleType.ENABLER);
        rule.setValue("test");
        ImplicitEligibilityRule rule1 = new ImplicitEligibilityRule();
        rule1.setField("test");
        rule1.setOperatorType(OperatorType.EQUALS);
        rule1.setRuleType(RuleType.ENABLER);
        rule1.setValue("test");

        assess.setImplicitEligibilityRules(new ImplicitEligibilityRule[] { rule, rule1 });

        Set<ConstraintViolation<Assessment>> violations = validator.validate(assess);
        assertThat(violations.size(), is(1));
        assertThat(violations.iterator().next().getMessage(),
                is("Duplicates Implicit Rules are not allowed"));
    }
    
    private Assessment getValidAssessment() {
        Assessment assess = new Assessment();
        assess.setDelayRule(2);
        assess.setEligibilityType(EligibilityType.IMPLICIT);
        assess.setNumGlobalOpportunities(4);
        assess.setTestWindow(new Assessment.TestWindow[] { new Assessment.TestWindow(new DateTime(2013, 12, 1, 0, 0),
                new DateTime(2013, 12, 31, 0, 0), null) });
        assess.setTestName("test12");
        assess.setVersion("1.0");

        ImplicitEligibilityRule rule = new ImplicitEligibilityRule();
        rule.setField("test");
        rule.setOperatorType(OperatorType.EQUALS);
        rule.setRuleType(RuleType.ENABLER);
        rule.setValue("test");

        assess.setImplicitEligibilityRules(new ImplicitEligibilityRule[] { rule });
        return assess;
    }
    
    @Test
    public void testOverlappingWindows() {
        Assessment assess = getValidAssessment();
        //Add Overlapping TestWindow
        assess.setTestWindow(new Assessment.TestWindow[] { 
                    new Assessment.TestWindow(new DateTime(2014, 06, 12, 0, 0), new DateTime(2014, 12, 24, 0, 0), 1),
                    new Assessment.TestWindow(new DateTime(2014, 12, 11, 0, 0), new DateTime(2015, 12, 12, 0, 0), 1),
                    });
        
        Set<ConstraintViolation<Assessment>> violations = validator.validate(assess);
        assertThat(violations.size(), is(1));
        assertThat(violations.iterator().next().getMessage(),
                is("Overlapping TestWindows are present "));        
    }
    
    @Test
    public void testDuplicateWindows() {
        Assessment assess = getValidAssessment();
        //Add Overlapping TestWindow
        assess.setTestWindow(new Assessment.TestWindow[] { 
                    new Assessment.TestWindow(new DateTime(2014, 06, 12, 0, 0), new DateTime(2014, 12, 24, 0, 0), 1),
                    new Assessment.TestWindow(new DateTime(2014, 06, 12, 0, 0), new DateTime(2014, 12, 24, 0, 0), 1)
                    });
        
        Set<ConstraintViolation<Assessment>> violations = validator.validate(assess);
        assertThat(violations.size(), is(1));
        assertThat(violations.iterator().next().getMessage(),
                is("Duplicate TestWindows are present "));        
    }
}
