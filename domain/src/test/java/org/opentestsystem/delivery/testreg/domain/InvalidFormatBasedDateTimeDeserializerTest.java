/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/

package org.opentestsystem.delivery.testreg.domain;

import static org.hamcrest.core.Is.is;
import static org.junit.Assert.assertThat;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;

import org.joda.time.DateTime;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameters;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.exc.InvalidFormatException;
import com.fasterxml.jackson.databind.module.SimpleModule;

@RunWith(Parameterized.class)
public class InvalidFormatBasedDateTimeDeserializerTest {

    ObjectMapper mapper;
    
    private String inputDate;
    
    private Boolean expectedResult;
    
    public InvalidFormatBasedDateTimeDeserializerTest(String inputdate, Boolean expectedResult) {
        this.inputDate = inputdate;
        this.expectedResult = expectedResult;
    }
    
    @SuppressWarnings("serial")
    @Before
    public void setup() {
        mapper = new ObjectMapper();
        mapper.registerModule(new SimpleModule(){{
            addDeserializer(DateTime.class, new InvalidFormatBasedDateTimeDeserializer());
        }});
    }
    
    @Parameters
    public static List<?> dateValues() {
        return Arrays.asList(new Object[][] {
                {"", true}, //Empty should be validated elsewhere
                {"2011-12-13", true},  
                {"2000-02-30", false},  
                {"2000-02-29", true},  //leap year
                {"200088-02-12", false}, 
                {"2012-02-29T16:08:01.151-06:00", true}, //leap year
                {"2014-191-21T16:08:01.151-06:00", false},
                {"2014-99-21T16:08:01.151-06:00", false},
                {"2014-00-21T16:08:01.151-06:00", false},
                {"2014-88-21T16:08:01.151-06:00", false},
                {"2014-91-81T16:08:01.151-06:00", false},
                {"2014-91-99T16:08:01.151-06:00", false},
                {"2014-91-00T16:08:01.151-06:00", false},
                {"2007-29-00T16:08:01.151-06:00", false},
                {"2014-191-21T16:08:01.151-06:00", false},
                {"2014-191-21T16:08:01.151-06:00", false},
                {"2014-111191-21T16:08:01.151-06:00", false},
                {"2014-1222291-21T16:08:01.151-06:00", false},
                {"2014-1333391-21T16:08:01.151-06:00", false},
                {"2014-1222222222222222291-21T16:08:01.151-06:00", false},
                {"2014-91-121T16:08:01.151-06:00", false},
                {"02014-191-21T16:08:01.151-06:00", false},
                {"0112014-191-21T16:08:01.151-06:00", false},
                {"0112014/191/21T16:08:01.151-06:00", false},
                {"11-1911-211T16:08:01.151-06:00", false}
                
        });
    }
    
    private boolean readDate(String date) throws JsonProcessingException, IOException {
        try {
            mapper.readValue(quote(date), DateTime.class);
            return true;
        } catch(InvalidFormatException exception) {
            return false;
        }
    }
    
    @Test
    public void testDates() throws JsonProcessingException, IOException {
        assertThat(readDate(inputDate), is(expectedResult));
    }
    
    public String quote(String str) {
        return '"'+str+'"';
    }
}
