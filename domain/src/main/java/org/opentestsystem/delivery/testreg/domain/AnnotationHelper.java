/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/

package org.opentestsystem.delivery.testreg.domain;

import java.io.IOException;
import java.util.HashSet;
import java.util.Set;

import org.springframework.beans.factory.config.BeanDefinition;
import org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider;
import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.core.type.classreading.MetadataReader;
import org.springframework.core.type.classreading.MetadataReaderFactory;
import org.springframework.core.type.filter.AnnotationTypeFilter;
import org.springframework.core.type.filter.AssignableTypeFilter;
import org.springframework.data.annotation.Persistent;
import org.springframework.data.mongodb.core.mapping.Document;
import org.springframework.util.ReflectionUtils;
import org.springframework.util.StringUtils;

/**
 * Simple Helper class for methods related to annotations
 * 
 */
public final class AnnotationHelper {

    private AnnotationHelper() {}

    /**
     * Returns {@link org.opentestsystem.delivery.testreg.domain.FieldLabel} associated with the property. If there is
     * no annotation present on the field returns the property as is.
     * 
     * @param object
     *            Object which has the field
     * @param property
     *            Java Bean Property of the object
     * @return Value of FieldLabel annotation present on the property
     */
    public static String getFieldLabel(final Object object, final String property) {
        return getFieldLabel(object.getClass(), property);
    }
    
    public static String getFieldLabel(Class<?> clazz, final String property) {
        try {
            return AnnotationUtils.getAnnotation(ReflectionUtils.findField(clazz, property),
                    FieldLabel.class).value();
        } catch (Exception e) {
            return property; // As a fallback just return the property in case of any exceptions.
        }
    }

    /**
     * Scans the mapping base package for classes annotated with {@link Document} and that are Sb11Entities
     * {@link Sb11Entity}, Sb11NonEntities {@link Sb11NonEntity}, or TestRegistrationBase {@link TestRegistrationBase}
     * 
     * @param basePackage
     *            base package to scan
     * @return
     * @throws ClassNotFoundException
     */
    public static Set<Class<? extends TestRegistrationBase>> getInitialEntitySet(final String basePackage)
            throws ClassNotFoundException {

        Set<Class<? extends TestRegistrationBase>> initialEntitySet = new HashSet<Class<? extends TestRegistrationBase>>();

        if (StringUtils.hasText(basePackage)) {
            ClassPathScanningCandidateComponentProvider componentProvider = new ClassPathScanningCandidateComponentProvider(
                    false);
            componentProvider.addIncludeFilter(new AnnotationTypeFilter(Document.class));
            componentProvider.addIncludeFilter(new AnnotationTypeFilter(Persistent.class));
            componentProvider.addIncludeFilter(new AssignableTypeFilter(Sb11Entity.class) {
                public boolean match(final MetadataReader metadataReader,
                        final MetadataReaderFactory metadataReaderFactory) throws IOException {
                    return metadataReader.getClassMetadata().isInterface()
                            && super.match(metadataReader, metadataReaderFactory);
                }
            });

            componentProvider.addIncludeFilter(new AssignableTypeFilter(Sb11NonEntity.class) {
                public boolean match(final MetadataReader metadataReader,
                        final MetadataReaderFactory metadataReaderFactory) throws IOException {
                    return metadataReader.getClassMetadata().isInterface()
                            && super.match(metadataReader, metadataReaderFactory);
                }
            });

            componentProvider.addIncludeFilter(new AssignableTypeFilter(TestRegistrationBase.class) {
                public boolean match(final MetadataReader metadataReader,
                        final MetadataReaderFactory metadataReaderFactory) throws IOException {
                    return metadataReader.getClassMetadata().isInterface()
                            && super.match(metadataReader, metadataReaderFactory);
                }
            });

            for (BeanDefinition candidate : componentProvider.findCandidateComponents(basePackage)) {
                try {
                    initialEntitySet.add(Class.forName(candidate.getBeanClassName()).asSubclass(
                            TestRegistrationBase.class));
                } catch (ClassCastException cce) {
                    /*
                     * Don't you worry about this. Okay? Because classpath scanning candidate component provider would
                     * not invoke filters further down the chain when anyones succeeds. So we usually get more than we
                     * wanted.
                     */
                }
            }
        }
        return initialEntitySet;
    }
}
