/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.delivery.testreg.domain.search;

import static org.springframework.data.mongodb.core.aggregation.Aggregation.group;
import static org.springframework.data.mongodb.core.aggregation.Aggregation.match;
import static org.springframework.data.mongodb.core.aggregation.Aggregation.newAggregation;
import static org.springframework.data.mongodb.core.aggregation.Aggregation.unwind;

import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.opentestsystem.delivery.testadmin.domain.search.FacilityAvailabilitySearchRequest;
import org.opentestsystem.delivery.testadmin.domain.search.FacilitySearchRequest;
import org.opentestsystem.delivery.testadmin.domain.search.ScheduleSearchRequest;
import org.opentestsystem.delivery.testreg.domain.Student;
import org.opentestsystem.delivery.testreg.domain.User;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.mongodb.core.aggregation.AggregationResults;
import org.springframework.data.mongodb.core.aggregation.TypedAggregation;
import org.springframework.data.mongodb.core.query.Criteria;

import com.mongodb.DBObject;

public abstract class AbstractTestRegNonEntitySearchRequest extends AbstractTestRegSearchRequest {

    private static final long serialVersionUID = 3918596245444169252L;

    @SuppressWarnings("unused")
    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractTestRegNonEntitySearchRequest.class);

    public AbstractTestRegNonEntitySearchRequest(final Map<String, String[]> requestMap) {
        super(requestMap);
    }

    @Override
    protected Map<String, Criteria> buildCustomCriteria(Map<String, Criteria> currentCriteriaMap) {
        Collection<String> permissibleEntityIds = getPermissibleEntityIds();
        boolean permissibleEntityIdsAvailable = permissibleEntityIds != null && permissibleEntityIds.size() > 0;
        Map<String, Criteria> newCriteriaMap = new HashMap<>(currentCriteriaMap);
        if (this instanceof StudentSearchRequest) {
            if (permissibleEntityIdsAvailable) {
                Criteria c = new Criteria().orOperator(Criteria.where("institutionEntityMongoId").in(permissibleEntityIds),
                        Criteria.where("districtEntityMongoId").in(permissibleEntityIds));
                newCriteriaMap.put(c.getKey(), c);
            }
        } else if (this instanceof AssessmentSearchRequest) {
            // --------------------------------------------------------------------------------------------------------------------
            // Since assessment search is derived from the tenant id passed from UI there is no need to add any other criteria here
            // --------------------------------------------------------------------------------------------------------------------
        } else if (this instanceof AccommodationSearchRequest) {
            if (permissibleEntityIdsAvailable) {
                TypedAggregation<Student> aggregation = newAggregation(
                        Student.class,
                        match(Criteria.where("institutionEntityMongoId").nin(permissibleEntityIds)
                                .orOperator(Criteria.where("districtEntityMongoId").nin(permissibleEntityIds))),
                        group("id"));
                AggregationResults<DBObject> results = ((AccommodationSearchRequest) this).getMongoTemplate().aggregate(
                        aggregation, Student.class, DBObject.class);
                Set<String> nonAccessibleStudentIds = new HashSet<>();
                for (DBObject dbObject : results.getMappedResults()) {
                    nonAccessibleStudentIds.add(dbObject.get("_id").toString());
                }
                Criteria c = Criteria.where("studentId").nin(nonAccessibleStudentIds);
                newCriteriaMap.put(c.getKey(), c);
            }
        } else if (this instanceof ExplicitEligibilitySearchRequest) {
            if (permissibleEntityIdsAvailable) {
                Criteria c = Criteria.where("responsibleDistrictMongoId").in(permissibleEntityIds);
                newCriteriaMap.put(c.getKey(), c);
            }
        } else if (this instanceof StudentGroupSearchRequest) {
            if (permissibleEntityIdsAvailable) {
                Criteria c = new Criteria().orOperator(Criteria.where("institutionEntityMongoId").in(permissibleEntityIds),
                        Criteria.where("districtEntityMongoId").in(permissibleEntityIds));
                newCriteriaMap.put(c.getKey(), c);
            }
        } else if (this instanceof UserSearchRequest) {
            try {

                if (permissibleEntityIdsAvailable) {

                    // 1. Find all users (IDs) that have access to entities that the current can't access
                    // 2. Find all users (IDs) that have a protected role that the current does not
                    Criteria inaccessibleUserCriteria = new Criteria().orOperator(
                            Criteria.where("roleAssociations.associatedEntityMongoId").nin(permissibleEntityIds),
                            Criteria.where("roleAssociations.role").in(getInaccessibleProtectedRoleNames()));

                    TypedAggregation<User> aggregation = newAggregation(User.class, unwind("roleAssociations"),
                            match(inaccessibleUserCriteria), group("id"));

                    Set<String> nonAccessibleUserIds = new HashSet<>();
                    AggregationResults<DBObject> results = ((UserSearchRequest) this).getMongoTemplate().aggregate(
                            aggregation, User.class, DBObject.class);
                    for (DBObject dbObject : results.getMappedResults()) {
                        nonAccessibleUserIds.add(dbObject.get("_id").toString());
                    }

                    nonAccessibleUserIds.remove(getCurrentUserId());
                    Criteria c = Criteria.where("id").nin(nonAccessibleUserIds);
                    newCriteriaMap.put(c.getKey(), c);
                }

                // we need a more flexible way to search for the state abbreviation since the role assoc. at the state level don't hold
                // state abbreviation in the stateAbbreviation field (they store it as their associatedEntityId)
                Map<String, String[]> currentCriteria = this.getSearchCriteria();
                String keys[] = { UserSearchRequest.SEARCH_KEY_STATE, UserSearchRequest.SEARCH_KEY_NAME_STATE_CODE };
                for (String key : keys) {
                    if (currentCriteria.containsKey(key)) {
                        Criteria replacementCriteria = new Criteria().orOperator(
                                Criteria.where(UserSearchRequest.SEARCH_KEY_ASSOCIATED_ENTITY_ID).is(currentCriteria.get(key)[0]),
                                Criteria.where(UserSearchRequest.SEARCH_KEY_STATE).is(currentCriteria.get(key)[0]));
                        newCriteriaMap.remove(UserSearchRequest.SEARCH_KEY_STATE); // since it was a copy of the currentCriteriaMap
                        newCriteriaMap.put(key, replacementCriteria);
                    }
                }

            } catch (RuntimeException e) {
                e.printStackTrace();
            }

        } else if (this instanceof EligibleStudentSearchRequest) {
            if (permissibleEntityIdsAvailable) {
                Criteria c = new Criteria().orOperator(
                        Criteria.where("student.institutionEntityMongoId").in(permissibleEntityIds),
                        Criteria.where("student.districtEntityMongoId").in(permissibleEntityIds));
                newCriteriaMap.put(c.getKey(), c);
            }
        } else if (this instanceof FacilitySearchRequest || this instanceof FacilityAvailabilitySearchRequest
                || this instanceof ScheduleSearchRequest) {
            if (permissibleEntityIdsAvailable) {
                Criteria c = Criteria.where("institutionId").in(permissibleEntityIds);
                newCriteriaMap.put(c.getKey(), c);
            }
        } else {
            throw new RuntimeException(
                    "unable to determine and/or handle this type of AbstractTestRegNonEntitySearchRequest class: "
                            + this.getClass().getName());
        }

        return newCriteriaMap;
    }
}
