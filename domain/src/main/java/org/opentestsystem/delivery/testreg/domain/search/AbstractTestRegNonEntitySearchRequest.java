/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.delivery.testreg.domain.search;

import com.mongodb.DBObject;
import org.opentestsystem.delivery.testreg.domain.Student;
import org.opentestsystem.delivery.testreg.domain.User;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.data.mongodb.core.aggregation.AggregationResults;
import org.springframework.data.mongodb.core.aggregation.TypedAggregation;
import org.springframework.data.mongodb.core.query.Criteria;

import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import static org.springframework.data.mongodb.core.aggregation.Aggregation.*;

public abstract class AbstractTestRegNonEntitySearchRequest extends AbstractTestRegSearchRequest {

    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractTestRegNonEntitySearchRequest.class);

    public AbstractTestRegNonEntitySearchRequest(final Map<String, String[]> requestMap) {
        super(requestMap);
    }

    @Override
    protected Criteria buildCustomCriteria() {
        Criteria c = null;
        if (this instanceof StudentSearchRequest) {
            c = new Criteria().orOperator(
                    Criteria.where("institutionEntityMongoId").in(getPermissibleEntityIds()),
                    Criteria.where("districtEntityMongoId").in(getPermissibleEntityIds()));
        } else if (this instanceof AssessmentSearchRequest) {
            //--------------------------------------------------------------------------------------------------------------------
            // Since assessment search is derived from the tenant id passed from UI there is no need to add any other criteria here
            //--------------------------------------------------------------------------------------------------------------------
        } else if (this instanceof AccommodationSearchRequest) {
            TypedAggregation<Student> aggregation = newAggregation(Student.class,
                    match(Criteria.where("institutionEntityMongoId").nin(getPermissibleEntityIds()).orOperator(Criteria.where("districtEntityMongoId").nin(getPermissibleEntityIds()))),
                    group("id")
            );
            AggregationResults<DBObject> results = ((AccommodationSearchRequest) this).getMongoTemplate().aggregate(aggregation, Student.class, DBObject.class);
            Set<String> nonAccessibleStudentIds = new HashSet<>();
            for (DBObject dbObject : results.getMappedResults()) {
                nonAccessibleStudentIds.add(dbObject.get("_id").toString());
            }
            c = Criteria.where("studentId").nin(nonAccessibleStudentIds);
        } else if (this instanceof ExplicitEligibilitySearchRequest) {
            c = Criteria.where("responsibleDistrictMongoId").in(getPermissibleEntityIds());
        } else if (this instanceof StudentGroupSearchRequest) {
            c = new Criteria().orOperator(
                    Criteria.where("institutionEntityMongoId").in(getPermissibleEntityIds()),
                    Criteria.where("districtEntityMongoId").in(getPermissibleEntityIds()));
        } else if (this instanceof UserSearchRequest) {
            try {

                // 1. Find all users (IDs) that have access to entities that the current can't access
                // 2. Find all users (IDs) that have a protected role that the current does not
                Criteria inaccessibleUserCriteria = new Criteria().orOperator(
                        Criteria.where("roleAssociations.associatedEntityMongoId").nin(getPermissibleEntityIds()),
                        Criteria.where("roleAssociations.role").in(getInaccessibleProtectedRoleNames())
                );

                TypedAggregation<User> aggregation = newAggregation(User.class,
                        unwind("roleAssociations"),
                        match(inaccessibleUserCriteria),
                        group("id")
                );

                Set<String> nonAccessibleUserIds = new HashSet<>();
                AggregationResults<DBObject> results = ((UserSearchRequest) this).getMongoTemplate().aggregate(aggregation, User.class, DBObject.class);
                for (DBObject dbObject : results.getMappedResults()) {
                    nonAccessibleUserIds.add(dbObject.get("_id").toString());
                }

                nonAccessibleUserIds.remove(getCurrentUserId());
                c = Criteria.where("id").nin(nonAccessibleUserIds);
            } catch (RuntimeException e) {
                e.printStackTrace();
            }

        } else if (this instanceof EligibleStudentSearchRequest) {
            c = new Criteria().orOperator(
                    Criteria.where("student.institutionEntityMongoId").in(getPermissibleEntityIds()),
                    Criteria.where("student.districtEntityMongoId").in(getPermissibleEntityIds()));
        } else {
            throw new RuntimeException("unable to determine and/or handle this type of AbstractTestRegNonEntitySearchRequest class: " + this.getClass().getName());
        }
        return c;
    }
}
