/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2014 American Institutes for Research
 *
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 *  http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/
package org.opentestsystem.delivery.testreg.domain;

import java.util.Comparator;
import java.util.List;

import org.apache.commons.lang.StringUtils;
import org.opentestsystem.delivery.testreg.domain.event.AssessmentModificationEvent;
import org.opentestsystem.shared.progman.client.domain.Tenant;

import com.google.common.base.Function;
import com.google.common.base.Predicate;
import com.google.common.base.Predicates;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;

public class ARTHelpers {

    protected static final class IER_ACCOMMODATION_FILTER implements Predicate<Accommodation> {
        private final String assessmentSubjectCode;

        public static IER_ACCOMMODATION_FILTER getInstance(final String assessmentSubjectCode) {
            return new IER_ACCOMMODATION_FILTER(assessmentSubjectCode);
        }

        private IER_ACCOMMODATION_FILTER(final String assessmentSubjectCode) {
            this.assessmentSubjectCode = assessmentSubjectCode;
        }

        @Override
        public boolean apply(final Accommodation accommodation) {
            return StringUtils.equalsIgnoreCase(this.assessmentSubjectCode, accommodation.getSubject());
        }
    };

    protected static final Predicate<ImplicitEligibilityRule> IER_ENABLER = new Predicate<ImplicitEligibilityRule>() {
        @Override
        public boolean apply(final ImplicitEligibilityRule rule) {
            return ImplicitEligibilityRule.RuleType.ENABLER == rule.getRuleType();
        }
    };

    protected static final List<ImplicitEligibilityRule> getImplicitEligibilityRules(final ImplicitEligibilityRule[] implicitEligibilityRuleArray, final ImplicitEligibilityRule.RuleType ruleType) {
        return Lists.newArrayList(Iterables.filter(Lists.newArrayList(implicitEligibilityRuleArray), ImplicitEligibilityRule.RuleType.ENABLER == ruleType ? IER_ENABLER : Predicates.not(IER_ENABLER)));
    }

    public static final Function<Tenant, String> TENANT_ID_TRANSFORMER = new Function<Tenant, String>() {
        @Override
        public String apply(final Tenant tenant) {
            return tenant.getId();
        }
    };

    public static final Function<Assessment, String> ASSESSMENT_TENANTID_TRANSFORMER = new Function<Assessment, String>() {
        @Override
        public String apply(final Assessment assessment) {
            return assessment.getTenantId();
        }
    };

    public static final Function<Assessment, AssessmentModificationEvent> ASSESSMENT_TRANSFORMER = new Function<Assessment, AssessmentModificationEvent>() {
        @Override
        public AssessmentModificationEvent apply(final Assessment assessment) {
            return new AssessmentModificationEvent(assessment, assessment, Action.UPD);
        }
    };

    public static final Comparator<ExplicitEligibility> EXPLICIT_ELIGIBILITY_COMPARATOR = new Comparator<ExplicitEligibility>() {
        @Override
        public int compare(final ExplicitEligibility elig1, final ExplicitEligibility elig2) {
            final String concat1 = elig1.getStudentId() + elig1.getTestName() + elig1.getTestVersion() + elig1.getStateAbbreviation();
            final String concat2 = elig2.getStudentId() + elig2.getTestName() + elig2.getTestVersion() + elig2.getStateAbbreviation();
            return concat1.compareTo(concat2);
        }
    };
    
    public static String generateKey(String grade,String subject){
      String result = null;
      if(grade != null && subject != null){
        result = grade.concat (subject);
      }
      return result;
    }
    
    public static String convertCodeToUpperCase (String code) {
      return code != null ? code.substring (0, 1).toUpperCase ().concat (code.substring (1)) : code;
    }
    
    public static String convertToLowerCase (String code) {
      return code != null ? code.substring (0, 1).toLowerCase ().concat (code.substring (1)): code;
    }
}
