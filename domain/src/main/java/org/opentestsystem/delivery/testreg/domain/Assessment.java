/*
Educational Online Test Delivery System Copyright (c) 2013 American Institutes for Research

Distributed under the AIR Open Source License, Version 1.0 See accompanying file AIR-License-1_0.txt or at
http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 */

package org.opentestsystem.delivery.testreg.domain;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.validation.Valid;
import javax.validation.constraints.Digits;
import javax.validation.constraints.Max;
import javax.validation.constraints.Min;
import javax.validation.constraints.NotNull;

import org.hibernate.validator.constraints.NotBlank;
import org.joda.time.DateTime;
import org.opentestsystem.delivery.testadmin.domain.DateWindow;
import org.opentestsystem.delivery.testadmin.domain.DateWindowable;
import org.opentestsystem.delivery.testadmin.domain.constraints.DuplicateAvailabilityWindow;
import org.opentestsystem.delivery.testadmin.domain.constraints.OverlappingAvailabilityWindow;
import org.opentestsystem.delivery.testreg.domain.constraints.ImplicitRuleSize;
import org.opentestsystem.delivery.testreg.domain.constraints.ImplicitRulesCheck;
import org.opentestsystem.delivery.testreg.domain.constraints.ValidEndWindow;
import org.opentestsystem.delivery.testreg.domain.constraints.ValidOpportunities;
import org.opentestsystem.delivery.testreg.domain.constraints.ValidTestWindow;
import org.opentestsystem.delivery.testreg.domain.search.AssessmentSearchRequest;
import org.opentestsystem.shared.search.domain.AbstractSearchRequest;
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.Transient;
import org.springframework.data.mongodb.core.index.CompoundIndex;
import org.springframework.data.mongodb.core.index.CompoundIndexes;
import org.springframework.data.mongodb.core.mapping.Document;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.google.common.base.Objects;
import com.google.common.collect.Lists;
import com.thoughtworks.xstream.annotations.XStreamAlias;
import com.thoughtworks.xstream.annotations.XStreamConverter;
import com.thoughtworks.xstream.annotations.XStreamOmitField;

@Document
@JsonIgnoreProperties(ignoreUnknown = true, value = {"dateWindows"})
@CompoundIndexes(value = { @CompoundIndex(name = "assessmentAlternate", def = "{'testName':1, 'version':1, 'testLabel':1, 'tenantId':1, 'sourceTsb':1}", unique = true) })
@ValidTestWindow
@ValidOpportunities
@ImplicitRuleSize
@ImplicitRulesCheck
@XStreamAlias("Test")
@XmlOrderSequence({ "subjectCode", "testName", "id", "category", "type", "numGlobalOpportunities", "testWindow", "delayRule" })
@DuplicateAvailabilityWindow(message = "{testwindow.duplicate.invalid}", node = "testWindow.beginWindow")
@OverlappingAvailabilityWindow(message = "{testwindow.overlap.invalid}", node = "testWindow.endWindow")
public class Assessment implements Sb11NonEntity, DateWindowable {

    private static final long serialVersionUID = 6554072621448796168L;
    private static final String GET_RESOURCE_NAME = "/assessment/";
    public static final FormatType FORMAT_TYPE = FormatType.ASSESSMENT;

    @Id
    @XStreamAlias("TestId")
    private String id;

    @FieldLabel("Assessment Identifier")
    @XStreamOmitField
    private String entityId;

    @NotNull(message = "{assessment.numglobalopportunities.required}", groups = { AssessmentValidationGroup.class })
    @Min(value = 1, message = "{assessment.numglobalopportunities.min}", groups = { AssessmentValidationGroup.class })
    @XStreamAlias("MaxOpps")
    private Integer numGlobalOpportunities;

    @Valid
    @NotNull(message = "{assessment.testwindow.required}", groups = { AssessmentValidationGroup.class })
    @XStreamOmitField
    private TestWindow[] testWindow;

    @Min(value = 0, message = "{assessment.delayrule.min}")
    @XStreamAlias("DelayRule")
    private Integer delayRule;

    @NotNull(message = "{assessment.eligibilitytype.required}", groups = { AssessmentValidationGroup.class })
    @XStreamOmitField
    private EligibilityType eligibilityType;

    @XStreamOmitField
    @Valid
    private ImplicitEligibilityRule[] implicitEligibilityRules;

    @XStreamAlias("SubjectCode")
    private String subjectCode;

    @NotNull(message = "{assessment.testname.required}")
    @XStreamAlias("TestName")
    private String testName;

    @NotNull(message = "{assessment.version.required}")
    private String version;

    @XStreamOmitField
    private String tenantId;

    @XStreamOmitField
    @Transient
    private boolean exists;

    @XStreamOmitField
    @Transient
    private boolean updatedVersion;

    @XStreamOmitField
    private List<String> testForm;

    @XStreamOmitField
    private String grade;

    @XStreamAlias("uuid")
    private String uuid;

    @XStreamOmitField
    @NotBlank(message = "{assessment.academic.year.required}", groups = { AssessmentValidationGroup.class })
    @Min(value = 2000, message = "{assessment.academic.year.min}", groups = { AssessmentValidationGroup.class })
    @Max(value = 9999, message = "{assessment.academic.year.max}", groups = { AssessmentValidationGroup.class })
    @Digits(fraction = 0, integer = 4, message = "{assessment.academic.year.digits}", groups = { AssessmentValidationGroup.class })
    private String academicYear;

    @XStreamAlias("Category")
    private String category;

    @XStreamAlias("Type")
    private String type;

    @XStreamOmitField
    private String testLabel;

    // Stub for validator node lookup only
    @XStreamOmitField
    private final String atLeastOneImplicitRule = "";

    @XStreamOmitField
    private String sourceTsb;

    public enum AssessmentType {
        INTERIM("Interim", "interim"), FORMATIVE("Formative", "formative"), SUMMATIVE("Summative", "summative");

        private String description;
        private String value;

        private AssessmentType(final String inDescription, final String inValue) {
            this.description = inDescription;
            this.value = inValue;
        }

        public String getDescription() {
            return description;
        }

        public String getValue() {
            return value;
        }

        public static Set<AssessmentType> getAllTypes() {
            Set<AssessmentType> retSet = new HashSet<>();

            retSet.add(INTERIM);
            retSet.add(FORMATIVE);
            retSet.add(SUMMATIVE);

            return retSet;
        }

        public static Set<String> getTypes() {
            Set<String> retSet = new HashSet<String>();

            retSet.add(INTERIM.value);
            retSet.add(FORMATIVE.value);
            retSet.add(SUMMATIVE.value);

            return retSet;
        }
    }

    public Assessment(final String testName, final String version, final String tenantId) {
        this(null, null, null, testName, version, tenantId, null, null, null);
    }

    public Assessment(final String testName, final String version, final String tenantId, final String testLabel,
            final String sourceTsb) {
        this(null, null, null, testName, version, tenantId, null, testLabel, sourceTsb);
    }

    public Assessment(final String assessmentId, final String packageXml, final String subjectCode,
            final String testName, final String version, final String tenantId, final EligibilityType eligibilityType,
            final String testLabel, final String sourceTsb) {
        this.entityId = assessmentId;
        this.subjectCode = subjectCode;
        this.testName = testName;
        this.version = version;
        this.tenantId = tenantId;
        this.eligibilityType = eligibilityType;
        this.testLabel = testLabel;
        this.sourceTsb = sourceTsb;
    }

    public Assessment() {
        // empty constructor
    }

    public Assessment(final String testName) {
        this(testName, null, null);
    }

    @ValidEndWindow
    @XmlOrderSequence({ "numOpportunities", "beginWindow" })
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class TestWindow implements Serializable, DateWindow {

        private static final long serialVersionUID = -4533846720490445598L;

        @NotNull(message = "{testwindow.beginwindow.required}")
        @XStreamConverter(value = JodaDateTimeXStreamConverter.class, strings = { "yyyy-MM-dd" })
        @XStreamAlias("WindowStart")
        private DateTime beginWindow;

        @NotNull(message = "{testwindow.endwindow.required}")
        @XStreamOmitField
        private DateTime endWindow;

        @Min(value = 1, message = "{assessment.numOpportunities.min}")
        @XStreamAlias("WindowOpps")
        private Integer numOpportunities;

        public TestWindow(final DateTime inBeginWindow, final DateTime inEndWindow, final Integer inNumOpportunities) {
            this.beginWindow = inBeginWindow;
            this.endWindow = inEndWindow;
            this.numOpportunities = inNumOpportunities;
        }

        public TestWindow(final DateTime inBeginWindow, final DateTime inEndWindow) {
            this(inBeginWindow, inEndWindow, 0);
        }

        public TestWindow() {
            this(null, null, null);
        }

        public DateTime getBeginWindow() {
            return beginWindow;
        }

        @JsonDeserialize(using = InvalidFormatBasedDateTimeDeserializer.class)
        public void setBeginWindow(final DateTime inBeginWindow) {
            this.beginWindow = inBeginWindow;
        }

        public DateTime getEndWindow() {
            return endWindow;
        }

        @JsonDeserialize(using = InvalidFormatBasedDateTimeDeserializer.class)
        public void setEndWindow(final DateTime inEndWindow) {
            this.endWindow = inEndWindow;
        }

        public Integer getNumOpportunities() {
            return numOpportunities;
        }

        public void setNumOpportunities(final Integer inNumOpportunities) {
            this.numOpportunities = inNumOpportunities;
        }

        @Override
        public DateTime getStartDateTime() {
            return getBeginWindow();
        }

        @Override
        public DateTime getEndDateTime() {
            return getEndWindow();
        }

        @Override
        public boolean equals(final Object obj) {
            if (obj instanceof TestWindow) {
                DateTime startDateTime = ((DateWindow) obj).getStartDateTime();
                DateTime endDateTime = ((DateWindow) obj).getEndDateTime();
                return (startDateTime.isEqual(getStartDateTime()) && endDateTime.isEqual(getEndDateTime()));
            }
            return false;
        }

        @Override
        public int hashCode() {
            return Objects.hashCode(getStartDateTime(), getEndDateTime());
        }

    }

    public enum EligibilityType {
        EXPLICIT, IMPLICIT;
    }

    public TestWindow[] getTestWindow() {
        if (testWindow == null) {
            testWindow = new TestWindow[] { };
        }

        return testWindow.clone();
    }

    public void setTestWindow(final TestWindow[] inTestWindow) {
        this.testWindow = inTestWindow != null ? inTestWindow.clone() : null;
    }

    public Integer getDelayRule() {
        return delayRule;
    }

    public void setDelayRule(final Integer inDelayRule) {
        this.delayRule = inDelayRule;
    }

    public Integer getNumGlobalOpportunities() {
        return numGlobalOpportunities;
    }

    public void setNumGlobalOpportunities(final Integer inNumGlobalOpportunities) {
        this.numGlobalOpportunities = inNumGlobalOpportunities;
    }

    public EligibilityType getEligibilityType() {
        return eligibilityType;
    }

    public void setEligibilityType(final EligibilityType inEligibilityType) {
        this.eligibilityType = inEligibilityType;
    }

    public ImplicitEligibilityRule[] getImplicitEligibilityRules() {

        if (implicitEligibilityRules == null) {
            implicitEligibilityRules = new ImplicitEligibilityRule[] { };
        }

        return implicitEligibilityRules.clone();
    }

    public void setImplicitEligibilityRules(final ImplicitEligibilityRule[] inImplicitEligibilityRules) {
        this.implicitEligibilityRules = inImplicitEligibilityRules.clone();
    }

    public String getSubjectCode() {
        return subjectCode;
    }

    public void setSubjectCode(final String subjectCode) {
        this.subjectCode = subjectCode;
    }

    public String getTestName() {
        return testName;
    }

    public void setTestName(final String testName) {
        this.testName = testName;
    }

    public String getEntityId() {
        return entityId;
    }

    public void setEntityId(final String entityId) {
        this.entityId = entityId;
    }

    @Override
    public String getId() {
        return id;
    }

    @Override
    public void setId(final String inId) {
        id = inId;
    }

    @Override
    public FormatType getFormatType() {
        return FORMAT_TYPE;
    }

    @JsonProperty
    public String getUrl() {
        return GET_RESOURCE_NAME + this.id;
    }

    @Override
    public Action getAction() {
        return null;
    }

    @Override
    public String[] toStringArray() {
        return new String[] { };
    }

    public String getVersion() {
        return version;
    }

    public void setVersion(final String version) {
        this.version = version;
    }

    public String getTenantId() {
        return tenantId;
    }

    public void setTenantId(final String inTenantId) {
        this.tenantId = inTenantId;
    }

    public List<String> getTestForm() {
        return testForm;
    }

    public void setTestForm(final List<String> testForm) {
        this.testForm = testForm;
    }

    public void addTestForm(final String formName) {
        if (testForm == null) {
            testForm = new ArrayList<String>();
        }
        testForm.add(formName);
    }

    public String getGrade() {
        return grade;
    }

    public void setGrade(final String grade) {
        this.grade = grade;
    }

    public List<ImplicitEligibilityRule> getEnablerRules() {

        List<ImplicitEligibilityRule> enablerRules = new ArrayList<ImplicitEligibilityRule>();

        for (ImplicitEligibilityRule rule : implicitEligibilityRules) {
            if (ImplicitEligibilityRule.RuleType.ENABLER == rule.getRuleType()) {
                enablerRules.add(rule);
            }
        }

        return enablerRules;
    }

    public List<ImplicitEligibilityRule> getDisablerRules() {

        List<ImplicitEligibilityRule> disablerRules = new ArrayList<ImplicitEligibilityRule>();

        for (ImplicitEligibilityRule rule : implicitEligibilityRules) {
            if (ImplicitEligibilityRule.RuleType.DISABLER == rule.getRuleType()) {
                disablerRules.add(rule);
            }
        }

        return disablerRules;
    }

    @Override
    public String getAlternateKey() {
        return new StringBuilder().append("testName: ").append(testName).append(", version: ").append(version)
                .append(", testLabel: ").append(testLabel).append(", sourceTsb: ").append(sourceTsb)
                .append(", tenantId: ").append(tenantId).toString();
    }

    @Override
    public AbstractSearchRequest createAlternateKeySearchRequest() {

        Map<String, String[]> reqMap = new HashMap<String, String[]>();
        reqMap.put("testName", new String[] { testName });
        reqMap.put("version", new String[] { version });
        reqMap.put("testLabel", new String[] { testLabel });
        reqMap.put("sourceTsb", new String[] { sourceTsb });
        reqMap.put("tenantId", new String[] { tenantId });

        AssessmentSearchRequest request = new AssessmentSearchRequest(reqMap);

        return request;
    }

    // equals and hashcode, only on alternate key fields
    @Override
    public boolean equals(final Object obj) {

        if (obj instanceof Assessment) {
            Assessment assess = (Assessment) obj;

            return com.google.common.base.Objects.equal(testName, assess.getTestName())
                    && com.google.common.base.Objects.equal(version, assess.getVersion())
                    && com.google.common.base.Objects.equal(testLabel, assess.getTestLabel())
                    && com.google.common.base.Objects.equal(tenantId, assess.getTenantId())
                    && com.google.common.base.Objects.equal(sourceTsb, assess.getSourceTsb());
        }

        return false;
    }

    // hashcode is only computed on the alternate key
    @Override
    public int hashCode() {
        return com.google.common.base.Objects.hashCode(testName, version, testLabel, tenantId, sourceTsb);
    }

    public boolean isExists() {
        return exists;
    }

    public void setExists(final boolean exists) {
        this.exists = exists;
    }

    public boolean isUpdatedVersion() {
        return updatedVersion;
    }

    public void setUpdatedVersion(final boolean updatedVersion) {
        this.updatedVersion = updatedVersion;
    }

    public String getAcademicYear() {
        return academicYear;
    }

    public void setAcademicYear(final String academicYear) {
        this.academicYear = academicYear;
    }

    @Override
    public String toString() {
        return Objects.toStringHelper(getClass()).add("id", id).add("entityId", entityId)
                .add("subjectCode", subjectCode).add("testName", testName).add("version", version)
                .add("sourceTsb", sourceTsb).add("testLabel", testLabel).add("tenantId", tenantId).add("grade", grade)
                .add("academicYear", academicYear).add("category", category).add("type", type).toString();

    }

    public String getCategory() {
        return category;
    }

    public void setCategory(final String category) {
        this.category = category;
    }

    public String getType() {
        return type;
    }

    public void setType(final String type) {
        this.type = type;
    }

    public String getAtLeastOneImplicitRule() {
        return atLeastOneImplicitRule;
    }

    public String getTestLabel() {
        return testLabel;
    }

    public void setTestLabel(final String testLabel) {
        this.testLabel = testLabel;
    }

    public String getSourceTsb() {
        return sourceTsb;
    }

    public void setSourceTsb(final String sourceTsb) {
        this.sourceTsb = sourceTsb;
    }

    @Override
    public List<DateWindow> getDateWindows() {
        List<DateWindow> dateWindows = Lists.newArrayList();
        if(getTestWindow() == null) {
            return dateWindows;
        }

        for(TestWindow testWindow: getTestWindow()) {
            dateWindows.add(testWindow);
        }
        return dateWindows;
    }

}
