/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/

package org.opentestsystem.delivery.testadmin.domain.constraintvalidators;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;

import org.joda.time.Interval;
import org.opentestsystem.delivery.testadmin.domain.Proctor;
import org.opentestsystem.delivery.testadmin.domain.Proctor.AvailabilityWindow;
import org.opentestsystem.delivery.testadmin.domain.constraints.OverlappingAvailabilityWindow;
import org.springframework.beans.factory.annotation.Autowired;

public class OverlappingAvailabilityWindowValidator implements ConstraintValidator<OverlappingAvailabilityWindow, Proctor> {
    
    @Autowired
    private DuplicateWindowValidationUtil duplicateWindowValidationUtil;
    
    private static final Comparator<Interval> INTERVAL_OVERLAP_COMPARATOR = new IntervalOverlapComparator();
    
    @Override
    public void initialize(OverlappingAvailabilityWindow constraintAnnotation) {
     }

    @Override
    public boolean isValid(Proctor proctor, ConstraintValidatorContext context) {
        boolean isValid = true;
        
        if(!duplicateWindowValidationUtil.hasDuplicateWindows(proctor)) {
            Set<Interval> intervalOverlapSet  = new TreeSet<Interval>(INTERVAL_OVERLAP_COMPARATOR);
            
            List<Interval> intervals = getIntervals(proctor.getAvailabilityWindow());
            
            context.disableDefaultConstraintViolation();            
            for(int i=0; i< intervals.size(); i++) {
                Interval interval = intervals.get(i);
                if(!intervalOverlapSet.add(interval)) {
                    isValid = false;
                    context.buildConstraintViolationWithTemplate(context.getDefaultConstraintMessageTemplate())
                    .addPropertyNode("availabilityWindow")
                    .addPropertyNode("startDateTime")
                    .inIterable().atIndex(i)
                    .addConstraintViolation();
                }
            }      
        }        
        return isValid;
    }
    
    private List<Interval> getIntervals(List<AvailabilityWindow> availabilityWindowList) {
        List<Interval> list = new ArrayList<>();
        
        for(AvailabilityWindow availabilityWindow: availabilityWindowList) {
            if(haveValidDates(availabilityWindow)) {
                list.add(new Interval(availabilityWindow.getStartDateTime(), availabilityWindow.getEndDateTime()));
            }
        }
        return list;
    }
    
    private static class IntervalOverlapComparator implements Comparator<Interval> {

        @Override
        public int compare(Interval o1, Interval o2) {
            if(o1.overlaps(o2)) return 0;
            else return 1;
        }
        
    }
    
    private boolean haveValidDates(AvailabilityWindow windowObj) {
        if(windowObj.getEndDateTime() ==null) return false;
        return !windowObj.getEndDateTime().isBefore(windowObj.getStartDateTime());
    }

}
