/*******************************************************************************
 * Educational Online Test Delivery System
 * Copyright (c) 2013 American Institutes for Research
 * 
 * Distributed under the AIR Open Source License, Version 1.0
 * See accompanying file AIR-License-1_0.txt or at
 * http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 ******************************************************************************/

package org.opentestsystem.delivery.testadmin.domain;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

import javax.validation.Valid;
import javax.validation.constraints.NotNull;

import org.apache.commons.collections.CollectionUtils;
import org.joda.time.DateTime;
import org.joda.time.Interval;
import org.opentestsystem.delivery.testadmin.domain.Affinity.AffinityRule;
import org.opentestsystem.delivery.testadmin.domain.Affinity.AffinityType;
import org.opentestsystem.delivery.testadmin.domain.constraints.DuplicateAvailabilityWindow;
import org.opentestsystem.delivery.testadmin.domain.constraints.OverlappingAvailabilityWindow;
import org.opentestsystem.delivery.testadmin.domain.constraints.ValidEndTime;
import org.opentestsystem.delivery.testreg.domain.User;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.index.CompoundIndex;
import org.springframework.data.mongodb.core.index.CompoundIndexes;
import org.springframework.data.mongodb.core.mapping.Document;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.google.common.base.Objects;

@Document
@JsonIgnoreProperties(ignoreUnknown = true)
@CompoundIndexes(value = { @CompoundIndex(name = "userMongoId", def = "{'user._id':1}", unique = true) })
@DuplicateAvailabilityWindow(message = "{timeperiod.duplicate.invalid}")
@OverlappingAvailabilityWindow(message = "{timeperiod.overlap.invalid}")
public class Proctor implements TestAdminBase {

    private static final long serialVersionUID = 1830323774952289118L;

    private static final String GET_RESOURCE_NAME = "/proctor/";

    @Id
    private String id;

    @Valid
    private List<Affinity> affinities;

    @Valid
    private List<AvailabilityWindow> availabilityWindow;

    private User user;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public void setAvailabilityWindow(List<AvailabilityWindow> availabilityWindows) {
        this.availabilityWindow = availabilityWindows;
    }

    public void addTimePeriods(List<AvailabilityWindow> availabilityWindows) {
        if (getAvailabilityWindow() == null || getAvailabilityWindow().isEmpty()) {
            setAvailabilityWindow(new ArrayList<AvailabilityWindow>());
        }
        getAvailabilityWindow().addAll(availabilityWindows);
    }

    public List<AvailabilityWindow> getAvailabilityWindow() {
        return availabilityWindow;
    }

    @ValidEndTime
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class AvailabilityWindow implements Serializable {

        private static final long serialVersionUID = 8156730549695535082L;

        @NotNull(message = "{timeperiod.starttime.required}")
        private DateTime startDateTime;

        @NotNull(message = "{timeperiod.endtime.required}")
        private DateTime endDateTime;

        @NotNull(message = "{timeperiod.availability.empty}")
        private Availability availability;

        public AvailabilityWindow() {
            this(null, null, null);
        }

        public AvailabilityWindow(DateTime startTime, DateTime endTime, Availability availability) {
            this.startDateTime = startTime;
            this.endDateTime = endTime;
            this.availability = availability;
        }

        public DateTime getStartDateTime() {
            return startDateTime;
        }

        @JsonDeserialize(using = TZBasedDateTimeDeserialier.class)
        public void setStartDateTime(DateTime startTime) {
            this.startDateTime = startTime;
        }

        public DateTime getEndDateTime() {
            return endDateTime;
        }

        @JsonDeserialize(using = TZBasedDateTimeDeserialier.class)
        public void setEndDateTime(DateTime endTime) {
            this.endDateTime = endTime;
        }

        public Availability getAvailability() {
            return availability;
        }

        public void setAvailability(Availability availability) {
            this.availability = availability;
        }

        @Override
        public boolean equals(Object obj) {
            if (obj instanceof AvailabilityWindow) {
                DateTime startDateTime = ((AvailabilityWindow) obj).getStartDateTime();
                DateTime endDateTime = ((AvailabilityWindow) obj).getEndDateTime();
                return (startDateTime.isEqual(getStartDateTime()) && endDateTime.isEqual(getEndDateTime()));
            }
            return false;
        }

        @Override
        public int hashCode() {
            return Objects.hashCode(getStartDateTime(), getEndDateTime());
        }
    }

    public List<Affinity> getAffinities() {
        return affinities;
    }

    public void setAffinities(List<Affinity> affinities) {
        this.affinities = affinities;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    public boolean hasSubjectAffinity() {
        if (hasAffinities()) {
            for (Affinity affinity : this.affinities) {
                if (affinity.getType() == AffinityType.SUBJECT) {
                    return true;
                }
            }
        }
        return false;
    }

    public boolean hasGradeAffinity() {
        if (hasAffinities()) {
            for (Affinity affinity : this.affinities) {
                if (affinity.getType() == AffinityType.GRADE) {
                    return true;
                }
            }
        }
        return false;
    }

    public boolean hasAssessmentAffinity() {
        if (hasAffinities()) {
            for (Affinity affinity : this.affinities) {
                if (affinity.getType() == AffinityType.ASSESSMENT) {
                    return true;
                }
            }
        }
        return false;
    }

    @JsonProperty
    public String getUrl() {
        return GET_RESOURCE_NAME + this.id;
    }

    public boolean isAvailableForTimeSlot(final TimeSlot timeSlot) {

        // if the user has not setup any availability windows just return true so the proctor can be scheduled
        // if (availabilityWindow == null || availabilityWindow.isEmpty()) {
        // return true;
        // } // this is for TESTADMIN-323 which is not yet complete

        Interval timeSlotInterval = new Interval(timeSlot.getStartTime(), timeSlot.getEndTime());

        boolean passesAvailable = false;
        boolean passesUnavailable = true;

        for (AvailabilityWindow window : availabilityWindow) {
            if (!passesAvailable || passesUnavailable) {
                Interval windowInterval = new Interval(window.getStartDateTime(), window.getEndDateTime());

                if (Availability.AVAILABLE == window.getAvailability()) {

                    if (windowInterval.contains(timeSlotInterval)) {
                        passesAvailable = true;
                    }

                } else if (Availability.NOTAVAILABLE == window.getAvailability()) {

                    if (windowInterval.contains(timeSlotInterval) || windowInterval.overlaps(timeSlotInterval)) {
                        passesUnavailable = false;
                    }
                }
            }
        }

        return passesAvailable && passesUnavailable;
    }

    public boolean hasStrictAffinity() {
        for (Affinity affinity : this.affinities) {
            if (affinity.getRule() == AffinityRule.STRICT) {
                return true;
            }
        }
        return false;
    }

    public Affinity findFirstStrictAffinity() {
        for (Affinity affinity : this.affinities) {
            if (affinity.getRule() == AffinityRule.STRICT) {
                return affinity;
            }
        }
        return null;
    }

    public boolean hasAffinities() {
        return CollectionUtils.isNotEmpty(affinities);
    }

}