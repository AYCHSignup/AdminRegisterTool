/*
Educational Online Test Delivery System Copyright (c) 2013 American Institutes for Research

Distributed under the AIR Open Source License, Version 1.0 See accompanying file AIR-License-1_0.txt or at
http://www.smarterapp.org/documents/American_Institutes_for_Research_Open_Source_Software_License.pdf
 */

package org.opentestsystem.delivery.testadmin.domain.schedule;

import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

import org.bson.types.ObjectId;
import org.opentestsystem.delivery.testadmin.domain.Affinity;
import org.opentestsystem.delivery.testadmin.domain.Proctor;
import org.opentestsystem.delivery.testadmin.domain.TimeSlot;
import org.springframework.data.annotation.Id;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

/**
 * A ScheduledTimeSlot is associated with a Proctor and a number of ScheduledSeats
 * 
 */
@JsonIgnoreProperties(ignoreUnknown = true)
public class ScheduledTimeSlot extends TimeSlot implements Comparable<TimeSlot> {

    private static final long serialVersionUID = -4555955110011941313L;
    
    private Set<ScheduledSeat> seats;

    private Proctor proctor;

    private Set<String> assignedStudents; // stores assigned student ids for this timeslot so student is not assigned
                                          // multiple times

    private boolean manuallyScheduledProctor;

    private Set<Affinity> affinitiesScheduled;

    private TimeSlot originalTimeSlot; // There would no setter for this property to directly manipulate the value.

    public ScheduledTimeSlot() {
        super();
        seats = new HashSet<ScheduledSeat>(10);
        assignedStudents = new HashSet<String>(10);
        affinitiesScheduled = new HashSet<Affinity>();
    }

    public ScheduledTimeSlot(TimeSlot timeSlot) {
        this();
        this.originalTimeSlot = timeSlot; // set the original value. Used for purpose of readOnly to see the unmodified
                                          // value in contrast to mutable StartTime and EndTime
        this.affinities = timeSlot.getAffinities();
        this.startTime = timeSlot.getStartTime();
        this.endTime = timeSlot.getEndTime();
    }    

    public String getId() {
        return super.getId();
    }

    public Set<String> getAssignedStudents() {
        return assignedStudents;
    }

    public void setAssignedStudents(Set<String> assignedStudents) {
        this.assignedStudents = assignedStudents;
    }

    public Set<ScheduledSeat> getSeats() {
        return seats;
    }

    public void setSeats(Set<ScheduledSeat> seats) {
        this.seats = seats;
    }

    public void addSeat(ScheduledSeat seat) {
        seats.add(seat);
    }

    public Proctor getProctor() {
        return proctor;
    }

    public void setProctor(Proctor proctor) {
        this.proctor = proctor;
    }

    public boolean hasUnscheduledSeat() {
        for (ScheduledSeat seat : this.getSeats()) {
            if (!seat.isSeatScheduled()) {
                return true;
            }
        }
        return false;
    }

    @JsonIgnore
    public Set<ScheduledSeat> getAllUnscheduledSeats() {
        Set<ScheduledSeat> unschedSeats = new HashSet<ScheduledSeat>();

        for (ScheduledSeat seat : seats) {
            if (!seat.isSeatScheduled()) {
                unschedSeats.add(seat);
            }
        }

        return unschedSeats;
    }

    @JsonIgnore
    public Set<ScheduledSeat> getUnscheduledSeatsWithAccessbilityEquip() {

        Set<ScheduledSeat> unschedSeats = new HashSet<ScheduledSeat>();

        for (ScheduledSeat seat : seats) {
            if (!seat.isSeatScheduled() && seat.getAccessibilityEquipments() != null
                    && !seat.getAccessibilityEquipments().isEmpty()) {
                unschedSeats.add(seat);
            }
        }

        return unschedSeats;
    }

    @JsonIgnore
    public int getNumberOfAssignedSeats() {
        int count = 0;
        for (ScheduledSeat seat : this.getSeats()) {
            if (seat.isSeatScheduled()) {
                count++;
            }
        }
        return count;
    }

    @Override
    public boolean equals(Object obj) {

        if (obj == null) {
            return false;
        }

        if (!(obj instanceof ScheduledTimeSlot)) {
            return false;
        }

        ScheduledTimeSlot otherObj = (ScheduledTimeSlot) obj;

        return super.equals(obj) && Objects.equals(this.proctor, otherObj.getProctor())
                && Objects.equals(this.seats, otherObj.getSeats());
    }

    @Override
    public int hashCode() {

        return Objects.hash(super.hashCode(), this.proctor, this.seats);
    }

    /**
     * Order based on start time
     */
    @Override
    public int compareTo(TimeSlot o) {
        return this.startTime.compareTo(o.getStartTime());
    }

    public boolean isManuallyScheduledProctor() {
        return manuallyScheduledProctor;
    }

    public void setManuallyScheduledProctor(final boolean inManuallyScheduledProctor) {
        this.manuallyScheduledProctor = inManuallyScheduledProctor;
    }

    @JsonIgnore
    public int getTotalNumberSeats() {
        return seats.size();
    }

    public boolean isStrictAffinityScheduled() {

        for (Affinity affinity : affinitiesScheduled) {
            if (affinity.isStrict()) {
                return true;
            }
        }

        return false;
    }

    public Set<Affinity> getAffinitiesScheduled() {
        return affinitiesScheduled;
    }

    public void addScheduledAffinity(final Affinity scheduledAffinity) {
        affinitiesScheduled.add(scheduledAffinity);
    }

    public void removeScheduledAffinities() {
        affinitiesScheduled.clear();
    }

    @JsonIgnore
    public int getNumberOfUnscheduledSeats() {

        return getTotalNumberSeats() - getNumberOfAssignedSeats();

    }

    public TimeSlot getOriginalTimeSlot() {
        return originalTimeSlot;
    }

    @JsonIgnore
    public Set<ScheduledSeat> getSeatsWithAccessbilityEquip() {

        Set<ScheduledSeat> seats = new HashSet<ScheduledSeat>();

        for (ScheduledSeat seat : seats) {
            if (seat.getAccessibilityEquipments() != null && !seat.getAccessibilityEquipments().isEmpty()) {
                seats.add(seat);
            }
        }

        return seats;
    }

    public boolean isTimeslotCompletelyEmpty() {
        return getTotalNumberSeats() == getNumberOfUnscheduledSeats();
    }
}
